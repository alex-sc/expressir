--- START FILE: .github/workflows/codeql.yml ---
name: "CodeQL"

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 23 * * 3'
  workflow_dispatch:

concurrency:
  group: '${{ github.workflow }}-${{ github.job }}-${{ github.head_ref || github.ref_name }}'
  cancel-in-progress: true

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Ruby
        uses: ruby/setup-ruby@master
        with:
          ruby-version: 3.2
          bundler-cache: true

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: "ruby, cpp"

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
--- END FILE: .github/workflows/codeql.yml ---
--- START FILE: .github/workflows/rake.yml ---
name: rake

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '**.adoc'
      - '**.md'
      - .github/workflows/release.yml
      - .github/workflows/codeql.yml
  pull_request:
  workflow_dispatch:

concurrency:
  group: '${{ github.workflow }}-${{ github.job }}-${{ github.head_ref || github.ref_name }}'
  cancel-in-progress: true

env:
  RUBYGEM_VER: 3.4.22

jobs:
  rubocop:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.2
          bundler-cache: true

      - name: Rubocop
        run: bundle exec rake rubocop

  rake:
    name: test on ruby-${{ matrix.ruby }} ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        ruby: [ '3.3', '3.2', '3.1', '3.0', '2.7' ]
        os: [ ubuntu-latest, windows-latest, macos-latest ]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true

      - name: Run tests
        run: |
          bundle exec rake
          cat .rspec_status

  rake-alpine:
    name: test on ruby-${{ matrix.ruby }} alpine container
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        ruby: [ '3.3', '3.2', '3.1', '3.0', '2.7' ]
    container: ruby:${{ matrix.ruby }}-alpine
    steps:
      - name: Install packages
        run: |
          apk --no-cache --upgrade add build-base git bash tar

      - name: Checkout
        uses: actions/checkout@v4

      - name: Upgrade RubyGems
        if: matrix.ruby == '3.0' || matrix.ruby == '2.7'
        run: gem update --system ${{ env.RUBYGEM_VER }} --no-document

      - name: Bundle
        run: |
          git config --global --add safe.directory $PWD
          bundle install --jobs 4 --retry 3

      - name: Run tests
        run: |
          bundle exec rake
          cat .rspec_status

  # test release workflow
  pack-ruby:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Build gem without native extension
        run: gem build expressir.gemspec

      - name: Package gem without native extension
        uses: actions/upload-artifact@v4
        with:
          name: pkg-ruby
          path: expressir-*.gem

  pack:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        platform: [ linux-gnu, linux-musl, windows, darwin ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Package gem with native extension
        uses: actions/upload-artifact@v4
        with:
          name: pkg-${{ matrix.platform }}
          path: pkg/*.gem

  verify-ruby:
    name: verify ruby gem on ruby-${{ matrix.ruby }} ${{ matrix.os }}
    needs: pack-ruby
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        ruby: [ '3.3', '3.2', '3.1', '3.0', '2.7' ]
        os: [ ubuntu-latest, windows-latest, macos-latest ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true

      - name: Download packaged gem
        uses: actions/download-artifact@v4
        with:
         name: pkg-ruby
         path: pkg

      - name: Install gem
        run: gem install -l pkg/expressir-*.gem

      - name: Verify
        run: |
          cd $(ruby -e "puts Gem::Specification.find_by_name('expressir').gem_dir")
          ruby bin/rspec
          cat .rspec_status || echo ".rspec_status was not found"
--- END FILE: .github/workflows/rake.yml ---
--- START FILE: .github/workflows/release.yml ---
name: release

on:
  workflow_dispatch:
    inputs:
      next_version:
        description: |
          Next release version. Possible values: x.y.z, major, minor, patch or pre|rc|etc
        required: true
        default: 'patch'
  push:
    tags: [ v* ]

concurrency:
  group: '${{ github.workflow }}-${{ github.job }}-${{ github.head_ref || github.ref_name }}'
  cancel-in-progress: true

jobs:
  bump:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: ruby/setup-ruby@master
        with:
          ruby-version: '3.2'

      - if: ${{ github.event_name == 'workflow_dispatch' }} # unfortunatelly cannot keep this condition on job level
        run: |
          git config --global user.name github-actions
          git config --global user.email github-actions@github.com
          gem install gem-release
          gem bump --version ${{ github.event.inputs.next_version }} --tag --push

  pack:
    runs-on: ubuntu-latest
    needs: bump
    strategy:
      fail-fast: false
      matrix:
        platform: [ linux-gnu, linux-musl, windows, darwin ]
    steps:
      - uses: actions/checkout@v4

      - uses: ruby/setup-ruby@master
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Build gem and save version
        if: matrix.platform == 'linux-gnu'
        run: |
          gem build expressir.gemspec | grep -o 'Version: .*' | awk '{print $2}' > version

      - if: matrix.platform == 'linux-gnu'
        uses: actions/upload-artifact@v4
        with:
          name: pkg-ruby
          path: expressir-*.gem

      - if: matrix.platform == 'linux-gnu'
        uses: actions/upload-artifact@v4
        with:
          name: version
          path: version

      # build gem WITH pre-built native extension
      - run: bundle exec rake gem:${{ matrix.platform }}

      - uses: actions/upload-artifact@v4
        with:
          name: pkg-${{ matrix.platform }}
          path: pkg/*.gem

  publish:
    runs-on: ubuntu-latest
    needs: pack
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: pkg-ruby
          path: pkg

      - uses: actions/download-artifact@v4
        with:
          name: pkg-linux-gnu
          path: pkg

      - uses: actions/download-artifact@v4
        with:
          name: pkg-linux-musl
          path: pkg

      - uses: actions/download-artifact@v4
        with:
          name: pkg-windows
          path: pkg

      - uses: actions/download-artifact@v4
        with:
          name: pkg-darwin
          path: pkg

      - uses: ruby/setup-ruby@master
        with:
          ruby-version: '3.1'

      - name: Publish to rubygems.org
        env:
          RUBYGEMS_API_KEY: ${{ secrets.LUTAML_CI_RUBYGEMS_API_KEY }}
        run: |
          ls -l pkg/
          mkdir -p ~/.gem
          cat > ~/.gem/credentials << EOF
          ---
          :rubygems_api_key: ${RUBYGEMS_API_KEY}
          EOF
          chmod 0600 ~/.gem/credentials
          gem signin
          for gem in pkg/*.gem; do gem push $gem -V; done
          sleep 15

  verify:
    name: Verify published gem on ${{ matrix.os }}
    needs: publish
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
    steps:
      - name: Install Ruby
        uses: ruby/setup-ruby@master
        with:
          ruby-version: 3.2
          bundler-cache: true

      - name: Download version
        uses: actions/download-artifact@v4
        with:
         name: version

      - name: Install gem
        run: gem install expressir -v $(cat version)

      - name: Verify
        run: expressir version

  verify-alpine:
    name: Verify published gem on alpine
    needs: publish
    runs-on: ubuntu-latest
    container:
      image: alpine:3.17
    steps:
      - name: Install packages
        run: apk --no-cache add bash build-base git ruby-dev gcc g++ automake

      - name: Download version
        uses: actions/download-artifact@v4
        with:
         name: version

      - name: Install gem
        run: gem install expressir -v $(cat version)

      - name: Verify
        run: expressir version
--- END FILE: .github/workflows/release.yml ---
--- START FILE: .github/workflows/stress.yml ---
name: stress

on:
  workflow_dispatch:

concurrency:
  group: '${{ github.workflow }}-${{ github.job }}-${{ github.head_ref || github.ref_name }}'
  cancel-in-progress: true

env:
  GC_STRESS: true

jobs:
  rake:
    name: test on ruby-${{ matrix.ruby }} ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        ruby: [ '3.2', '3.1', '3.0', '2.7' ]
        os: [ ubuntu-latest, windows-latest, macos-latest ]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Ruby
        uses: ruby/setup-ruby@master
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true

      - name: Run tests
        run: |
          bundle exec rake
          cat .rspec_status
--- END FILE: .github/workflows/stress.yml ---
--- START FILE: Gemfile ---
# frozen_string_literal: true

source "https://rubygems.org"

# Specify your gem's dependencies in reeper.gemspec
gemspec

# gem "asciidoctor", "~> 2.0.13"
gem "pry"
gem "rake", "~> 13.0"
gem "rspec", "~> 3.0"
gem "rubocop", "~> 1.21"
gem "rubocop-performance", require: false
gem "rubocop-rake", require: false
gem "rubocop-rspec", require: false
gem "webrick", "~> 1.7"
gem "yard", "~> 0.9"
--- END FILE: Gemfile ---
--- START FILE: README.adoc ---
= Expressir: EXPRESS in Ruby

image:https://img.shields.io/gem/v/expressir.svg["Gem Version", link="https://rubygems.org/gems/expressir"]
// image:https://codeclimate.com/github/lutaml/expressir/badges/gpa.svg["Code Climate", link="https://codeclimate.com/github/lutaml/expressir"]
image:https://github.com/lutaml/expressir/workflows/rake/badge.svg["Build Status", link="https://github.com/lutaml/expressir/actions?workflow=rake"]

== Purpose

Expressir ("`EXPRESS in Ruby`") is a Ruby parser for EXPRESS and
a set of Ruby tools for accessing ISO EXPRESS data models.

== Architecture

Expressir consists of 3 parts:

. Parsers. A parser allows Expressir to read EXPRESS files, including:

** EXPRESS data modelling language (ISO 10303-11:2007)
** EXPRESS data modelling language in XML (STEPmod)
** EXPRESS XML (ISO 10303-28:2007)
"`Industrial automation systems and integration — Product data representation and exchange — Part 28: Implementation methods: XML representations of EXPRESS schemas and data, using XML schemas`"

. Data model. The data model (`lib/expressir/express`) is the Ruby data model that fully represents an EXPRESS data model.

. Converters. A converter transforms the EXPRESS Ruby data model into an interoperable export format, including:
** EXPRESS data modelling language (ISO 10303-11:2007)
// ** W3C OWL
// ** OMG SysML (XMI 2.1, XMI 2.5)
// ** OMG UML 2 (XMI 2.1)
// ** OMG UML 2 for Eclipse (XMI 2.1)


== Usage

This gem ships with a CLI tool. To check what's available you can simply run
`expressir`, by default it will display some usage instructions.

[source, sh]
----
$ expressir

Commands:
  expressir format PATH     # pretty print EXPRESS schema located at PATH
  expressir help [COMMAND]  # Describe available commands or one specific command
  expressir version         # The Expressir Version
----

=== Pretty print

[source, sh]
----
expressir format schemas/resources/action_schema/action_schema.exp
----


== Development

We are following Sandi Metz's Rules for this gem, you can read
the http://robots.thoughtbot.com/post/50655960596/sandi-metz-rules-for-developers[description of the rules here] All new code should follow these rules.
If you make changes in a pre-existing file that violates these rules you should
fix the violations as part of your contribution.

=== Setup

Clone the repository.

[source, sh]
----
git clone https://github.com/metanorma/expressir
----

Setup your environment.

[source, sh]
----
bin/setup
git submodule update --init
bundle exec rake generate
bundle exec rake compile
----

Run the test suite

[source, sh]
----
bundle exec rake
----



== Installation

Add this line to your application's `Gemfile`:

[source, sh]
----
gem "expressir"
----

And then execute:

[source, sh]
----
$ bundle install
----

Or install it yourself as:

[source, sh]
----
$ gem install expressir
----


== Usage

=== Filtering out schemas

Use the `select_proc` argument of `to_hash`.

Example:

[source,ruby]
----

schema_yaml = YAML.load_file('documents/iso-10303-41/schemas.yaml')
schema_paths = schema_yaml['schemas'].map {|x,y| y['path'].gsub("../../", "")}

repo = Expressir::Express::Parser.from_files(schema_paths)

filtered_schemas = ["action_schema", "date_time_schema"]
select_proc = Proc.new do |value|
  if value.is_a?(Expressir::Model::Declarations::Schema)
    filtered_schemas.include?(value.id)
  else
    true
  end
end

repo_hash = repo.to_hash(select_proc: select_proc)
schemas = repo_hash['schemas']
schemas.map {|s| s["id"] }
----

== Contributing

First, thank you for contributing! We love pull requests from everyone. By
participating in this project, you hereby grant
https://www.ribose.com[Ribose Inc.] the right to grant or transfer an unlimited
number of non exclusive licenses or sub-licenses to third parties, under the
copyright covering the contribution to use the contribution by all means.

Here are a few technical guidelines to follow:

* Open an https://github.com/lutaml/expressir/issues[issues] to discuss a new
  feature.
* Write tests to support your new feature.
* Make sure the entire test suite passes locally and on CI.
* Open a Pull Request.
* https://github.com/thoughtbot/guides/tree/master/protocol/git#write-a-feature[Squash your commits] after receiving feedback.
* Party!


== License

Expressir is distributed under the BSD 2-clause license.

Expressir originally contained some code from the NIST Reeper project but
has been completely rewritten.

The https://www.nist.gov/services-resources/software/reeper[NIST Reeper license]
is reproduced below:

[quote]
____
This software was funded by NIST and developed by EuroSTEP.
Pursuant to title 17 Section 105 of the United States Code this
software is not subject to copyright protection and is in the public
domain.

We would appreciate acknowledgment if the software is used. Links to
non-Federal Government Web sites do not imply NIST endorsement of any
particular product, service, organization, company, information
provider, or content.
____


== Credits

Copyright Ribose Inc.
--- END FILE: README.adoc ---
--- START FILE: Rakefile ---
# frozen_string_literal: true

require "bundler/gem_tasks"
require "rspec/core/rake_task"

RSpec::Core::RakeTask.new(:spec)

require "rubocop/rake_task"

RuboCop::RakeTask.new

task default: %i[spec rubocop]

require "yard"

YARD::Rake::YardocTask.new
--- END FILE: Rakefile ---
--- START FILE: docs/development.md ---
## Development Plan

This document is a draft to understand the basic of the original library, and
how the whole tool chain is working at the moment. Once, we've an understanding
then let's look at the potential area of improvement, and plan out a high level
plan to start the development.

### What is it, expressir?

* Expressir is a ruby tool to harvest iso express data model
* Express is one of the language to represent data model
* Expressir tool is used to manipulate iso express data model
* The input for the expressir is a standard xml document
* XML Spec: http://stepmod.sourceforge.net/express_model_spec/
* Expressir does the job of representing express model as ruby class
* REXML-based parser that reads EXPRESS as XML and creates the dictionary (i.e.
  instances of the EXPRESS Ruby Classes) and then calls a mapper, that may be
  specified as an option at runtime
* Mappers that read the EXPRESS dictionary and perform the conversion to the
  desired language or format
* Express to UML2 Mapper - Convert the express model to UML2
* Express to OWL Structure - Convert the express model to OWL Structure
* Ruby API generator for express language
* Current Ruby API is super slow, it takes 2 hours to generate 400 entity

### How does the original version work?

At the core the `expressir.rb` is responsible for everything at moment, it takes
an Express XML file as an input and then it parses that XML file and build the
correct ruby interface for further processing.

This `expressir.rb` also expect one mapping file `deafult to mapping.rb`, and it
also expect the file to specify a custom method `map_from_express` to take the
`Ruby Express Representation` and convert this ruby representation to the
desire output format.

The library also provides couple mapping for UM2, OWL and SysML, so anyone can
export their data to any of those format if necessary, and the use cases for
those library are as following:

```ruby
ruby expressir.rb expxml=<schema.xml> map=<mapping_owl.rb>
```

### What are potential improvement area?

* The interface is not well defined, someone needs to dig deeper to understand
  just the basic of the library and how to use for their use cases. This is
  something that could be improved as initial step.
* At the moment, these are some ruby files, so potentially we could group those
  together as a CLI tool and group some of the common functionality, and provide
  a straight forward interface for users.
* The good part about this library is author had the extensibility in mind from
  the beginning, so we should keep that functionality as flexible as possible.
* There are lot of boilerplate code in the library, but it's understandable as
  it was written quite long time ago, so maybe most of the tool was not even
  available back then, so this is the another area we could improve.
* Another improvement we could do in terms of actual codebase, we should be able
  to refactor this library and cleanup as much as possible.

### What are the initial changes?

Initially, we can start by creating a ruby cli gem, group these functionality
together. This could be named as `expressir`, and this gem will be shipped with an
executable called `expressir`.

Second of all, let's add some dedicated interface for the default type, so user
does not need to know all the details but the name of the interface, for example
we could expose the transformation as follows:

```sh
# Convert to owl
expressir express2owl file=[express_xml_file] [**options]

# Convert to UML
expressir express2uml file=[express_xml_file] [**options]

# Convert to SysML
expressir express2sysml file=[express_xml_file] [**options]

# Custom conversion
expressir express2custom file=[express_xml_file] mapping=[custom_mapping.rb]
```

Third of all once this library is functional as the original version then we
will go through each of the existing types, and refactor those as necessary.

### References

* https://martinfowler.com/bliki/MovingToNokogiri.html
--- END FILE: docs/development.md ---
--- START FILE: expressir.gemspec ---
lib = File.expand_path("lib", __dir__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require "expressir/version"

Gem::Specification.new do |spec|
  spec.name = "expressir"
  spec.version = Expressir::VERSION
  spec.authors = ["Ribose Inc."]
  spec.email = ["open.source@ribose.com"]

  spec.summary = "EXPRESS parser and toolkit for Ruby"
  spec.description = "Expressir (“EXPRESS in Ruby”) is a Ruby parser for EXPRESS and a set of tools for accessing EXPRESS data models."

  spec.homepage = "https://github.com/lutaml/expressir"
  spec.license = "BSD-2-Clause"

  spec.bindir = "exe"
  spec.require_paths = ["lib"]
  spec.required_ruby_version = Gem::Requirement.new(">= 3.0.0")

  spec.metadata["homepage_uri"] = spec.homepage
  spec.metadata["source_code_uri"] = spec.homepage
  spec.metadata["changelog_uri"] = "https://github.com/lutaml/expressir/releases"

  spec.required_ruby_version = Gem::Requirement.new(">= 2.7.0")

  spec.files = Dir.chdir(File.expand_path(__dir__)) do
    `git ls-files -z`.split("\x0").reject do |f|
      f.match(%r{^(test|features)/})
    end
  end

  spec.executables = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
  spec.test_files = `git ls-files -- {spec}/*`.split("\n")

  spec.add_dependency "thor", "~> 1.0"
  spec.add_dependency "parslet", "~> 2.0"
  spec.metadata["rubygems_mfa_required"] = "true"
end
--- END FILE: expressir.gemspec ---
--- START FILE: lib/expressir.rb ---
require "expressir/version"

require "expressir/cli"
require "expressir/config"

# ..........................................................
# https://bugs.ruby-lang.org/issues/19319
# The issue is that this bug is fixed for 3.1 and above,
# but not for 3.0 or 2.7, so we need a "safe" function
# ..........................................................

if RUBY_VERSION < "3.1"
  class String
    def safe_downcase
      each_char.map(&:downcase).join
    end
  end
else
  class String
    def safe_downcase
      downcase
    end
  end
end

module Expressir
  class Error < StandardError; end

  def self.root
    File.dirname(__dir__)
  end

  def self.root_path
    @root_path ||= Pathname.new(Expressir.root)
  end
end

Dir[File.join(__dir__, "expressir", "express", "*.rb")].sort.each do |fea|
  require fea
end
--- END FILE: lib/expressir.rb ---
--- START FILE: lib/expressir/cli.rb ---
require "thor"

module Expressir
  class Cli < Thor
    desc "format PATH", "pretty print EXPRESS schema located at PATH"
    def format(path)
      repository = Expressir::Express::Parser.from_file(path)
      repository.schemas.each do |schema|
        puts "\n(* Expressir formatted schema: #{schema.id} *)\n"
        puts schema.to_s(no_remarks: true)
      end
    end

    no_commands do
      def _validate_schema(path)
        repository = Expressir::Express::Parser.from_file(path)
        repository.schemas.inject([]) do |acc, schema|
          acc << schema.id unless schema.version&.value
          acc
        end
      rescue StandardError
        nil
      end

      def _print_validation_errors(type, array)
        return if array.empty?

        puts "#{'*' * 20} RESULTS: #{type.to_s.upcase.tr('_', ' ')} #{'*' * 20}"
        array.each do |msg|
          puts msg
        end
      end
    end

    desc "validate *PATH", "validate EXPRESS schema located at PATH"
    def validate(*paths) # rubocop:disable Metrics/AbcSize,Metrics/MethodLength
      no_version = []
      no_valid = []

      paths.each do |path|
        x = Pathname.new(path).realpath.relative_path_from(Dir.pwd)
        puts "Validating #{x}"
        ret = _validate_schema(path)

        if ret.nil?
          no_valid << "Failed to parse: #{x}"
          next
        end

        ret.each do |schema_id|
          no_version << "Missing version string: schema `#{schema_id}` | #{x}"
        end
      end

      _print_validation_errors(:failed_to_parse, no_valid)
      _print_validation_errors(:missing_version_string, no_version)

      exit 1 unless [no_valid, no_version].all?(&:empty?)

      puts "Validation passed for all EXPRESS schemas."
    end

    desc "version", "Expressir Version"
    def version
      say(Expressir::VERSION)
    end
  end
end
--- END FILE: lib/expressir/cli.rb ---
--- START FILE: lib/expressir/config.rb ---
module Expressir
  module Config
    def configure
      if block_given?
        yield configuration
      end
    end

    def configuration
      @configuration ||= Configuration.new
    end
  end

  class Configuration
    attr_accessor :logs

    def initialize
      @logs = %i(error)
    end
  end

  extend Config
end
--- END FILE: lib/expressir/config.rb ---
--- START FILE: lib/expressir/express/cache.rb ---
require 'yaml'
require 'zlib'
require 'expressir/model'

module Expressir
  module Express
    class Cache
      # Save Express model into a cache file
      # @param file [String] cache file path
      # @param content [Model::ModelElement] Express model
      # @param root_path [String] Express repository root path, to be stripped from Express file paths to create a portable cache file
      # @param test_overwrite_version [String] don't use, only for tests
      # @return [nil]
      def self.to_file(file, content, root_path: nil, test_overwrite_version: nil)
        version = test_overwrite_version || VERSION

        cache = Model::Cache.new(
          version: version,
          content: content
        )

        hash = cache.to_hash(root_path: root_path)
        yaml = YAML.dump(hash)
        yaml_compressed = Zlib::Deflate.deflate(yaml)

        File.binwrite(file, yaml_compressed)
        nil
      end

      # Load Express model from a cache file
      # @param file [String] cache file path
      # @param root_path [String] Express repository root path, to be prepended to Express file paths if loading a portable cache file
      # @param test_overwrite_version [String] don't use, only for tests
      # @return [Model::ModelElement] Express model
      def self.from_file(file, root_path: nil, test_overwrite_version: nil)
        version = test_overwrite_version || VERSION

        yaml_compressed = File.binread(file)
        yaml = Zlib::Inflate.inflate(yaml_compressed)
        hash = YAML.load(yaml)
        cache = Model::ModelElement.from_hash(hash, root_path: root_path)

        if cache.version != version
          raise Error.new("Cache version mismatch, cache version is #{cache.version}, Expressir version is #{version}")
        end

        cache.content
      end
    end
  end
end
--- END FILE: lib/expressir/express/cache.rb ---
--- START FILE: lib/expressir/express/formatter.rb ---
require 'expressir/model'

module Expressir
  module Express
    class Formatter
      INDENT_CHAR = ' '
      INDENT_WIDTH = 2
      INDENT = INDENT_CHAR * INDENT_WIDTH
      OPERATOR_PRECEDENCE = {
        Model::Expressions::BinaryExpression::EXPONENTIATION => 1,
        Model::Expressions::BinaryExpression::MULTIPLICATION => 2,
        Model::Expressions::BinaryExpression::REAL_DIVISION => 2,
        Model::Expressions::BinaryExpression::INTEGER_DIVISION => 2,
        Model::Expressions::BinaryExpression::MODULO => 2,
        Model::Expressions::BinaryExpression::AND => 2,
        Model::Expressions::BinaryExpression::COMBINE => 2,
        Model::Expressions::BinaryExpression::SUBTRACTION => 3,
        Model::Expressions::BinaryExpression::ADDITION => 3,
        Model::Expressions::BinaryExpression::OR => 3,
        Model::Expressions::BinaryExpression::XOR => 3,
        Model::Expressions::BinaryExpression::EQUAL => 4,
        Model::Expressions::BinaryExpression::NOT_EQUAL => 4,
        Model::Expressions::BinaryExpression::LESS_THAN_OR_EQUAL => 4,
        Model::Expressions::BinaryExpression::GREATER_THAN_OR_EQUAL => 4,
        Model::Expressions::BinaryExpression::LESS_THAN => 4,
        Model::Expressions::BinaryExpression::GREATER_THAN => 4,
        Model::Expressions::BinaryExpression::INSTANCE_EQUAL => 4,
        Model::Expressions::BinaryExpression::INSTANCE_NOT_EQUAL => 4,
        Model::Expressions::BinaryExpression::IN => 4,
        Model::Expressions::BinaryExpression::LIKE => 4,
      }
      SUPERTYPE_OPERATOR_PRECEDENCE = {
        Model::SupertypeExpressions::BinarySupertypeExpression::AND => 1,
        Model::SupertypeExpressions::BinarySupertypeExpression::ANDOR => 2,
      }

      private_constant :INDENT_CHAR
      private_constant :INDENT_WIDTH
      private_constant :INDENT
      private_constant :OPERATOR_PRECEDENCE
      private_constant :SUPERTYPE_OPERATOR_PRECEDENCE

      # Formats Express model into an Express code
      # @param [Model::ModelElement] node
      # @return [String]
      def self.format(node)
        formatter = self.new
        formatter.format(node)
      end

      # Formats Express model into an Express code
      # @param [Model::ModelElement] node
      # @return [String]
      def format(node)
        if node.is_a? Model::Repository
          format_repository(node)
        elsif node.is_a? Model::Declarations::Attribute
          format_declarations_attribute(node)
        elsif node.is_a? Model::Declarations::Constant
          format_declarations_constant(node)
        elsif node.is_a? Model::Declarations::Entity
          format_declarations_entity(node)
        elsif node.is_a? Model::Declarations::Function
          format_declarations_function(node)
        elsif node.is_a? Model::Declarations::Interface
          format_declarations_interface(node)
        elsif node.is_a? Model::Declarations::InterfaceItem
          format_declarations_interface_item(node)
        elsif node.is_a? Model::Declarations::Parameter
          format_declarations_parameter(node)
        elsif node.is_a? Model::Declarations::Procedure
          format_declarations_procedure(node)
        elsif node.is_a? Model::Declarations::Rule
          format_declarations_rule(node)
        elsif node.is_a? Model::Declarations::Schema
          format_declarations_schema(node)
        elsif node.is_a? Model::Declarations::SchemaVersion
          format_declarations_schema_version(node)
        elsif node.is_a? Model::Declarations::SubtypeConstraint
          format_declarations_subtype_constraint(node)
        elsif node.is_a? Model::Declarations::Type
          format_declarations_type(node)
        elsif node.is_a? Model::Declarations::UniqueRule
          format_declarations_unique_rule(node)
        elsif node.is_a? Model::Declarations::Variable
          format_declarations_variable(node)
        elsif node.is_a? Model::Declarations::WhereRule
          format_declarations_where_rule(node)
        elsif node.is_a? Model::DataTypes::Aggregate
          format_data_types_aggregate(node)
        elsif node.is_a? Model::DataTypes::Array
          format_data_types_array(node)
        elsif node.is_a? Model::DataTypes::Bag
          format_data_types_bag(node)
        elsif node.is_a? Model::DataTypes::Binary
          format_data_types_binary(node)
        elsif node.is_a? Model::DataTypes::Boolean
          format_data_types_boolean(node)
        elsif node.is_a? Model::DataTypes::Enumeration
          format_data_types_enumeration(node)
        elsif node.is_a? Model::DataTypes::EnumerationItem
          format_data_types_enumeration_item(node)
        elsif node.is_a? Model::DataTypes::GenericEntity
          format_data_types_generic_entity(node)
        elsif node.is_a? Model::DataTypes::Generic
          format_data_types_generic(node)
        elsif node.is_a? Model::DataTypes::Integer
          format_data_types_integer(node)
        elsif node.is_a? Model::DataTypes::List
          format_data_types_list(node)
        elsif node.is_a? Model::DataTypes::Logical
          format_data_types_logical(node)
        elsif node.is_a? Model::DataTypes::Number
          format_data_types_number(node)
        elsif node.is_a? Model::DataTypes::Real
          format_data_types_real(node)
        elsif node.is_a? Model::DataTypes::Select
          format_data_types_select(node)
        elsif node.is_a? Model::DataTypes::Set
          format_data_types_set(node)
        elsif node.is_a? Model::DataTypes::String
          format_data_types_string(node)
        elsif node.is_a? Model::Expressions::AggregateInitializer
          format_expressions_aggregate_initializer(node)
        elsif node.is_a? Model::Expressions::AggregateInitializerItem
          format_expressions_aggregate_initializer_item(node)
        elsif node.is_a? Model::Expressions::BinaryExpression
          format_expressions_binary_expression(node)
        elsif node.is_a? Model::Expressions::EntityConstructor
          format_expressions_entity_constructor(node)
        elsif node.is_a? Model::Expressions::FunctionCall
          format_expressions_function_call(node)
        elsif node.is_a? Model::Expressions::Interval
          format_expressions_interval(node)
        elsif node.is_a? Model::Expressions::QueryExpression
          format_expressions_query_expression(node)
        elsif node.is_a? Model::Expressions::UnaryExpression
          format_expressions_unary_expression(node)
        elsif node.is_a? Model::Literals::Binary
          format_literals_binary(node)
        elsif node.is_a? Model::Literals::Integer
          format_literals_integer(node)
        elsif node.is_a? Model::Literals::Logical
          format_literals_logical(node)
        elsif node.is_a? Model::Literals::Real
          format_literals_real(node)
        elsif node.is_a? Model::Literals::String
          format_literals_string(node)
        elsif node.is_a? Model::References::AttributeReference
          format_references_attribute_reference(node)
        elsif node.is_a? Model::References::GroupReference
          format_references_group_reference(node)
        elsif node.is_a? Model::References::IndexReference
          format_references_index_reference(node)
        elsif node.is_a? Model::References::SimpleReference
          format_references_simple_reference(node)
        elsif node.is_a? Model::Statements::Alias
          format_statements_alias(node)
        elsif node.is_a? Model::Statements::Assignment
          format_statements_assignment(node)
        elsif node.is_a? Model::Statements::Case
          format_statements_case(node)
        elsif node.is_a? Model::Statements::CaseAction
          format_statements_case_action(node)
        elsif node.is_a? Model::Statements::Compound
          format_statements_compound(node)
        elsif node.is_a? Model::Statements::Escape
          format_statements_escape(node)
        elsif node.is_a? Model::Statements::If
          format_statements_if(node)
        elsif node.is_a? Model::Statements::Null
          format_statements_null(node)
        elsif node.is_a? Model::Statements::ProcedureCall
          format_statements_procedure_call(node)
        elsif node.is_a? Model::Statements::Repeat
          format_statements_repeat(node)
        elsif node.is_a? Model::Statements::Return
          format_statements_return(node)
        elsif node.is_a? Model::Statements::Skip
          format_statements_skip(node)
        elsif node.is_a? Model::SupertypeExpressions::BinarySupertypeExpression
          format_supertype_expressions_binary_supertype_expression(node)
        elsif node.is_a? Model::SupertypeExpressions::OneofSupertypeExpression
          format_supertype_expressions_oneof_supertype_expression(node)
        else
          STDERR.puts "#{node.class.name} format not implemented"
          ''
        end
      end

      private

      def format_repository(node)
        node.schemas.map{|x| format(x)}.join("\n\n")
      end

      def format_declarations_attribute(node)
        [
          *if node.supertype_attribute
            [
              format(node.supertype_attribute),
              ' ',
            ].join('')
          end,
          *if node.supertype_attribute and node.id
            [
              'RENAMED',
              ' '
            ].join('')
          end,
          *if node.id
            [
              node.id,
              ' '
            ].join('')
          end,
          ':',
          *if node.optional
            [
              ' ',
              'OPTIONAL'
            ].join('')
          end,
          ' ',
          format(node.type),
          *if node.kind == Model::Declarations::Attribute::DERIVED
            [
              ' ',
              ':=',
              ' ',
              format(node.expression)
            ].join('')
          elsif node.kind == Model::Declarations::Attribute::INVERSE
            [
              ' ',
              'FOR',
              ' ',
              format(node.expression)
            ].join('')
          end,
          ';',
        ].join('')
      end

      def format_declarations_constant(node)
        [
          node.id,
          ' ',
          ':',
          ' ',
          format(node.type),
          ' ',
          ':=',
          ' ',
          format(node.expression),
          ';'
        ].join('')
      end

      def format_declarations_entity(node)
        explicit_attributes = node.attributes.select{|x| x.kind == Model::Declarations::Attribute::EXPLICIT}
        derived_attributes = node.attributes.select{|x| x.kind == Model::Declarations::Attribute::DERIVED}
        inverse_attributes = node.attributes.select{|x| x.kind == Model::Declarations::Attribute::INVERSE}

        [
          [
            'ENTITY',
            ' ',
            node.id,
            *if node.abstract and !node.supertype_expression
              [
                "\n",
                indent([
                  'ABSTRACT',
                  ' ',
                  'SUPERTYPE'
                ].join(''))
              ].join('')
            end,
            *if node.abstract and node.supertype_expression
              [
                "\n",
                indent([
                  'ABSTRACT',
                  ' ',
                  'SUPERTYPE',
                  ' ',
                  'OF',
                  ' ',
                  '(',
                  format(node.supertype_expression),
                  ')'
                ].join(''))
              ].join('')
            end,
            *if !node.abstract and node.supertype_expression
              [
                "\n",
                indent([
                  'SUPERTYPE',
                  ' ',
                  'OF',
                  ' ',
                  '(',
                  format(node.supertype_expression),
                  ')'
                ].join(''))
              ].join('')
            end,
            *if node.subtype_of.length > 0
              [
                "\n",
                indent([
                  'SUBTYPE',
                  ' ',
                  'OF',
                  ' ',
                  '(',
                  node.subtype_of.map{|x| format(x)}.join(', '),
                  ')'
                ].join(''))
              ].join('')
            end,
            ';'
          ].join(''),
          *if explicit_attributes and explicit_attributes.length > 0
            indent(explicit_attributes.map{|x| format(x)}.join("\n"))
          end,
          *if derived_attributes and derived_attributes.length > 0
            [
              'DERIVE',
              indent(derived_attributes.map{|x| format(x)}.join("\n")),
            ]
          end,
          *if inverse_attributes and inverse_attributes.length > 0
            [
              'INVERSE',
              indent(inverse_attributes.map{|x| format(x)}.join("\n")),
            ]
          end,
          *if node.unique_rules.length > 0
            [
              'UNIQUE',
              indent(node.unique_rules.map{|x| format(x)}.join("\n"))
            ]
          end,
          *if node.where_rules.length > 0
            [
              'WHERE',
              indent(node.where_rules.map{|x| format(x)}.join("\n")),
            ]
          end,
          [
            'END_ENTITY',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_declarations_function(node)
        [
          [
            'FUNCTION',
            ' ',
            node.id,
            *if node.parameters.length > 0
              parameter_indent = INDENT_CHAR * "FUNCTION #{node.id}(".length
              [
                '(',
                node.parameters.map{|x| format(x)}.join(";\n#{parameter_indent}"),
                ')'
              ].join('')
            end,
            ' ',
            ':',
            ' ',
            format(node.return_type),
            ';'
          ].join(''),
          *if node.types.length > 0
            indent(node.types.map{|x| format(x)}.join("\n"))
          end,
          *if node.entities.length > 0
            indent(node.entities.map{|x| format(x)}.join("\n"))
          end,
          *if node.subtype_constraints.length > 0
            indent(node.subtype_constraints.map{|x| format(x)}.join("\n"))
          end,
          *if node.functions.length > 0
            indent(node.functions.map{|x| format(x)}.join("\n"))
          end,
          *if node.procedures.length > 0
            indent(node.procedures.map{|x| format(x)}.join("\n"))
          end,
          *if node.constants.length > 0
            indent([
              'CONSTANT',
              indent(node.constants.map{|x| format(x)}.join("\n")),
              [
                'END_CONSTANT',
                ';'
              ].join('')
            ].join("\n"))
          end,
          *if node.variables.length > 0
            indent([
              'LOCAL',
              indent(node.variables.map{|x| format(x)}.join("\n")),
              [
                'END_LOCAL',
                ';'
              ].join('')
            ].join("\n"))
          end,
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          [
            'END_FUNCTION',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_declarations_interface(node)
        [
          case node.kind
            when Model::Declarations::Interface::USE then 'USE'
            when Model::Declarations::Interface::REFERENCE then 'REFERENCE'
          end,
          ' ',
          'FROM',
          ' ',
          format(node.schema),
          *if node.items.length > 0
            item_indent = INDENT_CHAR * '('.length
            [
              "\n",
              indent([
                '(',
                node.items.map{|x| format(x)}.join(",\n#{item_indent}"),
                ')'
              ].join(''))
            ].join('')
          end,
          ';',
        ].join('')
      end

      def format_declarations_interface_item(node)
        [
          format(node.ref),
          *if node.id
            [
              ' ',
              'AS',
              ' ',
              node.id
            ]
          end
        ].join('')
      end

      def format_declarations_parameter(node)
        [
          *if node.var
            [
              'VAR',
              ' '
            ].join('')
          end,
          node.id,
          ' ',
          ':',
          ' ',
          format(node.type)
        ].join('')
      end

      def format_declarations_procedure(node)
        [
          [
            'PROCEDURE',
            ' ',
            node.id,
            *if node.parameters.length > 0
              parameter_indent = INDENT_CHAR * "PROCEDURE #{node.id}(".length
              [
                '(',
                node.parameters.map{|x| format(x)}.join(";\n#{parameter_indent}"),
                ')'
              ].join('')
            end,
            ';'
          ].join(''),
          *if node.types.length > 0
            indent(node.types.map{|x| format(x)}.join("\n"))
          end,
          *if node.entities.length > 0
            indent(node.entities.map{|x| format(x)}.join("\n"))
          end,
          *if node.subtype_constraints.length > 0
            indent(node.subtype_constraints.map{|x| format(x)}.join("\n"))
          end,
          *if node.functions.length > 0
            indent(node.functions.map{|x| format(x)}.join("\n"))
          end,
          *if node.procedures.length > 0
            indent(node.procedures.map{|x| format(x)}.join("\n"))
          end,
          *if node.constants.length > 0
            indent([
              'CONSTANT',
              indent(node.constants.map{|x| format(x)}.join("\n")),
              [
                'END_CONSTANT',
                ';'
              ].join('')
            ].join("\n"))
          end,
          *if node.variables.length > 0
            indent([
              'LOCAL',
              indent(node.variables.map{|x| format(x)}.join("\n")),
              [
                'END_LOCAL',
                ';'
              ].join('')
            ].join("\n"))
          end,
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          [
            'END_PROCEDURE',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_declarations_rule(node)
        [
          [
            'RULE',
            ' ',
            node.id,
            ' ',
            'FOR',
            ' ',
            '(',
            node.applies_to.map{|x| format(x)}.join(', '),
            ')',
            ';'
          ].join(''),
          *if node.types.length > 0
            indent(node.types.map{|x| format(x)}.join("\n"))
          end,
          *if node.entities.length > 0
            indent(node.entities.map{|x| format(x)}.join("\n"))
          end,
          *if node.subtype_constraints.length > 0
            indent(node.subtype_constraints.map{|x| format(x)}.join("\n"))
          end,
          *if node.functions.length > 0
            indent(node.functions.map{|x| format(x)}.join("\n"))
          end,
          *if node.procedures.length > 0
            indent(node.procedures.map{|x| format(x)}.join("\n"))
          end,
          *if node.constants.length > 0
            indent([
              'CONSTANT',
              indent(node.constants.map{|x| format(x)}.join("\n")),
              [
                'END_CONSTANT',
                ';'
              ].join('')
            ].join("\n"))
          end,
          *if node.variables.length > 0
            indent([
              'LOCAL',
              indent(node.variables.map{|x| format(x)}.join("\n")),
              [
                'END_LOCAL',
                ';'
              ].join('')
            ].join("\n"))
          end,
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          *if node.where_rules.length > 0
            [
              'WHERE',
              indent(node.where_rules.map{|x| format(x)}.join("\n"))
            ]
          end,
          [
            'END_RULE',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_declarations_schema_head(node)
        [
          [
            'SCHEMA',
            ' ',
            node.id,
            *if node.version
              [
                ' ',
                format(node.version),
              ].join('')
            end,
            ';'
          ].join(''),
          *if node.interfaces.length > 0
            [
              '',
              node.interfaces.map{|x| format(x)}.join("\n")
            ]
          end
        ].join("\n")
      end

      def format_declarations_schema(node)
        schema_declarations = [
          *if node.constants.length > 0
            [
              'CONSTANT',
              indent(node.constants.map{|x| format(x)}.join("\n")),
              [
                'END_CONSTANT',
                ';'
              ].join('')
            ].join("\n")
          end,
          *if node.types.length > 0
            node.types.map{|x| format(x)}
          end,
          *if node.entities.length > 0
            node.entities.map{|x| format(x)}
          end,
          *if node.subtype_constraints.length > 0
            node.subtype_constraints.map{|x| format(x)}
          end,
          *if node.functions.length > 0
            node.functions.map{|x| format(x)}
          end,
          *if node.rules.length > 0
            node.rules.map{|x| format(x)}
          end,
          *if node.procedures and node.procedures.length > 0
            node.procedures.map{|x| format(x)}
          end
        ]

        [
          format_declarations_schema_head(node),
          *if schema_declarations.length > 0
            [
              '',
              schema_declarations.join("\n\n"),
              ''
            ]
          end,
          [
            'END_SCHEMA',
            ';'
          ].join(''),
          *format_scope_remarks(node)
        ].join("\n")
      end

      def format_declarations_schema_version(node)
        [
          "'",
          node.value,
          "'"
        ].join('')
      end

      def format_declarations_subtype_constraint(node)
        [
          [
            'SUBTYPE_CONSTRAINT',
            ' ',
            node.id,
            ' ',
            'FOR',
            ' ',
            format(node.applies_to),
            ';'
          ].join(''),
          *if node.abstract
            indent([
              'ABSTRACT',
              ' ',
              'SUPERTYPE',
              ';'
            ].join(''))
          end,
          *if node.total_over.length > 0
            indent([
              'TOTAL_OVER',
              '(',
              node.total_over.map{|x| format(x)}.join(', '),
              ')',
              ';'
            ].join(''))
          end,
          *if node.supertype_expression
            indent([
              format(node.supertype_expression),
              ';'
            ].join(''))
          end,
          [
            'END_SUBTYPE_CONSTRAINT',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_declarations_type(node)
        [
          [
            'TYPE',
            ' ',
            node.id,
            ' ',
            '=',
            ' ',
            format(node.underlying_type),
            ';',
          ].join(''),
          *if node.where_rules.length > 0
            [
              'WHERE',
              indent(node.where_rules.map{|x| format(x)}.join("\n"))
            ]
          end,
          [
            'END_TYPE',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_declarations_unique_rule(node)
        [
          *if node.id
            [
              node.id,
              ':',
              ' '
            ].join('')
          end,
          node.attributes.map{|x| format(x)}.join(', '),
          ';'
        ].join('')
      end

      def format_declarations_variable(node)
        [
          node.id,
          ' ',
          ':',
          ' ',
          format(node.type),
          *if node.expression
            [
              ' ',
              ':=',
              ' ',
              format(node.expression),
            ].join('')
          end,
          ';'
        ].join('')
      end

      def format_declarations_where_rule(node)
        [
          *if node.id
            [
              node.id,
              ':',
              ' '
            ].join('')
          end,
          format(node.expression),
          ';'
        ].join('')
      end

      def format_expressions_aggregate_initializer(node)
        [
          '[',
          node.items.map{|x| format(x)}.join(', '),
          ']'
        ].join('')
      end

      def format_expressions_aggregate_initializer_item(node)
        [
          format(node.expression),
          ':',
          format(node.repetition)
        ].join('')
      end

      def format_expressions_binary_expression(node)
        [
          *if node.operand1.is_a? Model::Expressions::BinaryExpression and OPERATOR_PRECEDENCE[node.operand1.operator] > OPERATOR_PRECEDENCE[node.operator]
            '('
          end,
          format(node.operand1),
          *if node.operand1.is_a? Model::Expressions::BinaryExpression and OPERATOR_PRECEDENCE[node.operand1.operator] > OPERATOR_PRECEDENCE[node.operator]
            ')'
          end,
          ' ',
          case node.operator
            when Model::Expressions::BinaryExpression::ADDITION then '+'
            when Model::Expressions::BinaryExpression::AND then 'AND'
            when Model::Expressions::BinaryExpression::COMBINE then '||'
            when Model::Expressions::BinaryExpression::EQUAL then '='
            when Model::Expressions::BinaryExpression::EXPONENTIATION then '**'
            when Model::Expressions::BinaryExpression::GREATER_THAN then '>'
            when Model::Expressions::BinaryExpression::GREATER_THAN_OR_EQUAL then '>='
            when Model::Expressions::BinaryExpression::IN then 'IN'
            when Model::Expressions::BinaryExpression::INSTANCE_EQUAL then ':=:'
            when Model::Expressions::BinaryExpression::INSTANCE_NOT_EQUAL then ':<>:'
            when Model::Expressions::BinaryExpression::INTEGER_DIVISION then 'DIV'
            when Model::Expressions::BinaryExpression::LESS_THAN then '<'
            when Model::Expressions::BinaryExpression::LESS_THAN_OR_EQUAL then '<='
            when Model::Expressions::BinaryExpression::LIKE then 'LIKE'
            when Model::Expressions::BinaryExpression::MODULO then 'MOD'
            when Model::Expressions::BinaryExpression::MULTIPLICATION then '*'
            when Model::Expressions::BinaryExpression::NOT_EQUAL then '<>'
            when Model::Expressions::BinaryExpression::OR then 'OR'
            when Model::Expressions::BinaryExpression::REAL_DIVISION then '/'
            when Model::Expressions::BinaryExpression::SUBTRACTION then '-'
            when Model::Expressions::BinaryExpression::XOR then 'XOR'
          end,
          ' ',
          *if node.operand2.is_a? Model::Expressions::BinaryExpression and OPERATOR_PRECEDENCE[node.operand2.operator] > OPERATOR_PRECEDENCE[node.operator]
            '('
          end,
          format(node.operand2),
          *if node.operand2.is_a? Model::Expressions::BinaryExpression and OPERATOR_PRECEDENCE[node.operand2.operator] > OPERATOR_PRECEDENCE[node.operator]
            ')'
          end,
        ].join('')
      end

      def format_expressions_entity_constructor(node)
        [
          format(node.entity),
          '(',
          node.parameters.map{|x| format(x)}.join(', '),
          ')'
        ].join('')
      end

      def format_expressions_function_call(node)
        [
          format(node.function),
          '(',
          node.parameters.map{|x| format(x)}.join(', '),
          ')'
        ].join('')
      end

      def format_expressions_interval(node)
        [
          '{',
          format(node.low),
          ' ',
          case node.operator1
            when Model::Expressions::Interval::LESS_THAN then '<'
            when Model::Expressions::Interval::LESS_THAN_OR_EQUAL then '<='
          end,
          ' ',
          format(node.item),
          ' ',
          case node.operator2
            when Model::Expressions::Interval::LESS_THAN then '<'
            when Model::Expressions::Interval::LESS_THAN_OR_EQUAL then '<='
          end,
          ' ',
          format(node.high),
          '}'
        ].join('')
      end

      def format_expressions_query_expression(node)
        [
          'QUERY',
          '(',
          node.id,
          ' ',
          '<*',
          ' ',
          format(node.aggregate_source),
          ' ',
          '|',
          ' ',
          format(node.expression),
          *format_remarks(node).instance_eval{|x| x.length > 0 ? ["\n", *x, "\n"] : x},
          ')'
        ].join('')
      end

      def format_expressions_unary_expression(node)
        [
          case node.operator
            when Model::Expressions::UnaryExpression::MINUS then '-'
            when Model::Expressions::UnaryExpression::NOT then 'NOT'
            when Model::Expressions::UnaryExpression::PLUS then '+'
          end,
          if node.operator == Model::Expressions::UnaryExpression::NOT
            ' '
          end,
          *if node.operand.is_a? Model::Expressions::BinaryExpression
            '('
          end,
          format(node.operand),
          *if node.operand.is_a? Model::Expressions::BinaryExpression
            ')'
          end
        ].join('')
      end

      def format_literals_binary(node)
        [
          '%',
          node.value
        ].join('')
      end

      def format_literals_integer(node)
        node.value
      end

      def format_literals_logical(node)
        case node.value
          when Model::Literals::Logical::TRUE then 'TRUE'
          when Model::Literals::Logical::FALSE then 'FALSE'
          when Model::Literals::Logical::UNKNOWN then 'UNKNOWN'
        end
      end

      def format_literals_real(node)
        node.value
      end

      def format_literals_string(node)
        if node.encoded
          [
            "\"",
            node.value,
            "\""
          ].join('')
        else
          [
            "'",
            node.value,
            "'"
          ].join('')
        end
      end

      def format_references_attribute_reference(node)
        [
          format(node.ref),
          '.',
          format(node.attribute)
        ].join('')
      end

      def format_references_group_reference(node)
        [
          format(node.ref),
          '\\',
          format(node.entity)
        ].join('')
      end

      def format_references_index_reference(node)
        [
          format(node.ref),
          '[',
          format(node.index1),
          *if node.index2
            [
              ':',
              format(node.index2)
            ].join('')
          end,
          ']'
        ].join('')
      end

      def format_references_simple_reference(node)
        node.id
      end

      def format_statements_alias(node)
        [
          [
            'ALIAS',
            ' ',
            node.id,
            ' ',
            'FOR',
            ' ',
            format(node.expression),
            ';'
          ].join(''),
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          *format_remarks(node),
          [
            'END_ALIAS',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_statements_assignment(node)
        [
          format(node.ref),
          ' ',
          ':=',
          ' ',
          format(node.expression),
          ';'
        ].join('')
      end

      def format_statements_procedure_call(node)
        [
          format(node.procedure),
          *if node.parameters.length > 0
            [
              '(',
              node.parameters.map{|x| format(x)}.join(', '),
              ')'
            ].join('')
          end,
          ';'
        ].join('')
      end

      def format_statements_case(node)
        [
          [
            'CASE',
            ' ',
            format(node.expression),
            ' ',
            'OF'
          ].join(''),
          *if node.actions.length > 0
            node.actions.map{|x| format(x)}
          end,
          *if node.otherwise_statement
            [
              [
                'OTHERWISE',
                ' ',
                ':'
              ].join(''),
              indent(format(node.otherwise_statement))
            ]
          end,
          [
            'END_CASE',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_statements_case_action(node)
        [
          [
            node.labels.map{|x| format(x)}.join(', '),
            ' ',
            ':'
          ].join(''),
          indent(format(node.statement))
        ].join("\n")
      end

      def format_statements_compound(node)
        [
          'BEGIN',
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          [
            'END',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_statements_escape(node)
        [
          'ESCAPE',
          ';'
        ].join('')
      end

      def format_statements_if(node)
        [
          [
            'IF',
            ' ',
            format(node.expression),
            ' ',
            'THEN'
          ].join(''),
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          *if node.else_statements.length > 0
            [
              'ELSE',
              indent(node.else_statements.map{|x| format(x)}.join("\n")),
            ].join("\n")
          end,
          [
            'END_IF',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_statements_null(node)
        ';'
      end

      def format_statements_repeat(node)
        [
          [
            'REPEAT',
            *if node.id
              [
                ' ',
                node.id,
                ' ',
                ':=',
                ' ',
                format(node.bound1),
                ' ',
                'TO',
                ' ',
                format(node.bound2),
                *if node.increment
                  [
                    ' ',
                    'BY',
                    ' ',
                    format(node.increment)
                  ].join('')
                end
              ].join('')
            end,
            *if node.while_expression
              [
                ' ',
                'WHILE',
                ' ',
                format(node.while_expression)
              ].join('')
            end,
            *if node.until_expression
              [
                ' ',
                'UNTIL',
                ' ',
                format(node.until_expression)
              ].join('')
            end,
            ';'
          ].join(''),
          *if node.statements.length > 0
            indent(node.statements.map{|x| format(x)}.join("\n"))
          end,
          *format_remarks(node),
          [
            'END_REPEAT',
            ';'
          ].join('')
        ].join("\n")
      end

      def format_statements_return(node)
        [
          'RETURN',
          *if node.expression
            [
              ' ',
              '(',
              format(node.expression),
              ')'
            ].join('')
          end,
          ';'
        ].join('')
      end

      def format_statements_skip(node)
        [
          'SKIP',
          ';'
        ].join('')
      end

      def format_supertype_expressions_binary_supertype_expression(node)
        [
          *if node.operand1.is_a? Model::SupertypeExpressions::BinarySupertypeExpression and SUPERTYPE_OPERATOR_PRECEDENCE[node.operand1.operator] > SUPERTYPE_OPERATOR_PRECEDENCE[node.operator]
            '('
          end,
          format(node.operand1),
          *if node.operand1.is_a? Model::SupertypeExpressions::BinarySupertypeExpression and SUPERTYPE_OPERATOR_PRECEDENCE[node.operand1.operator] > SUPERTYPE_OPERATOR_PRECEDENCE[node.operator]
            ')'
          end,
          ' ',
          case node.operator
            when Model::SupertypeExpressions::BinarySupertypeExpression::AND then 'AND'
            when Model::SupertypeExpressions::BinarySupertypeExpression::ANDOR then 'ANDOR'
          end,
          ' ',
          *if node.operand2.is_a? Model::SupertypeExpressions::BinarySupertypeExpression and SUPERTYPE_OPERATOR_PRECEDENCE[node.operand2.operator] > SUPERTYPE_OPERATOR_PRECEDENCE[node.operator]
            '('
          end,
          format(node.operand2),
          *if node.operand2.is_a? Model::SupertypeExpressions::BinarySupertypeExpression and SUPERTYPE_OPERATOR_PRECEDENCE[node.operand2.operator] > SUPERTYPE_OPERATOR_PRECEDENCE[node.operator]
            ')'
          end,
        ].join('')
      end

      def format_supertype_expressions_oneof_supertype_expression(node)
        [
          'ONEOF',
          '(',
          node.operands.map{|x| format(x)}.join(', '),
          ')'
        ].join('')
      end

      def format_data_types_aggregate(node)
        'AGGREGATE'
      end

      def format_data_types_array(node)
        [
          'ARRAY',
          *if node.bound1 and node.bound2
            [
              ' ',
              '[',
              format(node.bound1),
              ':',
              format(node.bound2),
              ']',
            ].join('')
          end,
          ' ',
          'OF',
          *if node.optional
            [
              ' ',
              'OPTIONAL'
            ].join('')
          end,
          *if node.unique
            [
              ' ',
              'UNIQUE'
            ].join('')
          end,
          ' ',
          format(node.base_type)
        ].join('')
      end

      def format_data_types_bag(node)
        [
          'BAG',
          *if node.bound1 and node.bound2
            [
              ' ',
              '[',
              format(node.bound1),
              ':',
              format(node.bound2),
              ']',
            ].join('')
          end,
          ' ',
          'OF',
          ' ',
          format(node.base_type)
        ].join('')
      end

      def format_data_types_binary(node)
        [
          'BINARY',
          *if node.width
            [
              ' ',
              '(',
              format(node.width),
              ')'
            ].join('')
          end,
          *if node.fixed
            [
              ' ',
              'FIXED'
            ].join('')
          end
        ].join('')
      end

      def format_data_types_boolean(node)
        'BOOLEAN'
      end

      def format_data_types_enumeration(node)
        [
          *if node.extensible
            [
              'EXTENSIBLE',
              ' '
            ].join('')
          end,
          'ENUMERATION',
          *if node.based_on
            [
              ' ',
              'BASED_ON',
              ' ',
              format(node.based_on),
              *if node.items.length > 0
                item_indent = INDENT_CHAR * '('.length
                [
                  ' ',
                  'WITH',
                  "\n",
                  indent([
                    '(',
                    node.items.map{|x| format(x)}.join(",\n#{item_indent}"),
                    ')'
                  ].join(''))
                ].join('')
              end
            ].join('')
          else
            [
              *if node.items.length > 0
                item_indent = INDENT_CHAR * '('.length
                [
                  ' ',
                  'OF',
                  "\n",
                  indent([
                    '(',
                    node.items.map{|x| format(x)}.join(",\n#{item_indent}"),
                    ')'
                  ].join(''))
                ].join('')
              end
            ].join('')
          end
        ].join('')
      end

      def format_data_types_enumeration_item(node)
        node.id
      end

      def format_data_types_generic_entity(node)
        [
          'GENERIC_ENTITY',
          *if node.id
            [
              ':',
              node.id
            ]
          end
        ].join('')
      end

      def format_data_types_generic(node)
        [
          'GENERIC',
          *if node.id
            [
              ':',
              node.id
            ]
          end
        ].join('')
      end

      def format_data_types_integer(node)
        'INTEGER'
      end

      def format_data_types_list(node)
        [
          'LIST',
          *if node.bound1 and node.bound2
            [
              ' ',
              '[',
              format(node.bound1),
              ':',
              format(node.bound2),
              ']',
            ].join('')
          end,
          ' ',
          'OF',
          *if node.unique
            [
              ' ',
              'UNIQUE'
            ].join('')
          end,
          ' ',
          format(node.base_type)
        ].join('')
      end

      def format_data_types_logical(node)
        'LOGICAL'
      end

      def format_data_types_number(node)
        'NUMBER'
      end

      def format_data_types_real(node)
        [
          'REAL',
          *if node.precision
            [
              ' ',
              '(',
              format(node.precision),
              ')'
            ].join('')
          end
        ].join('')
      end

      def format_data_types_select(node)
        [
          *if node.extensible
            [
              'EXTENSIBLE',
              ' '
            ].join('')
          end,
          *if node.generic_entity
            [
              'GENERIC_ENTITY',
              ' '
            ].join('')
          end,
          'SELECT',
          *if node.based_on
            [
              ' ',
              'BASED_ON',
              ' ',
              format(node.based_on),
              *if node.items.length > 0
                item_indent = INDENT_CHAR * '('.length
                [
                  ' ',
                  'WITH',
                  "\n",
                  indent([
                    '(',
                    node.items.map{|x| format(x)}.join(",\n#{item_indent}"),
                    ')'
                  ].join(''))
                ].join('')
              end
            ].join('')
          else
            [
              *if node.items.length > 0
                item_indent = INDENT_CHAR * '('.length
                [
                  "\n",
                  indent([
                    '(',
                    node.items.map{|x| format(x)}.join(",\n#{item_indent}"),
                    ')'
                  ].join(''))
                ].join('')
              end
            ].join('')
          end
        ].join('')
      end

      def format_data_types_set(node)
        [
          'SET',
          *if node.bound1 and node.bound2
            [
              ' ',
              '[',
              format(node.bound1),
              ':',
              format(node.bound2),
              ']',
            ].join('')
          end,
          ' ',
          'OF',
          ' ',
          format(node.base_type)
        ].join('')
      end

      def format_data_types_string(node)
        [
          'STRING',
          *if node.width
            [
              ' ',
              '(',
              format(node.width),
              ')'
            ].join('')
          end,
          *if node.fixed
            [
              ' ',
              'FIXED'
            ].join('')
          end
        ].join('')
      end

      def indent(str)
        str.split("\n").map{|x| "#{INDENT}#{x}"}.join("\n")
      end

      def format_remark(node, remark)
        if remark.include?("\n")
          [
            [
              '(*',
              '"',
              node.path || node.id,
              '"',
            ].join(''),
            remark,
            '*)'
          ].join("\n")
        else
          [
            '--',
            '"',
            node.path || node.id,
            '"',
            ' ',
            remark
          ].join('')
        end
      end

      def format_remarks(node)
        if node.class.method_defined? :remarks
          node.remarks.map do |remark|
            format_remark(node, remark)
          end
        else
          []
        end
      end

      def format_scope_remarks(node)
        [
          *format_remarks(node),
          *node.children.select{|x| !x.is_a? Model::DataTypes::EnumerationItem or node.is_a? Model::Declarations::Type}.flat_map{|x| format_scope_remarks(x)}
        ]
      end
    end
  end
end
--- END FILE: lib/expressir/express/formatter.rb ---
--- START FILE: lib/expressir/express/hyperlink_formatter.rb ---
module Expressir
  module Express
    # Formatter module - format references as hyperlinks
    # @example Include into Formatter subclass
    #   formatter = Class.new(Expressir::Express::Formatter) do
    #     include Expressir::Express::HyperlinkFormatter
    #   end
    module HyperlinkFormatter
      # @!visibility private
      def self.included(mod)
        if !mod.superclass.private_method_defined? :format_references_simple_reference
          raise 'Missing method'
        end
      end

      private

      def format_references_simple_reference(node)
        return node.id unless node.base_path

        # find closest node with path
        current_node = node
        while !current_node.path
          current_node = current_node.parent
        end

        # skip if this reference and target node are in the same node with path
        node_base_path_parts = node.base_path.split(".")
        current_node_path_parts = current_node.path.split(".")
        return node.id if node_base_path_parts[0..1] == current_node_path_parts[0..1]

        "{{{<<express:#{node.base_path},#{node.id}>>}}}"
      end
    end
  end
end
--- END FILE: lib/expressir/express/hyperlink_formatter.rb ---
--- START FILE: lib/expressir/express/model_visitor.rb ---
require "expressir/model"

module Expressir
  module Express
    # @abstract
    class ModelVisitor
      def visit(node)
        node.class.model_attrs.each do |variable|
          value = node.send(variable)

          if value.is_a? Array
            value.each do |value|
              if value.is_a? Model::ModelElement
                visit(value)
              end
            end
          elsif value.is_a? Model::ModelElement
            visit(value)
          end
        end
      end
    end
  end
end
--- END FILE: lib/expressir/express/model_visitor.rb ---
--- START FILE: lib/expressir/express/parser.rb ---
require 'expressir/express/resolve_references_model_visitor'
require 'parslet'
require "expressir/model"

module Expressir
  module Express
    class Parser
      class Parser < Parslet::Parser
        root(:syntax)

        def cts(atom)
          spaces >> atom
        end

        def cstr(atom)
          cts(str(atom).as(:str))
        end

        KEYWORDS = %i[
          ABS ABSTRACT ACOS AGGREGATE ALIAS AND ANDOR ARRAY AS ASIN ATAN BAG BASED_ON
          BEGIN BINARY BLENGTH BOOLEAN BY CASE CONSTANT CONST_E COS DERIVE DIV ELSE
          END END_ALIAS END_CASE END_CONSTANT END_ENTITY END_FUNCTION END_IF
          END_LOCAL END_PROCEDURE END_REPEAT END_RULE END_SCHEMA
          END_SUBTYPE_CONSTRAINT END_TYPE ENTITY ENUMERATION ESCAPE EXISTS EXP
          EXTENSIBLE FALSE FIXED FOR FORMAT FROM FUNCTION GENERIC GENERIC_ENTITY
          HIBOUND HIINDEX IF IN INSERT INTEGER INVERSE LENGTH LIKE LIST LOBOUND LOCAL
          LOG LOG10 LOG2 LOGICAL LOINDEX MOD NOT NUMBER NVL ODD OF ONEOF OPTIONAL OR
          OTHERWISE PI PROCEDURE QUERY REAL REFERENCE REMOVE RENAMED REPEAT RETURN
          ROLESOF RULE SCHEMA SELECT SELF SET SIN SIZEOF SKIP SQRT STRING SUBTYPE
          SUBTYPE_CONSTRAINT SUPERTYPE TAN THEN TO TRUE TYPE TYPEOF TOTAL_OVER UNIQUE
          UNKNOWN UNTIL USE USEDIN VALUE VALUE_IN VALUE_UNIQUE VAR WITH WHERE WHILE
          XOR
        ]
        
        def keyword_rule(str)
          key_chars = str.to_s.split(//)
          key_chars.
            collect! { |char| match("[#{char}#{char.downcase}]") }.
            reduce(:>>) >> match['a-zA-Z0-9_'].absent?
        end        

        KEYWORDS.each do |keyword|
          sym = "t#{keyword}".to_sym
          rule(sym) { cts(keyword_rule(keyword).as(:str)).as(sym) }
        end

        rule(:abstractEntityDeclaration) { (tABSTRACT).as(:abstractEntityDeclaration) }
        rule(:abstractSupertypeDeclaration) { (tABSTRACT >> tSUPERTYPE >> subtypeConstraint.maybe).as(:abstractSupertypeDeclaration) }
        rule(:abstractSupertype) { (tABSTRACT >> tSUPERTYPE >> op_delim).as(:abstractSupertype) }
        rule(:actualParameterList) { (op_leftparen >> (parameter >> (op_comma >> parameter).repeat).as(:listOf_parameter) >> op_rightparen).as(:actualParameterList) }
        rule(:addLikeOp) { (op_plus | op_minus | tOR | tXOR).as(:addLikeOp) }
        rule(:aggregateInitializer) { (op_leftbracket >> ((element >> (op_comma >> element).repeat).as(:listOf_element)).maybe >> op_rightbracket).as(:aggregateInitializer) }
        rule(:aggregateSource) { (simpleExpression).as(:aggregateSource) }
        rule(:aggregateType) { (tAGGREGATE >> (op_colon >> typeLabel).maybe >> tOF >> parameterType).as(:aggregateType) }
        rule(:aggregationTypes) { (arrayType | bagType | listType | setType).as(:aggregationTypes) }
        rule(:algorithmHead) { (declaration.repeat.as(:declaration) >> constantDecl.maybe >> localDecl.maybe).as(:algorithmHead) }
        rule(:aliasStmt) { (tALIAS >> variableId >> tFOR >> generalRef >> qualifier.repeat.as(:qualifier) >> op_delim >> stmt.repeat(1).as(:stmt) >> tEND_ALIAS >> (op_delim.as(:op_delim2))).as(:aliasStmt) }
        rule(:anyKeyword) { KEYWORDS.map { |kw| send("t#{kw}") }.inject(:|) }
        rule(:arrayType) { (tARRAY >> boundSpec >> tOF >> tOPTIONAL.maybe >> tUNIQUE.maybe >> instantiableType).as(:arrayType) }
        rule(:assignmentStmt) { (generalRef >> qualifier.repeat.as(:qualifier) >> op_decl >> expression >> op_delim).as(:assignmentStmt) }
        rule(:attributeDecl) { (attributeId | redeclaredAttribute).as(:attributeDecl) }
        rule(:attributeId) { (simpleId).as(:attributeId) }
        rule(:attributeQualifier) { (op_period >> attributeRef).as(:attributeQualifier) }
        rule(:attributeRef) { (attributeId).as(:attributeRef) }
        rule(:bagType) { (tBAG >> boundSpec.maybe >> tOF >> instantiableType).as(:bagType) }
        rule(:binaryLiteral) { cts((str('%') >> bit.repeat(1)).as(:str)).as(:binaryLiteral) }
        rule(:binaryType) { (tBINARY >> widthSpec.maybe).as(:binaryType) }
        rule(:bit) { (match['0-1']) }
        rule(:booleanType) { (tBOOLEAN).as(:booleanType) }
        rule(:bound1) { (numericExpression).as(:bound1) }
        rule(:bound2) { (numericExpression).as(:bound2) }
        rule(:boundSpec) { (op_leftbracket >> bound1 >> op_colon >> bound2 >> op_rightbracket).as(:boundSpec) }
        rule(:builtInConstant) { (tCONST_E | tPI | tSELF | op_question_mark).as(:builtInConstant) }
        rule(:builtInFunction) { (tABS | tACOS | tASIN | tATAN | tBLENGTH | tCOS | tEXISTS | tEXP | tFORMAT | tHIBOUND | tHIINDEX | tLENGTH | tLOBOUND | tLOINDEX | tLOG2 | tLOG10 | tLOG | tNVL | tODD | tROLESOF | tSIN | tSIZEOF | tSQRT | tTAN | tTYPEOF | tUSEDIN | tVALUE_IN | tVALUE_UNIQUE | tVALUE).as(:builtInFunction) }
        rule(:builtInProcedure) { (tINSERT | tREMOVE).as(:builtInProcedure) }
        rule(:caseAction) { ((caseLabel >> (op_comma >> caseLabel).repeat).as(:listOf_caseLabel) >> op_colon >> stmt).as(:caseAction) }
        rule(:caseLabel) { (expression).as(:caseLabel) }
        rule(:caseStmt) { (tCASE >> selector >> tOF >> caseAction.repeat.as(:caseAction) >> (tOTHERWISE >> op_colon >> stmt).maybe >> tEND_CASE >> op_delim).as(:caseStmt) }
        rule(:compoundStmt) { (tBEGIN >> stmt.repeat(1).as(:stmt) >> tEND >> op_delim).as(:compoundStmt) }
        rule(:concreteTypes) { (aggregationTypes | simpleTypes | typeRef).as(:concreteTypes) }
        rule(:constantBody) { (constantId >> op_colon >> instantiableType >> op_decl >> expression >> op_delim).as(:constantBody) }
        rule(:constantDecl) { (tCONSTANT >> constantBody.repeat(1).as(:constantBody) >> tEND_CONSTANT >> op_delim).as(:constantDecl) }
        rule(:constantFactor) { (builtInConstant | constantRef).as(:constantFactor) }
        rule(:constantId) { (simpleId).as(:constantId) }
        rule(:constantRef) { (constantId).as(:constantRef) }
        rule(:constructedTypes) { (enumerationType | selectType).as(:constructedTypes) }
        rule(:declaration) { (entityDecl | functionDecl | procedureDecl | subtypeConstraintDecl | typeDecl).as(:declaration) }
        rule(:delim) { cts(str(';').as(:delim)) }
        rule(:deriveClause) { (tDERIVE >> derivedAttr.repeat(1).as(:derivedAttr)).as(:deriveClause) }
        rule(:derivedAttr) { (attributeDecl >> op_colon >> parameterType >> op_decl >> expression >> op_delim).as(:derivedAttr) }
        rule(:digit) { (match['0-9']) }
        rule(:digits) { (digit >> digit.repeat) }
        rule(:domainRule) { ((ruleLabelId >> op_colon).maybe >> expression).as(:domainRule) }
        rule(:element) { (expression >> (op_colon >> repetition).maybe).as(:element) }
        rule(:embeddedRemark) { (str('(*') >> (str("*)").absent? >> (embeddedRemark|any)).repeat >> str('*)')).as(:embeddedRemark) }
        rule(:encodedCharacter) { (octet >> octet >> octet >> octet) }
        rule(:encodedStringLiteral) { cts((str('"') >> (encodedCharacter.repeat(1)) >> str('"')).as(:str)).as(:encodedStringLiteral) }
        rule(:entityBody) { (explicitAttr.repeat.as(:explicitAttr) >> deriveClause.maybe >> inverseClause.maybe >> uniqueClause.maybe >> whereClause.maybe).as(:entityBody) }
        rule(:entityConstructor) { (entityRef >> op_leftparen >> (expression >> (op_comma >> expression).repeat).as(:listOf_expression).maybe >> op_rightparen).as(:entityConstructor) }
        rule(:entityDecl) { (entityHead >> entityBody >> tEND_ENTITY >> op_delim).as(:entityDecl) }
        rule(:entityHead) { (tENTITY >> entityId >> subsuper >> op_delim).as(:entityHead) }
        rule(:entityId) { (simpleId).as(:entityId) }
        rule(:entityRef) { (entityId).as(:entityRef) }
        rule(:enumerationExtension) { (tBASED_ON >> typeRef >> (tWITH >> enumerationItems).maybe).as(:enumerationExtension) }
        rule(:enumerationId) { (simpleId).as(:enumerationId) }
        rule(:enumerationItem) { (enumerationId).as(:enumerationItem) }
        rule(:enumerationItems) { (op_leftparen >> (enumerationItem >> (op_comma >> enumerationItem).repeat).as(:listOf_enumerationItem) >> op_rightparen).as(:enumerationItems) }
        rule(:enumerationRef) { (enumerationId).as(:enumerationRef) }
        rule(:enumerationReference) { ((typeRef >> op_period).maybe >> enumerationRef).as(:enumerationReference) }
        rule(:enumerationType) { (tEXTENSIBLE.maybe >> tENUMERATION >> (tOF >> enumerationItems | enumerationExtension).maybe).as(:enumerationType) }
        rule(:escapeStmt) { (tESCAPE >> op_delim).as(:escapeStmt) }
        rule(:explicitAttr) { ((attributeDecl >> (op_comma >> attributeDecl).repeat).as(:listOf_attributeDecl) >> op_colon >> tOPTIONAL.maybe >> parameterType >> op_delim).as(:explicitAttr) }
        rule(:expression) { (simpleExpression >> (relOpExtended >> simpleExpression.as(:rhs)).maybe).as(:expression) }
        rule(:factor) { (simpleFactor >> (op_double_asterisk >> simpleFactor.as(:rhs)).maybe).as(:factor) }
        rule(:formalParameter) { ((parameterId >> (op_comma >> parameterId).repeat).as(:listOf_parameterId) >> op_colon >> parameterType).as(:formalParameter) }
        rule(:functionCall) { ((builtInFunction | functionRef) >> actualParameterList.maybe).as(:functionCall) }
        rule(:functionDecl) { (functionHead >> algorithmHead >> stmt.repeat(1).as(:stmt) >> tEND_FUNCTION >> op_delim).as(:functionDecl) }
        rule(:functionHead) { (tFUNCTION >> functionId >> (op_leftparen >> (formalParameter >> (op_delim >> formalParameter).repeat).as(:listOf_formalParameter) >> op_rightparen).maybe >> op_colon >> parameterType >> (op_delim.as(:op_delim2))).as(:functionHead) }
        rule(:functionId) { (simpleId).as(:functionId) }
        rule(:functionRef) { (functionId).as(:functionRef) }
        rule(:generalAggregationTypes) { (generalArrayType | generalBagType | generalListType | generalSetType).as(:generalAggregationTypes) }
        rule(:generalArrayType) { (tARRAY >> boundSpec.maybe >> tOF >> tOPTIONAL.maybe >> tUNIQUE.maybe >> parameterType).as(:generalArrayType) }
        rule(:generalBagType) { (tBAG >> boundSpec.maybe >> tOF >> parameterType).as(:generalBagType) }
        rule(:generalizedTypes) { (aggregateType | generalAggregationTypes | genericEntityType | genericType).as(:generalizedTypes) }
        rule(:generalListType) { (tLIST >> boundSpec.maybe >> tOF >> tUNIQUE.maybe >> parameterType).as(:generalListType) }
        rule(:generalRef) { (parameterRef | variableId).as(:generalRef) }
        rule(:generalSetType) { (tSET >> boundSpec.maybe >> tOF >> parameterType).as(:generalSetType) }
        rule(:genericEntityType) { (tGENERIC_ENTITY >> (op_colon >> typeLabel).maybe).as(:genericEntityType) }
        rule(:genericType) { (tGENERIC >> (op_colon >> typeLabel).maybe).as(:genericType) }
        rule(:groupQualifier) { (op_double_backslash >> entityRef).as(:groupQualifier) }
        rule(:hexDigit) { match['0-9a-fA-F'] }
        rule(:ifStmtElseStatements) { (stmt.repeat(1).as(:stmt)).as(:ifStmtElseStatements) }
        rule(:ifStmtStatements) { (stmt.repeat(1).as(:stmt)).as(:ifStmtStatements) }
        rule(:ifStmt) { (tIF >> logicalExpression >> tTHEN >> ifStmtStatements >> (tELSE >> ifStmtElseStatements).maybe >> tEND_IF >> op_delim).as(:ifStmt) }
        rule(:incrementControl) { (variableId >> op_decl >> bound1 >> tTO >> bound2 >> (tBY >> increment).maybe).as(:incrementControl) }
        rule(:increment) { (numericExpression).as(:increment) }
        rule(:index1) { (index).as(:index1) }
        rule(:index2) { (index).as(:index2) }
        rule(:index) { (numericExpression).as(:index) }
        rule(:indexQualifier) { (op_leftbracket >> index1 >> (op_colon >> index2).maybe >> op_rightbracket).as(:indexQualifier) }
        rule(:instantiableType) { (concreteTypes | entityRef).as(:instantiableType) }
        rule(:integerLiteral) { cts(digits.as(:str)).as(:integerLiteral) }
        rule(:integerType) { (tINTEGER).as(:integerType) }
        rule(:interfaceSpecification) { (referenceClause | useClause).as(:interfaceSpecification) }
        rule(:intervalHigh) { (simpleExpression).as(:intervalHigh) }
        rule(:intervalItem) { (simpleExpression).as(:intervalItem) }
        rule(:intervalLow) { (simpleExpression).as(:intervalLow) }
        rule(:interval) { (op_left_curly_brace >> intervalLow >> intervalOp >> intervalItem >> (intervalOp.as(:intervalOp2)) >> intervalHigh >> op_right_curly_brace).as(:interval) }
        rule(:intervalOp) { (op_less_equal | op_less_than).as(:intervalOp) }
        rule(:inverseAttr) { (attributeDecl >> op_colon >> inverseAttrType >> tFOR >> (entityRef >> op_period).maybe >> attributeRef >> op_delim).as(:inverseAttr) }
        rule(:inverseAttrType) { (((tSET | tBAG) >> boundSpec.maybe >> tOF).maybe >> entityRef).as(:inverseAttrType) }
        rule(:inverseClause) { (tINVERSE >> inverseAttr.repeat(1).as(:inverseAttr)).as(:inverseClause) }
        rule(:letter) { match['a-zA-Z'] }
        rule(:listType) { (tLIST >> boundSpec.maybe >> tOF >> tUNIQUE.maybe >> instantiableType).as(:listType) }
        rule(:literal) { (binaryLiteral | logicalLiteral | realLiteral | integerLiteral | stringLiteral).as(:literal) }
        rule(:localDecl) { (tLOCAL >> localVariable.repeat(1).as(:localVariable) >> tEND_LOCAL >> op_delim).as(:localDecl) }
        rule(:localVariable) { ((variableId >> (op_comma >> variableId).repeat).as(:listOf_variableId) >> op_colon >> parameterType >> (op_decl >> expression).maybe >> op_delim).as(:localVariable) }
        rule(:logicalExpression) { (expression).as(:logicalExpression) }
        rule(:logicalLiteral) { (tFALSE | tTRUE | tUNKNOWN).as(:logicalLiteral) }
        rule(:logicalType) { (tLOGICAL).as(:logicalType) }
        rule(:multiplicationLikeOp) { (op_asterisk | op_slash | tDIV | tMOD | tAND | op_double_pipe).as(:multiplicationLikeOp) }
        rule(:namedTypeOrRename) { (namedTypes >> (tAS >> (entityId | typeId)).maybe).as(:namedTypeOrRename) }
        rule(:namedTypes) { (entityRef | typeRef).as(:namedTypes) }
        rule(:nullStmt) { (op_delim).as(:nullStmt) }
        rule(:numberType) { (tNUMBER).as(:numberType) }
        rule(:numericExpression) { (simpleExpression).as(:numericExpression) }
        rule(:octet) { hexDigit >> hexDigit }
        rule(:oneOf) { (tONEOF >> op_leftparen >> (supertypeExpression >> (op_comma >> supertypeExpression).repeat).as(:listOf_supertypeExpression) >> op_rightparen).as(:oneOf) }
        rule(:op_asterisk) { cstr('*').as(:op_asterisk) }
        rule(:op_colon) { cstr(':').as(:op_colon) }
        rule(:op_colon_equals_colon) { cstr(':=:').as(:op_colon_equals_colon) }
        rule(:op_colon_less_greater_colon) { cstr(':<>:').as(:op_colon_less_greater_colon) }
        rule(:op_comma) { cstr(',').as(:op_comma) }
        rule(:op_decl) { cstr(':=').as(:op_decl) }
        rule(:op_delim) { cstr(';').as(:op_delim) }
        rule(:op_double_asterisk) { cstr('**').as(:op_double_asterisk) }
        rule(:op_double_backslash) { cstr('\\').as(:op_double_backslash) }
        rule(:op_double_pipe) { cstr('||').as(:op_double_pipe) }
        rule(:op_equals) { cstr('=').as(:op_equals) }
        rule(:op_greater_equal) { cstr('>=').as(:op_greater_equal) }
        rule(:op_greater_than) { cstr('>').as(:op_greater_than) }
        rule(:op_leftbracket) { cstr('[').as(:op_leftbracket) }
        rule(:op_left_curly_brace) { cstr('{').as(:op_left_curly_brace) }
        rule(:op_leftparen) { cstr('(').as(:op_leftparen) }
        rule(:op_less_equal) { cstr('<=').as(:op_less_equal) }
        rule(:op_less_greater) { cstr('<>').as(:op_less_greater) }
        rule(:op_less_than) { cstr('<').as(:op_less_than) }
        rule(:op_minus) { cstr('-').as(:op_minus) }
        rule(:op_period) { cstr('.').as(:op_period) }
        rule(:op_pipe) { cstr('|').as(:op_pipe) }
        rule(:op_plus) { cstr('+').as(:op_plus) }
        rule(:op_query_begin) { cstr('<*').as(:op_query_begin) }
        rule(:op_query_end) { cstr('*>').as(:op_query_end) }
        rule(:op_question_mark) { cstr('?').as(:op_question_mark) }
        rule(:op_rightbracket) { cstr(']').as(:op_rightbracket) }
        rule(:op_right_curly_brace) { cstr('}').as(:op_right_curly_brace) }
        rule(:op_rightparen) { cstr(')').as(:op_rightparen) }
        rule(:op_slash) { cstr('/').as(:op_slash) }
        rule(:parameter) { (expression).as(:parameter) }
        rule(:parameterId) { (simpleId).as(:parameterId) }
        rule(:parameterRef) { (parameterId).as(:parameterRef) }
        rule(:parameterType) { (generalizedTypes | namedTypes | simpleTypes).as(:parameterType) }
        rule(:population) { (entityRef).as(:population) }
        rule(:precisionSpec) { (numericExpression).as(:precisionSpec) }
        rule(:primary) { (literal | qualifiableFactor >> qualifier.repeat.as(:qualifier)).as(:primary) }
        rule(:procedureCallStmt) { ((builtInProcedure | procedureRef) >> actualParameterList.maybe >> op_delim).as(:procedureCallStmt) }
        rule(:procedureDecl) { (procedureHead >> algorithmHead >> stmt.repeat.as(:stmt) >> tEND_PROCEDURE >> op_delim).as(:procedureDecl) }
        rule(:procedureHeadParameter) { (tVAR.maybe >> formalParameter).as(:procedureHeadParameter) }
        rule(:procedureHead) { (tPROCEDURE >> procedureId >> (op_leftparen >> (procedureHeadParameter >> (op_delim >> procedureHeadParameter).repeat).as(:listOf_procedureHeadParameter) >> op_rightparen).maybe >> (op_delim.as(:op_delim2))).as(:procedureHead) }
        rule(:procedureId) { (simpleId).as(:procedureId) }
        rule(:procedureRef) { (procedureId).as(:procedureRef) }
        rule(:qualifiableFactor) { (attributeRef | constantFactor | functionCall | generalRef | population).as(:qualifiableFactor) }
        rule(:qualifiedAttribute) { (tSELF >> groupQualifier >> attributeQualifier).as(:qualifiedAttribute) }
        rule(:qualifier) { (attributeQualifier | groupQualifier | indexQualifier).as(:qualifier) }
        rule(:queryExpression) { (tQUERY >> op_leftparen >> variableId >> op_query_begin >> aggregateSource >> op_pipe >> logicalExpression >> op_rightparen).as(:queryExpression) }
        rule(:realLiteral) { cts((digits >> str('.') >> digits.maybe >> (match['eE'] >> sign.maybe >> digits).maybe).as(:str)).as(:realLiteral) }
        rule(:realType) { (tREAL >> (op_leftparen >> precisionSpec >> op_rightparen).maybe).as(:realType) }
        rule(:redeclaredAttribute) { (qualifiedAttribute >> (tRENAMED >> attributeId).maybe).as(:redeclaredAttribute) }
        rule(:referenceClause) { (tREFERENCE >> tFROM >> schemaRef >> (op_leftparen >> (resourceOrRename >> (op_comma >> resourceOrRename).repeat).as(:listOf_resourceOrRename) >> op_rightparen).maybe >> op_delim).as(:referenceClause) }
        rule(:referencedAttribute) { (attributeRef | qualifiedAttribute).as(:referencedAttribute) }
        rule(:relOpExtended) { (relOp | tIN | tLIKE).as(:relOpExtended) }
        rule(:relOp) { (op_less_equal | op_greater_equal | op_less_greater | op_less_than | op_greater_than | op_equals | op_colon_less_greater_colon | op_colon_equals_colon).as(:relOp) }
        rule(:renameId) { (constantId | entityId | functionId | procedureId | typeId).as(:renameId) }
        rule(:repeatControl) { (incrementControl.maybe >> whileControl.maybe >> untilControl.maybe).as(:repeatControl) }
        rule(:repeatStmt) { (tREPEAT >> repeatControl >> op_delim >> stmt.repeat(1).as(:stmt) >> tEND_REPEAT >> (op_delim.as(:op_delim2))).as(:repeatStmt) }
        rule(:repetition) { (numericExpression).as(:repetition) }
        rule(:resourceOrRename) { (resourceRef >> (tAS >> renameId).maybe).as(:resourceOrRename) }
        rule(:resourceRef) { (constantRef | entityRef | functionRef | procedureRef | typeRef).as(:resourceRef) }
        rule(:returnStmt) { (tRETURN >> (op_leftparen >> expression >> op_rightparen).maybe >> op_delim).as(:returnStmt) }
        rule(:ruleDecl) { (ruleHead >> algorithmHead >> stmt.repeat.as(:stmt) >> whereClause >> tEND_RULE >> op_delim).as(:ruleDecl) }
        rule(:ruleHead) { (tRULE >> ruleId >> tFOR >> op_leftparen >> (entityRef >> (op_comma >> entityRef).repeat).as(:listOf_entityRef) >> op_rightparen >> op_delim).as(:ruleHead) }
        rule(:ruleId) { (simpleId).as(:ruleId) }
        rule(:ruleLabelId) { (simpleId).as(:ruleLabelId) }
        rule(:ruleLabelRef) { (ruleLabelId).as(:ruleLabelRef) }
        rule(:ruleRef) { (ruleId).as(:ruleRef) }
        rule(:schemaBodyDeclaration) { (declaration | ruleDecl).as(:schemaBodyDeclaration) }
        rule(:schemaBody) { (interfaceSpecification.repeat.as(:interfaceSpecification) >> constantDecl.maybe >> schemaBodyDeclaration.repeat.as(:schemaBodyDeclaration)).as(:schemaBody) }
        rule(:schemaDecl) { (tSCHEMA >> schemaId >> schemaVersionId.maybe >> op_delim >> schemaBody >> tEND_SCHEMA >> (op_delim.as(:op_delim2))).as(:schemaDecl) }
        rule(:schemaId) { (simpleId).as(:schemaId) }
        rule(:schemaRef) { (schemaId).as(:schemaRef) }
        rule(:schemaVersionId) { (stringLiteral).as(:schemaVersionId) }
        rule(:selectExtension) { (tBASED_ON >> typeRef >> (tWITH >> selectList).maybe).as(:selectExtension) }
        rule(:selectList) { (op_leftparen >> (namedTypes >> (op_comma >> namedTypes).repeat).as(:listOf_namedTypes) >> op_rightparen).as(:selectList) }
        rule(:selector) { (expression).as(:selector) }
        rule(:selectType) { ((tEXTENSIBLE >> tGENERIC_ENTITY.maybe).maybe >> tSELECT >> (selectList | selectExtension).maybe).as(:selectType) }
        rule(:setType) { (tSET >> boundSpec.maybe >> tOF >> instantiableType).as(:setType) }
        rule(:sign) { match['+-'] }
        rule(:simpleExpression) { (term >> (addLikeOp.as(:operator) >> term).as(:item).repeat.as(:rhs)).as(:simpleExpression) }
        rule(:simpleFactor) { (aggregateInitializer | entityConstructor | interval | queryExpression | simpleFactorExpression | simpleFactorUnaryExpression | enumerationReference).as(:simpleFactor) }
        rule(:simpleFactorExpression) { (op_leftparen >> expression >> op_rightparen | primary).as(:simpleFactorExpression) }
        rule(:simpleFactorUnaryExpression) { (unaryOp >> simpleFactorExpression).as(:simpleFactorUnaryExpression) }
        rule(:simpleId) { anyKeyword.absent? >> cts((match["a-zA-Z_"] >> match["a-zA-Z0-9_"].repeat).as(:str)).as(:simpleId) }
        rule(:simpleStringLiteral) { cts((str("'") >> (str("'").absent? >> any).repeat >> str("'")).as(:str)).as(:simpleStringLiteral) }
        rule(:simpleTypes) { (binaryType | booleanType | integerType | logicalType | numberType | realType | stringType).as(:simpleTypes) }
        rule(:skipStmt) { (tSKIP >> op_delim).as(:skipStmt) }
        rule(:space) { match[" \r\n\t\f"] | embeddedRemark | tailRemark }
        rule(:spaces) { space.repeat.as(:spaces) }
        rule(:stmt) { (aliasStmt | assignmentStmt | caseStmt | compoundStmt | escapeStmt | ifStmt | nullStmt | procedureCallStmt | repeatStmt | returnStmt | skipStmt).as(:stmt) }
        rule(:stringLiteral) { (simpleStringLiteral | encodedStringLiteral).as(:stringLiteral) }
        rule(:stringType) { (tSTRING >> widthSpec.maybe).as(:stringType) }
        rule(:subsuper) { (supertypeConstraint.maybe >> subtypeDeclaration.maybe).as(:subsuper) }
        rule(:subtypeConstraintBody) { (abstractSupertype.maybe >> totalOver.maybe >> (supertypeExpression >> op_delim).maybe).as(:subtypeConstraintBody) }
        rule(:subtypeConstraintDecl) { (subtypeConstraintHead >> subtypeConstraintBody >> tEND_SUBTYPE_CONSTRAINT >> op_delim).as(:subtypeConstraintDecl) }
        rule(:subtypeConstraintHead) { (tSUBTYPE_CONSTRAINT >> subtypeConstraintId >> tFOR >> entityRef >> op_delim).as(:subtypeConstraintHead) }
        rule(:subtypeConstraintId) { (simpleId).as(:subtypeConstraintId) }
        rule(:subtypeConstraintRef) { (subtypeConstraintId).as(:subtypeConstraintRef) }
        rule(:subtypeConstraint) { (tOF >> op_leftparen >> supertypeExpression >> op_rightparen).as(:subtypeConstraint) }
        rule(:subtypeDeclaration) { (tSUBTYPE >> tOF >> op_leftparen >> entityRef >> (op_comma >> entityRef).repeat >> op_rightparen).as(:listOf_entityRef).as(:subtypeDeclaration) }
        rule(:supertypeConstraint) { (abstractSupertypeDeclaration | abstractEntityDeclaration | supertypeRule).as(:supertypeConstraint) }
        rule(:supertypeExpression) { (supertypeFactor >> (tANDOR.as(:operator) >> supertypeFactor).as(:item).repeat.as(:rhs)).as(:supertypeExpression) }
        rule(:supertypeFactor) { (supertypeTerm >> (tAND.as(:operator) >> supertypeTerm).as(:item).repeat.as(:rhs)).as(:supertypeFactor) }
        rule(:supertypeRule) { (tSUPERTYPE >> subtypeConstraint).as(:supertypeRule) }
        rule(:supertypeTerm) { (entityRef | oneOf | op_leftparen >> supertypeExpression >> op_rightparen).as(:supertypeTerm) }
        rule(:syntax) { (spaces.as(:spaces) >> schemaDecl.repeat(1).as(:schemaDecl) >> spaces.as(:trailer)).as(:syntax) }
        rule(:tailRemark) { (str('--') >> (str("\n").absent? >> any).repeat >> str("\n")).as(:tailRemark) }
        rule(:term) { (factor >> (multiplicationLikeOp >> factor).as(:item).repeat.as(:rhs)).as(:term) }
        rule(:totalOver) { (tTOTAL_OVER >> op_leftparen >> (entityRef >> (op_comma >> entityRef).repeat).as(:listOf_entityRef) >> op_rightparen >> op_delim).as(:totalOver) }
        rule(:typeDecl) { (tTYPE >> typeId >> op_equals >> underlyingType >> op_delim >> whereClause.maybe >> tEND_TYPE >> (op_delim.as(:op_delim2))).as(:typeDecl) }
        rule(:typeId) { (simpleId).as(:typeId) }
        rule(:typeLabelId) { (simpleId).as(:typeLabelId) }
        rule(:typeLabelRef) { (typeLabelId).as(:typeLabelRef) }
        rule(:typeLabel) { (typeLabelId | typeLabelRef).as(:typeLabel) }
        rule(:typeRef) { (typeId).as(:typeRef) }
        rule(:unaryOp) { (op_plus | op_minus | tNOT).as(:unaryOp) }
        rule(:underlyingType) { (concreteTypes | constructedTypes).as(:underlyingType) }
        rule(:uniqueClause) { (tUNIQUE >> (uniqueRule >> op_delim >> (uniqueRule >> (op_delim.as(:op_delim2))).repeat).as(:listOf_uniqueRule)).as(:uniqueClause) }
        rule(:uniqueRule) { ((ruleLabelId >> op_colon).maybe >> (referencedAttribute >> (op_comma >> referencedAttribute).repeat).as(:listOf_referencedAttribute)).as(:uniqueRule) }
        rule(:untilControl) { (tUNTIL >> logicalExpression).as(:untilControl) }
        rule(:useClause) { (tUSE >> tFROM >> schemaRef >> (op_leftparen >> (namedTypeOrRename >> (op_comma >> namedTypeOrRename).repeat).as(:listOf_namedTypeOrRename) >> op_rightparen).maybe >> op_delim).as(:useClause) }
        rule(:variableId) { (simpleId).as(:variableId) }
        rule(:variableRef) { (variableId).as(:variableRef) }
        rule(:whereClause) { (tWHERE >> (domainRule >> op_delim).repeat.as(:listOf_domainRule)).as(:whereClause) }
        rule(:whileControl) { (tWHILE >> logicalExpression).as(:whileControl) }
        rule(:width) { (numericExpression).as(:width) }
        rule(:widthSpec) { (op_leftparen >> width >> op_rightparen >> tFIXED.maybe).as(:widthSpec) }
      end

      # Parses Express file into an Express model
      # @param [String] file Express file path
      # @param [Boolean] skip_references skip resolving references
      # @param [Boolean] include_source attach original source code to model elements
      # @return [Model::Repository]
      def self.from_file(file, skip_references: nil, include_source: nil)
        source = File.read file
        ast = Parser.new.parse source

        visitor = Expressir::Express::Visitor.new(source, include_source: include_source)
        transformed = visitor.visit_ast ast,:top
        @repository = transformed

        @repository.schemas.each do |schema|
          schema.file = file.to_s
        end

        unless skip_references
          @resolve_references_model_visitor = ResolveReferencesModelVisitor.new
          @resolve_references_model_visitor.visit(@repository)
        end

        @repository
      end

      # Parses Express files into an Express model
      # @param [Array<String>] files Express file paths
      # @param [Boolean] skip_references skip resolving references
      # @param [Boolean] include_source attach original source code to model elements
      # @return [Model::Repository]
      def self.from_files(files, skip_references: nil, include_source: nil)
        schemas = files.each_with_index.map do |file, i|
          # start = Time.now
          repository = self.from_file(file, skip_references: true)
          # STDERR.puts "#{i+1}/#{files.length} #{file} #{Time.now - start}"
          repository.schemas
        end.flatten

        @repository = Model::Repository.new(
          schemas: schemas
        )

        unless @skip_references
          @resolve_references_model_visitor = ResolveReferencesModelVisitor.new
          @resolve_references_model_visitor.visit(@repository)
        end

        @repository
      end
    end
  end
end
--- END FILE: lib/expressir/express/parser.rb ---
--- START FILE: lib/expressir/express/resolve_references_model_visitor.rb ---
require "expressir/express/model_visitor"
require "expressir/model"

module Expressir
  module Express
    class ResolveReferencesModelVisitor < ModelVisitor
      def visit(node)
        if node.is_a? Model::References::SimpleReference
          visit_references_simple_reference(node)
        end

        super
      end

      private

      def visit_references_simple_reference(node)
        return if node.parent.is_a? Model::References::AttributeReference

        if node.parent.is_a? Model::Declarations::InterfaceItem
          base_item = node.find("#{node.parent.parent.schema.id}.#{node.parent.ref.id}")
        else
          base_item = node.find(node.id)
        end
        return unless base_item

        node.base_path = base_item.path
      end
    end
  end
end
--- END FILE: lib/expressir/express/resolve_references_model_visitor.rb ---
--- START FILE: lib/expressir/express/schema_head_formatter.rb ---
module Expressir
  module Express
    # Formatter module - format schema as schema head only
    # @example Include into Formatter subclass
    #   formatter = Class.new(Expressir::Express::Formatter) do
    #     include Expressir::Express::SchemaHeadFormatter
    #   end
    module SchemaHeadFormatter
      # @!visibility private
      def self.included(mod)
        if !mod.superclass.private_method_defined? :format_declarations_schema or !mod.superclass.private_method_defined? :format_declarations_schema_head
          raise 'Missing method'
        end
      end

      private

      def format_declarations_schema(node)
        format_declarations_schema_head(node)
      end
    end
  end
end
--- END FILE: lib/expressir/express/schema_head_formatter.rb ---
--- START FILE: lib/expressir/express/visitor.rb ---
require "expressir/model"
require "set"

# reference type is not recognized
# see note in A.1.5 Interpreted identifiers
# > It is expected that identifiers matching these syntax rules are known to an implementation.
# > How the implementation obtains this information is of no concern to the definition of the language. One
# > method of gaining this information is multi-pass parsing: the first pass collects the identifiers from their
# > declarations, so that subsequent passes are then able to distinguish a veriable_ref from a function_ref,
# > for example.
# - such multi-pass parsing is not implemented yet
# - xxxRef - merged to SimpleReference
# - entityConstructor, functionCall - merged to FunctionCall
#
# difference between generalized and instantiable types is not recognized
# see note in 8.6.2 Parameter data types
# > A syntactic construct such as ARRAY[1:3] OF REAL satisfies two syntactic productions —
# > aggregation_type and general_aggregation_type. It is considered to be instantiable no matter which
# > production it is required to satisfy in the syntax.
#
# static shorthands are unwrapped
# - entity attributes, function/procedure parameters, local variables
#
# all access to ctx members must happen before calling other visitor code
# - prevents segfault in ANTLR4 C++ runtime, not sure why they are caused
# - e.g. see visit_schema_decl

require 'objspace'

module Expressir
  module Express
    class Visitor
      class Ctx
        attr_reader :name
        attr_reader :data
        attr_accessor :source_pos
        def initialize(data,name)
          @data = data
          @name = name
        end

        def text
          str.data.to_s
        end

        def method_missing(name,*args)
          rulename = name.to_s.sub(/^visit_/,"").gsub(/_([a-z])/) { |m| m[1].upcase }.to_sym
          self.class.define_method(name) { @data[rulename] }
          self.send name, *args
        end

        def keys
          @data.keys
        end

        def values
          @data.values
        end

        def each(&block)
          @data.values.each(&block)
        end
      end

      class SimpleCtx
        attr_reader :name
        attr_reader :data
        def initialize(data,name)
          @data = data
          @name = name
        end

        def text
          @data.to_s
        end
      end

      REMARK_CHANNEL = 2

      private_constant :REMARK_CHANNEL

      # @param [::ExpressParser::TokenVector] Rice-wrapped std::vector<TokenProxy>
      # @param [Boolean] include_source attach original source code to model elements
      def initialize(source, include_source: nil)
        @source = source
        @include_source = include_source

        @attached_remark_tokens = Set.new

        @visit_methods = Hash[
          private_methods.grep(/^visit_/).map { |name|
            rulename = name.to_s.sub(/^visit_/,"").gsub(/_([a-z])/) { $1.upcase }
            [rulename.to_sym,name.to_sym]
          }
        ]
      end

      def to_ctx(ast,name=:unnamed)
        case ast
        when Hash
          nodes = Hash[
            ast.map { |k,v|
              if k.match(/^listOf_(.*)$/)
                itemkey = $1.to_sym
                ary = (Array === v) ? v : [v]
                [ itemkey, to_ctx(ary.select { |v| v[itemkey] }.map { |v| v.slice(itemkey) }) ]
              else
                [ k, to_ctx(v,k) ]
              end
            }
          ]
          Ctx.new nodes,name
        when Array
          ast.map { |v|
            v.length == 1 or raise "element of array invalid (#{v.keys})"
            to_ctx(v.values[0],v.keys[0])
          }
        when nil
          nil
        else
          SimpleCtx.new ast,name
        end
      end

      def get_source_pos(ctx)
        ranges = nil
        ranges = case ctx
        when Ctx
          ctx.source_pos and return ctx.source_pos # cache
          ctx.values.map { |item| get_source_pos(item) }
        when SimpleCtx
          return nil unless ctx.data.respond_to? :offset
          [ [ctx.data.offset, ctx.data.offset + ctx.data.length] ]
        when Array
          ctx.map { |item| get_source_pos(item) }
        else
          raise "unknown type in Ctx tree: #{ctx}"
        end
        source_pos = ranges.compact.reduce { |item,acc|
          [ [item[0],acc[0]].min, [item[1],acc[1]].max ]
        }
        Ctx === ctx and ctx.source_pos = source_pos
        source_pos
      end

      def get_source(ctx)
        a,b = get_source_pos ctx
        @source[a..b-1].strip
      end

      def visit_ast(ast,name)
        ctx = to_ctx(ast,name)

        visit ctx
      end

      def visit(ctx)
        if Array === ctx
          return ctx.map { |el| visit el }
        end

        node = ctx
        if @visit_methods[ctx.name]
          node = send(@visit_methods[ctx.name],ctx)
          if @include_source && node.respond_to?(:source)
            node.source = get_source ctx
          end
        end

        attach_remarks(ctx, node)
        node
      end

      ############################################3
      private

      def visit_top(ctx)
        visit ctx.syntax
      end

      def visit_if(ctx, default = nil)
        if ctx
          visit(ctx)
        else
          default
        end
      end

      def visit_if_map(ctx)
        if ctx
          ctx.map{|ctx2| visit(ctx2)}
        else
          []
        end
      end

      def visit_if_map_flatten(ctx)
        if ctx
          ctx.map{|ctx2| visit(ctx2)}.flatten
        else
          []
        end
      end

      def node_find(node, path)
        if node.is_a?(Enumerable)
          target_node = node.find { |item| item.find(path) }
        else
          target_node = node.find(path)
        end
        target_node
      end

      def find_remark_target(node, path)
        target_node = node_find(node, path)

        return target_node if target_node

        # check if path can create implicit remark item
        # see https://github.com/lutaml/expressir/issues/78
        rest, _, current_path = path.rpartition(".") # get last path part
        _, _, current_path = current_path.rpartition(":") # ignore prefix
        parent_node = node_find(node, rest)
        if parent_node and parent_node.class.method_defined? :remark_items
          remark_item = Model::Declarations::RemarkItem.new(
            id: current_path
          )
          remark_item.parent = parent_node

          # check if path can create implicit informal proposition
          # see https://github.com/lutaml/expressir/issues/50
          if parent_node.class.method_defined? :informal_propositions and current_path.match(/^IP\d+$/)
            parent_node.informal_propositions << remark_item
          else
            parent_node.remark_items << remark_item
          end
          parent_node.reset_children_by_id

          remark_item
        end
      end

      def get_remarks(ctx,indent="")
        case ctx
        when Ctx
          ctx.values.map { |item| get_remarks(item,indent+"  ") }.inject([],:+)
        when Array
          x = ctx.map { |item| get_remarks(item,indent+"  ") }.inject([],:+)
          x
        else
          if [:tailRemark, :embeddedRemark].include?(ctx.name)
            [ get_source_pos(ctx) ]
          else
            []
          end
        end
      end

      def attach_remarks(ctx, node)

        remark_tokens = get_remarks ctx

        # skip already attached remarks
        remark_tokens = remark_tokens.select{|x| !@attached_remark_tokens.include?(x)}

        # parse remarks, find remark targets
        tagged_remark_tokens = remark_tokens.map do |span|
          text = @source[span[0]..span[1]-1]
          _, remark_tag, remark_text = if text.start_with?('--')
            text.match(/^--"([^"]*)"(.*)$/).to_a
          else
            text.match(/^\(\*"([^"]*)"(.*)\*\)$/m).to_a
          end

          if remark_tag
            remark_target = find_remark_target(node, remark_tag)
          end
          if remark_text
            remark_text = remark_text.strip.force_encoding('UTF-8')
          end

          [span, remark_target, remark_text]
        end.select{|x| x[1]}

        tagged_remark_tokens.each do |span, remark_target, remark_text|
          # attach remark
          remark_target.remarks ||= []
          remark_target.remarks << remark_text

          # mark remark as attached, so that it is not attached again at higher nesting level
          @attached_remark_tokens << span
        end
      end

      def visit_attribute_ref(ctx)
        ctx__attribute_id = ctx.attribute_id

        id = visit_if(ctx__attribute_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_constant_ref(ctx)
        ctx__constant_id = ctx.constant_id

        id = visit_if(ctx__constant_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_entity_ref(ctx)
        ctx__entity_id = ctx.entity_id

        id = visit_if(ctx__entity_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_enumeration_ref(ctx)
        ctx__enumeration_id = ctx.enumeration_id

        id = visit_if(ctx__enumeration_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_function_ref(ctx)
        ctx__function_id = ctx.function_id

        id = visit_if(ctx__function_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_parameter_ref(ctx)
        ctx__parameter_id = ctx.parameter_id

        id = visit_if(ctx__parameter_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_procedure_ref(ctx)
        ctx__procedure_id = ctx.procedure_id

        id = visit_if(ctx__procedure_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_rule_label_ref(ctx)
        ctx__rule_label_id = ctx.rule_label_id

        id = visit_if(ctx__rule_label_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_rule_ref(ctx)
        ctx__rule_id = ctx.rule_id

        id = visit_if(ctx__rule_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_schema_ref(ctx)
        ctx__schema_id = ctx.schema_id

        id = visit_if(ctx__schema_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_subtype_constraint_ref(ctx)
        ctx__subtype_constraint_id = ctx.subtype_constraint_id

        id = visit_if(ctx__subtype_constraint_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_type_label_ref(ctx)
        ctx__type_label_id = ctx.type_label_id

        id = visit_if(ctx__type_label_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_type_ref(ctx)
        ctx__type_id = ctx.type_id

        id = visit_if(ctx__type_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_variable_ref(ctx)
        ctx__variable_id = ctx.variable_id

        id = visit_if(ctx__variable_id)

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_abstract_entity_declaration(ctx)
        raise 'Invalid state'
      end

      def visit_abstract_supertype(ctx)
        raise 'Invalid state'
      end

      def visit_abstract_supertype_declaration(ctx)
        ctx__subtype_constraint = ctx.subtype_constraint

        visit_if(ctx__subtype_constraint)
      end

      def visit_actual_parameter_list(ctx)
        ctx__parameter = ctx.parameter

        visit_if_map(ctx__parameter)
      end

      def visit_add_like_op(ctx)
        ctx__text = ctx.values[0].text
        ctx__ADDITION = ctx__text == '+'
        ctx__SUBTRACTION = ctx__text == '-'
        ctx__OR = ctx.tOR
        ctx__XOR = ctx.tXOR

        if ctx__ADDITION
          Model::Expressions::BinaryExpression::ADDITION
        elsif ctx__SUBTRACTION
          Model::Expressions::BinaryExpression::SUBTRACTION
        elsif ctx__OR
          Model::Expressions::BinaryExpression::OR
        elsif ctx__XOR
          Model::Expressions::BinaryExpression::XOR
        else
          raise 'Invalid state'
        end
      end

      def visit_aggregate_initializer(ctx)
        ctx__element = ctx.element

        items = visit_if_map(ctx__element)

        Model::Expressions::AggregateInitializer.new(
          items: items
        )
      end

      def visit_aggregate_source(ctx)
        ctx__simple_expression = ctx.simple_expression

        visit_if(ctx__simple_expression)
      end

      def visit_aggregate_type(ctx)
        ctx__type_label = ctx.type_label
        ctx__parameter_type = ctx.parameter_type

        id = visit_if(ctx__type_label)
        base_type = visit_if(ctx__parameter_type)

        Model::DataTypes::Aggregate.new(
          id: id,
          base_type: base_type
        )
      end

      def visit_aggregation_types(ctx)
        ctx__array_type = ctx.array_type
        ctx__bag_type = ctx.bag_type
        ctx__list_type = ctx.list_type
        ctx__set_type = ctx.set_type

        visit_if(ctx__array_type || ctx__bag_type || ctx__list_type || ctx__set_type)
      end

      def visit_algorithm_head(ctx)
        raise 'Invalid state'
      end

      def visit_alias_stmt(ctx)
        ctx__variable_id = ctx.variable_id
        ctx__general_ref = ctx.general_ref
        ctx__qualifier = ctx.qualifier
        ctx__stmt = ctx.stmt

        id = visit_if(ctx__variable_id)
        expression = handle_qualified_ref(visit_if(ctx__general_ref), ctx__qualifier)
        statements = visit_if_map(ctx__stmt)

        Model::Statements::Alias.new(
          id: id,
          expression: expression,
          statements: statements
        )
      end

      def visit_array_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__OPTIONAL = ctx.tOPTIONAL
        ctx__UNIQUE = ctx.tUNIQUE
        ctx__instantiable_type = ctx.instantiable_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        optional = ctx__OPTIONAL && true
        unique = ctx__UNIQUE && true
        base_type = visit_if(ctx__instantiable_type)

        Model::DataTypes::Array.new(
          bound1: bound1,
          bound2: bound2,
          optional: optional,
          unique: unique,
          base_type: base_type
        )
      end

      def visit_assignment_stmt(ctx)
        ctx__general_ref = ctx.general_ref
        ctx__qualifier = ctx.qualifier
        ctx__expression = ctx.expression

        ref = handle_qualified_ref(visit_if(ctx__general_ref), ctx__qualifier)
        expression = visit_if(ctx__expression)

        Model::Statements::Assignment.new(
          ref: ref,
          expression: expression
        )
      end

      def visit_attribute_decl(ctx)
        ctx__attribute_id = ctx.attribute_id
        ctx__redeclared_attribute = ctx.redeclared_attribute
        ctx__redeclared_attribute__qualified_attribute = ctx__redeclared_attribute&.qualified_attribute
        ctx__redeclared_attribute__attribute_id = ctx__redeclared_attribute&.attribute_id

        id = visit_if(ctx__attribute_id || ctx__redeclared_attribute__attribute_id)
        supertype_attribute = visit_if(ctx__redeclared_attribute__qualified_attribute)

        Model::Declarations::Attribute.new(
          id: id,
          supertype_attribute: supertype_attribute
        )
      end

      def visit_attribute_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_attribute_qualifier(ctx)
        ctx__attribute_ref = ctx.attribute_ref

        attribute = visit_if(ctx__attribute_ref)

        Model::References::AttributeReference.new(
          attribute: attribute
        )
      end

      def visit_attribute_reference(ctx)
        raise 'Invalid state'
      end

      def visit_bag_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__instantiable_type = ctx.instantiable_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        base_type = visit_if(ctx__instantiable_type)

        Model::DataTypes::Bag.new(
          bound1: bound1,
          bound2: bound2,
          base_type: base_type
        )
      end

      def visit_binary_type(ctx)
        ctx__width_spec = ctx.width_spec
        ctx__width_spec__width = ctx__width_spec&.width
        ctx__width_spec__FIXED = ctx__width_spec&.tFIXED

        width = visit_if(ctx__width_spec__width)
        fixed = ctx__width_spec__FIXED && true

        Model::DataTypes::Binary.new(
          width: width,
          fixed: fixed
        )
      end

      def visit_boolean_type(ctx)
        Model::DataTypes::Boolean.new
      end

      def visit_bound1(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_bound2(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_bound_spec(ctx)
        raise 'Invalid state'
      end

      def visit_built_in_constant(ctx)
        ctx__text = ctx.values[0].text

        id = ctx__text

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_built_in_function(ctx)
        ctx__text = ctx.values[0].text

        id = ctx__text

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_built_in_procedure(ctx)
        ctx__text = ctx.values[0].text

        id = ctx__text

        Model::References::SimpleReference.new(
          id: id
        )
      end

      def visit_case_action(ctx)
        ctx__case_label = ctx.case_label
        ctx__stmt = ctx.stmt

        labels = visit_if_map(ctx__case_label)
        statement = visit_if(ctx__stmt)

        Model::Statements::CaseAction.new(
          labels: labels,
          statement: statement
        )
      end

      def visit_case_label(ctx)
        ctx__expression = ctx.expression

        visit_if(ctx__expression)
      end

      def visit_case_stmt(ctx)
        ctx__selector = ctx.selector
        ctx__case_action = ctx.case_action
        ctx__stmt = ctx.stmt
        ctx__selector__expression = ctx__selector&.expression

        expression = visit_if(ctx__selector__expression)
        actions = visit_if_map_flatten(ctx__case_action)
        otherwise_statement = visit_if(ctx__stmt)

        Model::Statements::Case.new(
          expression: expression,
          actions: actions,
          otherwise_statement: otherwise_statement
        )
      end

      def visit_compound_stmt(ctx)
        ctx__stmt = ctx.stmt

        statements = visit_if_map(ctx__stmt)

        Model::Statements::Compound.new(
          statements: statements
        )
      end

      def visit_concrete_types(ctx)
        ctx__aggregation_types = ctx.aggregation_types
        ctx__simple_types = ctx.simple_types
        ctx__type_ref = ctx.type_ref

        visit_if(ctx__aggregation_types || ctx__simple_types || ctx__type_ref)
      end

      def visit_constant_body(ctx)
        ctx__constant_id = ctx.constant_id
        ctx__instantiable_type = ctx.instantiable_type
        ctx__expression = ctx.expression

        id = visit_if(ctx__constant_id)
        type = visit_if(ctx__instantiable_type)
        expression = visit_if(ctx__expression)

        Model::Declarations::Constant.new(
          id: id,
          type: type,
          expression: expression
        )
      end

      def visit_constant_decl(ctx)
        ctx__constant_body = ctx.constant_body

        visit_if_map(ctx__constant_body)
      end

      def visit_constant_factor(ctx)
        ctx__built_in_constant = ctx.built_in_constant
        ctx__constant_ref = ctx.constant_ref

        visit_if(ctx__built_in_constant || ctx__constant_ref)
      end

      def visit_constant_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_constructed_types(ctx)
        ctx__enumeration_type = ctx.enumeration_type
        ctx__select_type = ctx.select_type

        visit_if(ctx__enumeration_type || ctx__select_type)
      end

      def visit_declaration(ctx)
        ctx__entity_decl = ctx.entity_decl
        ctx__function_decl = ctx.function_decl
        ctx__procedure_decl = ctx.procedure_decl
        ctx__subtype_constraint_decl = ctx.subtype_constraint_decl
        ctx__type_decl = ctx.type_decl

        visit_if(ctx__entity_decl || ctx__function_decl || ctx__procedure_decl || ctx__subtype_constraint_decl || ctx__type_decl)
      end

      def visit_derived_attr(ctx)
        ctx__attribute_decl = ctx.attribute_decl
        ctx__parameter_type = ctx.parameter_type
        ctx__expression = ctx.expression

        attribute = visit_if(ctx__attribute_decl)
        type = visit_if(ctx__parameter_type)
        expression = visit_if(ctx__expression)

        Model::Declarations::Attribute.new(
          id: attribute.id, # reuse
          kind: Model::Declarations::Attribute::DERIVED,
          supertype_attribute: attribute.supertype_attribute, # reuse
          type: type,
          expression: expression
        )
      end

      def visit_derive_clause(ctx)
        ctx__derived_attr = ctx.derived_attr

        visit_if_map(ctx__derived_attr)
      end

      def visit_domain_rule(ctx)
        ctx__rule_label_id = ctx.rule_label_id
        ctx__expression = ctx.expression

        id = visit_if(ctx__rule_label_id)
        expression = visit_if(ctx__expression)

        Model::Declarations::WhereRule.new(
          id: id,
          expression: expression
        )
      end

      def visit_element(ctx)
        ctx__expression = ctx.expression
        ctx__repetition = ctx.repetition

        if ctx__repetition
          expression = visit_if(ctx__expression)
          repetition = visit_if(ctx__repetition)

          Model::Expressions::AggregateInitializerItem.new(
            expression: expression,
            repetition: repetition
          )
        else
          visit_if(ctx__expression)
        end
      end

      def visit_entity_body(ctx)
        raise 'Invalid state'
      end

      def visit_entity_constructor(ctx)
        ctx__entity_ref = ctx.entity_ref
        ctx__expression = ctx.expression

        entity = visit_if(ctx__entity_ref)
        parameters = visit_if_map(ctx__expression)

        # Model::Expressions::EntityConstructor.new(
        #   entity: entity,
        #   parameters: parameters
        # )
        Model::Expressions::FunctionCall.new(
          function: entity,
          parameters: parameters
        )
      end

      def visit_entity_decl(ctx)
        ctx__entity_head = ctx.entity_head
        ctx__entity_body = ctx.entity_body
        ctx__entity_head__entity_id = ctx__entity_head&.entity_id
        ctx__entity_head__subsuper = visit_if ctx__entity_head&.subsuper
        ctx__entity_head__subsuper__supertype_constraint = ctx__entity_head__subsuper&.supertype_constraint
        ctx__entity_head__subsuper__supertype_constraint__abstract_entity_declaration = ctx__entity_head__subsuper__supertype_constraint&.abstract_entity_declaration
        ctx__entity_head__subsuper__supertype_constraint__abstract_supertype_declaration = ctx__entity_head__subsuper__supertype_constraint&.abstract_supertype_declaration
        ctx__entity_head__subsuper__supertype_constraint__supertype_rule = ctx__entity_head__subsuper__supertype_constraint&.supertype_rule
        ctx__entity_head__subsuper__subtype_declaration = ctx__entity_head__subsuper&.subtype_declaration
        ctx__entity_body__explicit_attr = ctx__entity_body&.explicit_attr
        ctx__entity_body__derive_clause = ctx__entity_body&.derive_clause
        ctx__entity_body__inverse_clause = ctx__entity_body&.inverse_clause
        ctx__entity_body__unique_clause = ctx__entity_body&.unique_clause
        ctx__entity_body__where_clause = ctx__entity_body&.where_clause

        id = visit_if(ctx__entity_head__entity_id)
        abstract = (ctx__entity_head__subsuper__supertype_constraint__abstract_entity_declaration || ctx__entity_head__subsuper__supertype_constraint__abstract_supertype_declaration) && true
        supertype_expression = visit_if(ctx__entity_head__subsuper__supertype_constraint__abstract_supertype_declaration || ctx__entity_head__subsuper__supertype_constraint__supertype_rule)
        subtype_of = visit_if(ctx__entity_head__subsuper__subtype_declaration, [])
        attributes = [
          *visit_if_map_flatten(ctx__entity_body__explicit_attr),
          *visit_if(ctx__entity_body__derive_clause),
          *visit_if(ctx__entity_body__inverse_clause)
        ]
        unique_rules = visit_if(ctx__entity_body__unique_clause, [])
        where_rules = visit_if(ctx__entity_body__where_clause, [])

        Model::Declarations::Entity.new(
          id: id,
          abstract: abstract,
          supertype_expression: supertype_expression,
          subtype_of: subtype_of,
          attributes: attributes,
          unique_rules: unique_rules,
          where_rules: where_rules
        )
      end

      def visit_entity_head(ctx)
        raise 'Invalid state'
      end

      def visit_entity_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_enumeration_extension(ctx)
        raise 'Invalid state'
      end

      def visit_enumeration_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_enumeration_items(ctx)
        ctx__enumeration_item = ctx.enumeration_item

        visit_if_map(ctx__enumeration_item)
      end

      def visit_enumeration_item(ctx)
        ctx__enumeration_id = ctx.enumeration_id

        id = visit_if(ctx__enumeration_id)

        Model::DataTypes::EnumerationItem.new(
          id: id
        )
      end

      def visit_enumeration_reference(ctx)
        ctx__type_ref = ctx.type_ref
        ctx__enumeration_ref = ctx.enumeration_ref

        if ctx__type_ref
          ref = visit_if(ctx__type_ref)
          attribute = visit_if(ctx__enumeration_ref)

          Model::References::AttributeReference.new(
            ref: ref,
            attribute: attribute
          )
        else
          visit_if(ctx__enumeration_ref)
        end
      end

      def visit_enumeration_type(ctx)
        ctx__EXTENSIBLE = ctx.tEXTENSIBLE
        ctx__enumeration_items = ctx.enumeration_items
        ctx__enumeration_extension = ctx.enumeration_extension
        ctx__enumeration_extension__type_ref = ctx__enumeration_extension&.type_ref
        ctx__enumeration_extension__enumeration_items = ctx__enumeration_extension&.enumeration_items

        extensible = ctx__EXTENSIBLE && true
        based_on = visit_if(ctx__enumeration_extension__type_ref)
        items = visit_if(ctx__enumeration_items || ctx__enumeration_extension__enumeration_items, [])

        Model::DataTypes::Enumeration.new(
          extensible: extensible,
          based_on: based_on,
          items: items
        )
      end

      def visit_escape_stmt(ctx)
        Model::Statements::Escape.new
      end

      def visit_explicit_attr(ctx)
        ctx__attribute_decl = ctx.attribute_decl
        ctx__OPTIONAL = ctx.tOPTIONAL
        ctx__parameter_type = ctx.parameter_type

        attributes = visit_if_map(ctx__attribute_decl)
        optional = ctx__OPTIONAL && true
        type = visit_if(ctx__parameter_type)

        attributes.map do |attribute|
          Model::Declarations::Attribute.new(
            id: attribute.id, # reuse
            kind: Model::Declarations::Attribute::EXPLICIT,
            supertype_attribute: attribute.supertype_attribute, # reuse
            optional: optional,
            type: type
          )
        end
      end

      def visit_expression(ctx)
        ctx__simple_expression = ctx.simple_expression
        ctx__rel_op_extended = ctx.rel_op_extended
        ctx__rhs = ctx.rhs

        if ctx__rhs
          operator = visit_if(ctx__rel_op_extended)
          operand1 = visit_if(ctx__simple_expression)
          operand2 = visit_if(ctx__rhs.values[0])

          Model::Expressions::BinaryExpression.new(
            operator: operator,
            operand1: operand1,
            operand2: operand2
          )
        else
          visit_if(ctx__simple_expression)
        end
      end

      def visit_factor(ctx)
        ctx__simple_factor = ctx.simple_factor
        ctx__rhs = ctx.rhs

        if ctx__rhs
          operator = Model::Expressions::BinaryExpression::EXPONENTIATION
          operand1 = visit(ctx__simple_factor)
          operand2 = visit(ctx__rhs.simple_factor)

          Model::Expressions::BinaryExpression.new(
            operator: operator,
            operand1: operand1,
            operand2: operand2
          )
        else
          visit_if(ctx__simple_factor)
        end
      end

      def visit_formal_parameter(ctx)
        ctx__parameter_id = ctx.parameter_id
        ctx__parameter_type = ctx.parameter_type

        ids = visit_if_map(ctx__parameter_id)
        type = visit_if(ctx__parameter_type)

        ids.map do |id|
          Model::Declarations::Parameter.new(
            id: id,
            type: type
          )
        end
      end

      def visit_function_call(ctx)
        ctx__built_in_function = ctx.built_in_function
        ctx__function_ref = ctx.function_ref
        ctx__actual_parameter_list = ctx.actual_parameter_list

        function = visit_if(ctx__built_in_function || ctx__function_ref)
        parameters = visit_if(ctx__actual_parameter_list, [])

        Model::Expressions::FunctionCall.new(
          function: function,
          parameters: parameters
        )
      end

      def visit_function_decl(ctx)
        ctx__function_head = ctx.function_head
        ctx__algorithm_head = ctx.algorithm_head
        ctx__stmt = ctx.stmt
        ctx__function_head__function_id = ctx__function_head&.function_id
        ctx__function_head__formal_parameter = ctx__function_head&.formal_parameter
        ctx__function_head__parameter_type = ctx__function_head&.parameter_type
        ctx__algorithm_head__declaration = ctx__algorithm_head&.declaration
        ctx__algorithm_head__constant_decl = ctx__algorithm_head&.constant_decl
        ctx__algorithm_head__local_decl = ctx__algorithm_head&.local_decl

        id = visit_if(ctx__function_head__function_id)
        parameters = visit_if_map_flatten(ctx__function_head__formal_parameter)
        return_type = visit_if(ctx__function_head__parameter_type)
        declarations = visit_if_map(ctx__algorithm_head__declaration)
        types = declarations.select{|x| x.is_a? Model::Declarations::Type}
        entities = declarations.select{|x| x.is_a? Model::Declarations::Entity}
        subtype_constraints = declarations.select{|x| x.is_a? Model::Declarations::SubtypeConstraint}
        functions = declarations.select{|x| x.is_a? Model::Declarations::Function}
        procedures = declarations.select{|x| x.is_a? Model::Declarations::Procedure}
        constants = visit_if(ctx__algorithm_head__constant_decl, [])
        variables = visit_if(ctx__algorithm_head__local_decl, [])
        statements = visit_if_map(ctx__stmt)

        Model::Declarations::Function.new(
          id: id,
          parameters: parameters,
          return_type: return_type,
          types: types,
          entities: entities,
          subtype_constraints: subtype_constraints,
          functions: functions,
          procedures: procedures,
          constants: constants,
          variables: variables,
          statements: statements
        )
      end

      def visit_function_head(ctx)
        raise 'Invalid state'
      end

      def visit_function_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_generalized_types(ctx)
        ctx__aggregate_type = ctx.aggregate_type
        ctx__general_aggregation_types = ctx.general_aggregation_types
        ctx__generic_entity_type = ctx.generic_entity_type
        ctx__generic_type = ctx.generic_type

        visit_if(ctx__aggregate_type || ctx__general_aggregation_types || ctx__generic_entity_type || ctx__generic_type)
      end

      def visit_general_aggregation_types(ctx)
        ctx__general_array_type = ctx.general_array_type
        ctx__general_bag_type = ctx.general_bag_type
        ctx__general_list_type = ctx.general_list_type
        ctx__general_set_type = ctx.general_set_type

        visit_if(ctx__general_array_type || ctx__general_bag_type || ctx__general_list_type || ctx__general_set_type)
      end

      def visit_general_array_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__OPTIONAL = ctx.tOPTIONAL
        ctx__UNIQUE = ctx.tUNIQUE
        ctx__parameter_type = ctx.parameter_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        optional = ctx__OPTIONAL && true
        unique = ctx__UNIQUE && true
        base_type = visit_if(ctx__parameter_type)

        Model::DataTypes::Array.new(
          bound1: bound1,
          bound2: bound2,
          optional: optional,
          unique: unique,
          base_type: base_type
        )
      end

      def visit_general_bag_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__parameter_type = ctx.parameter_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        base_type = visit_if(ctx__parameter_type)

        Model::DataTypes::Bag.new(
          bound1: bound1,
          bound2: bound2,
          base_type: base_type
        )
      end

      def visit_general_list_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__UNIQUE = ctx.tUNIQUE
        ctx__parameter_type = ctx.parameter_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        unique = ctx__UNIQUE && true
        base_type = visit_if(ctx__parameter_type)

        Model::DataTypes::List.new(
          bound1: bound1,
          bound2: bound2,
          unique: unique,
          base_type: base_type
        )
      end

      def visit_general_ref(ctx)
        ctx__parameter_ref = ctx.parameter_ref
        ctx__variable_id = ctx.variable_id

        visit_if(ctx__parameter_ref || ctx__variable_id)
      end

      def visit_general_set_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__parameter_type = ctx.parameter_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        base_type = visit_if(ctx__parameter_type)

        Model::DataTypes::Set.new(
          bound1: bound1,
          bound2: bound2,
          base_type: base_type
        )
      end

      def visit_generic_entity_type(ctx)
        ctx__type_label = ctx.type_label

        id = visit_if(ctx__type_label)

        Model::DataTypes::GenericEntity.new(
          id: id
        )
      end

      def visit_generic_type(ctx)
        ctx__type_label = ctx.type_label

        id = visit_if(ctx__type_label)

        Model::DataTypes::Generic.new(
          id: id
        )
      end

      def visit_group_qualifier(ctx)
        ctx__entity_ref = ctx.entity_ref

        entity = visit_if(ctx__entity_ref)

        Model::References::GroupReference.new(
          entity: entity
        )
      end

      def visit_group_reference(ctx)
        raise 'Invalid state'
      end

      def visit_if_stmt(ctx)
        ctx__logical_expression = ctx.logical_expression
        ctx__if_stmt_statements = ctx.if_stmt_statements
        ctx__if_stmt_else_statements = ctx.if_stmt_else_statements

        expression = visit_if(ctx__logical_expression)
        statements = visit_if(ctx__if_stmt_statements, [])
        else_statements = visit_if(ctx__if_stmt_else_statements, [])

        Model::Statements::If.new(
          expression: expression,
          statements: statements,
          else_statements: else_statements
        )
      end

      def visit_if_stmt_statements(ctx)
        ctx__stmt = ctx.stmt

        visit_if_map(ctx__stmt)
      end

      def visit_if_stmt_else_statements(ctx)
        ctx__stmt = ctx.stmt

        visit_if_map(ctx__stmt)
      end

      def visit_increment(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_increment_control(ctx)
        raise 'Invalid state'
      end

      def visit_index(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_index1(ctx)
        ctx__index = ctx.index

        visit_if(ctx__index)
      end

      def visit_index2(ctx)
        ctx__index = ctx.index

        visit_if(ctx__index)
      end

      def visit_index_qualifier(ctx)
        ctx__index1 = ctx.index1
        ctx__index2 = ctx.index2

        index1 = visit_if(ctx__index1)
        index2 = visit_if(ctx__index2)

        Model::References::IndexReference.new(
          index1: index1,
          index2: index2
        )
      end

      def visit_index_reference(ctx)
        raise 'Invalid state'
      end

      def visit_instantiable_type(ctx)
        ctx__concrete_types = ctx.concrete_types
        ctx__entity_ref = ctx.entity_ref

        visit_if(ctx__concrete_types || ctx__entity_ref)
      end

      def visit_integer_type(ctx)
        Model::DataTypes::Integer.new
      end

      def visit_interface_specification(ctx)
        ctx__reference_clause = ctx.reference_clause
        ctx__use_clause = ctx.use_clause

        visit_if(ctx__reference_clause || ctx__use_clause)
      end

      def visit_interval(ctx)
        ctx__interval_low = ctx.interval_low
        ctx__interval_op = ctx.interval_op
        ctx__interval_op2 = ctx.interval_op2.interval_op
        ctx__interval_item = ctx.interval_item
        ctx__interval_high = ctx.interval_high

        low = visit_if(ctx__interval_low)
        operator1 = visit_if(ctx__interval_op)
        item = visit_if(ctx__interval_item)
        operator2 = visit_if(ctx__interval_op2)
        high = visit_if(ctx__interval_high)

        Model::Expressions::Interval.new(
          low: low,
          operator1: operator1,
          item: item,
          operator2: operator2,
          high: high
        )
      end

      def visit_interval_high(ctx)
        ctx__simple_expression = ctx.simple_expression

        visit_if(ctx__simple_expression)
      end

      def visit_interval_item(ctx)
        ctx__simple_expression = ctx.simple_expression

        visit_if(ctx__simple_expression)
      end

      def visit_interval_low(ctx)
        ctx__simple_expression = ctx.simple_expression

        visit_if(ctx__simple_expression)
      end

      def visit_interval_op(ctx)
        ctx__text = ctx.values[0].text
        ctx__LESS_THAN = ctx__text == '<'
        ctx__LESS_THAN_OR_EQUAL = ctx__text == '<='

        if ctx__LESS_THAN
          Model::Expressions::Interval::LESS_THAN
        elsif ctx__LESS_THAN_OR_EQUAL
          Model::Expressions::Interval::LESS_THAN_OR_EQUAL
        else
          raise 'Invalid state'
        end
      end

      def visit_inverse_attr(ctx)
        ctx__attribute_decl = ctx.attribute_decl
        ctx__inverse_attr_type = ctx.inverse_attr_type
        ctx__entity_ref = ctx.entity_ref
        ctx__attribute_ref = ctx.attribute_ref

        attribute = visit_if(ctx__attribute_decl)
        type = visit_if(ctx__inverse_attr_type)
        expression = if ctx__entity_ref
          ref = visit(ctx__entity_ref)
          attribute_ref = visit(ctx__attribute_ref)

          Model::References::AttributeReference.new(
            ref: ref,
            attribute: attribute_ref
          )
        else
          visit(ctx__attribute_ref)
        end

        Model::Declarations::Attribute.new(
          id: attribute.id, # reuse
          kind: Model::Declarations::Attribute::INVERSE,
          supertype_attribute: attribute.supertype_attribute, # reuse
          type: type,
          expression: expression
        )
      end

      def visit_inverse_attr_type(ctx)
        ctx__SET = ctx.tSET
        ctx__BAG = ctx.tBAG
        ctx__bound_spec = ctx.bound_spec
        ctx__entity_ref = ctx.entity_ref
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        if ctx__SET
          bound1 = visit_if(ctx__bound_spec__bound1)
          bound2 = visit_if(ctx__bound_spec__bound2)
          base_type = visit_if(ctx__entity_ref)

          Model::DataTypes::Set.new(
            bound1: bound1,
            bound2: bound2,
            base_type: base_type
          )
        elsif ctx__BAG
          bound1 = visit_if(ctx__bound_spec__bound1)
          bound2 = visit_if(ctx__bound_spec__bound2)
          base_type = visit_if(ctx__entity_ref)

          Model::DataTypes::Bag.new(
            bound1: bound1,
            bound2: bound2,
            base_type: base_type
          )
        else
          visit_if(ctx__entity_ref)
        end
      end

      def visit_inverse_clause(ctx)
        ctx__inverse_attr = ctx.inverse_attr

        visit_if_map(ctx__inverse_attr)
      end

      def visit_list_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__UNIQUE = ctx.tUNIQUE
        ctx__instantiable_type = ctx.instantiable_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        unique = ctx__UNIQUE && true
        base_type = visit_if(ctx__instantiable_type)

        Model::DataTypes::List.new(
          bound1: bound1,
          bound2: bound2,
          unique: unique,
          base_type: base_type
        )
      end

      def visit_literal(ctx)
        ctx__BinaryLiteral = ctx.binary_literal
        ctx__IntegerLiteral = ctx.integerLiteral
        ctx__logical_literal = ctx.logical_literal
        ctx__RealLiteral = ctx.real_literal
        ctx__string_literal = ctx.string_literal

        if ctx__BinaryLiteral
          handle_binary_literal(ctx__BinaryLiteral)
        elsif ctx__IntegerLiteral
          handle_integer_literal(ctx__IntegerLiteral)
        elsif ctx__logical_literal
          visit(ctx__logical_literal)
        elsif ctx__RealLiteral
          handle_real_literal(ctx__RealLiteral)
        elsif ctx__string_literal
          visit(ctx__string_literal)
        else
          raise 'Invalid state'
        end
      end

      def visit_local_decl(ctx)
        ctx__local_variable = ctx.local_variable

        visit_if_map_flatten(ctx__local_variable)
      end

      def visit_local_variable(ctx)
        ctx__variable_id = ctx.variable_id
        ctx__parameter_type = ctx.parameter_type
        ctx__expression = ctx.expression

        ids = visit_if_map(ctx__variable_id)
        type = visit_if(ctx__parameter_type)
        expression = visit_if(ctx__expression)

        ids.map do |id|
          Model::Declarations::Variable.new(
            id: id,
            type: type,
            expression: expression
          )
        end
      end

      def visit_logical_expression(ctx)
        ctx__expression = ctx.expression

        visit_if(ctx__expression)
      end

      def visit_logical_literal(ctx)
        ctx__TRUE = ctx.tTRUE
        ctx__FALSE = ctx.tFALSE
        ctx__UNKNOWN = ctx.tUNKNOWN

        value = if ctx__TRUE
          Model::Literals::Logical::TRUE
        elsif ctx__FALSE
          Model::Literals::Logical::FALSE
        elsif ctx__UNKNOWN
          Model::Literals::Logical::UNKNOWN
        else
          raise 'Invalid state'
        end

        Model::Literals::Logical.new(
          value: value
        )
      end

      def visit_logical_type(ctx)
        Model::DataTypes::Logical.new
      end

      def visit_multiplication_like_op(ctx)
        ctx__text = ctx.values[0].text
        ctx__MULTIPLICATION = ctx__text == '*'
        ctx__REAL_DIVISION = ctx__text == '/'
        ctx__INTEGER_DIVISION = ctx.tDIV
        ctx__MODULO = ctx.tMOD
        ctx__AND = ctx.tAND
        ctx__COMBINE = ctx__text == '||'

        if ctx__MULTIPLICATION
          Model::Expressions::BinaryExpression::MULTIPLICATION
        elsif ctx__REAL_DIVISION
          Model::Expressions::BinaryExpression::REAL_DIVISION
        elsif ctx__INTEGER_DIVISION
          Model::Expressions::BinaryExpression::INTEGER_DIVISION
        elsif ctx__MODULO
          Model::Expressions::BinaryExpression::MODULO
        elsif ctx__AND
          Model::Expressions::BinaryExpression::AND
        elsif ctx__COMBINE
          Model::Expressions::BinaryExpression::COMBINE
        else
          raise 'Invalid state'
        end
      end

      def visit_named_types(ctx)
        ctx__entity_ref = ctx.entity_ref
        ctx__type_ref = ctx.type_ref

        visit_if(ctx__entity_ref || ctx__type_ref)
      end

      def visit_named_type_or_rename(ctx)
        ctx__named_types = ctx.named_types
        ctx__entity_id = ctx.entity_id
        ctx__type_id = ctx.type_id

        ref = visit_if(ctx__named_types)
        id = visit_if(ctx__entity_id || ctx__type_id)

        Model::Declarations::InterfaceItem.new(
          ref: ref,
          id: id
        )
      end

      def visit_null_stmt(ctx)
        Model::Statements::Null.new
      end

      def visit_number_type(ctx)
        Model::DataTypes::Number.new
      end

      def visit_numeric_expression(ctx)
        ctx__simple_expression = ctx.simple_expression

        visit_if(ctx__simple_expression)
      end

      def visit_one_of(ctx)
        ctx__supertype_expression = ctx.supertype_expression

        operands = visit_if_map(ctx__supertype_expression)

        Model::SupertypeExpressions::OneofSupertypeExpression.new(
          operands: operands
        )
      end

      def visit_parameter(ctx)
        ctx__expression = ctx.expression

        visit_if(ctx__expression)
      end

      def visit_parameter_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_parameter_type(ctx)
        ctx__generalized_types = ctx.generalized_types
        ctx__named_types = ctx.named_types
        ctx__simple_types = ctx.simple_types

        visit_if(ctx__generalized_types || ctx__named_types || ctx__simple_types)
      end

      def visit_population(ctx)
        ctx__entity_ref = ctx.entity_ref

        visit_if(ctx__entity_ref)
      end

      def visit_precision_spec(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_primary(ctx)
        ctx__literal = ctx.literal
        ctx__qualifiable_factor = ctx.qualifiable_factor
        ctx__qualifier = ctx.qualifier

        if ctx__literal
          visit(ctx__literal)
        elsif ctx__qualifiable_factor
          handle_qualified_ref(visit(ctx__qualifiable_factor), ctx__qualifier)
        else
          raise 'Invalid state'
        end
      end

      def visit_procedure_call_stmt(ctx)
        ctx__built_in_procedure = ctx.built_in_procedure
        ctx__procedure_ref = ctx.procedure_ref
        ctx__actual_parameter_list = ctx.actual_parameter_list

        procedure = visit_if(ctx__built_in_procedure || ctx__procedure_ref)
        parameters = visit_if(ctx__actual_parameter_list, [])

        Model::Statements::ProcedureCall.new(
          procedure: procedure,
          parameters: parameters
        )
      end

      def visit_procedure_decl(ctx)
        ctx__procedure_head = ctx.procedure_head
        ctx__algorithm_head = ctx.algorithm_head
        ctx__stmt = ctx.stmt
        ctx__procedure_head__procedure_id = ctx__procedure_head&.procedure_id
        ctx__procedure_head__procedure_head_parameter = ctx__procedure_head&.procedure_head_parameter
        ctx__algorithm_head__declaration = ctx__algorithm_head&.declaration
        ctx__algorithm_head__constant_decl = ctx__algorithm_head&.constant_decl
        ctx__algorithm_head__local_decl = ctx__algorithm_head&.local_decl

        id = visit_if(ctx__procedure_head__procedure_id)
        parameters = visit_if_map_flatten(ctx__procedure_head__procedure_head_parameter)
        declarations = visit_if_map(ctx__algorithm_head__declaration)
        types = declarations.select{|x| x.is_a? Model::Declarations::Type}
        entities = declarations.select{|x| x.is_a? Model::Declarations::Entity}
        subtype_constraints = declarations.select{|x| x.is_a? Model::Declarations::SubtypeConstraint}
        functions = declarations.select{|x| x.is_a? Model::Declarations::Function}
        procedures = declarations.select{|x| x.is_a? Model::Declarations::Procedure}
        constants = visit_if(ctx__algorithm_head__constant_decl, [])
        variables = visit_if(ctx__algorithm_head__local_decl, [])
        statements = visit_if_map(ctx__stmt)

        Model::Declarations::Procedure.new(
          id: id,
          parameters: parameters,
          types: types,
          entities: entities,
          subtype_constraints: subtype_constraints,
          functions: functions,
          procedures: procedures,
          constants: constants,
          variables: variables,
          statements: statements
        )
      end

      def visit_procedure_head(ctx)
        raise 'Invalid state'
      end

      def visit_procedure_head_parameter(ctx)
        ctx__formal_parameter = ctx.formal_parameter
        ctx__VAR = ctx.tVAR

        parameters = visit(ctx__formal_parameter)

        if ctx.tVAR
          parameters.map do |parameter|
            Model::Declarations::Parameter.new(
              id: parameter.id,
              var: true,
              type: parameter.type
            )
          end
        else
          parameters
        end
      end

      def visit_procedure_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_qualifiable_factor(ctx)
        ctx__attribute_ref = ctx.attribute_ref
        ctx__constant_factor = ctx.constant_factor
        ctx__function_call = ctx.function_call
        ctx__general_ref = ctx.general_ref
        ctx__population = ctx.population

        visit_if(ctx__attribute_ref || ctx__constant_factor || ctx__function_call || ctx__general_ref || ctx__population)
      end

      def visit_qualified_attribute(ctx)
        ctx__group_qualifier = ctx.group_qualifier
        ctx__attribute_qualifier = ctx.attribute_qualifier

        id = 'SELF'
        group_reference = visit_if(ctx__group_qualifier)
        attribute_reference = visit_if(ctx__attribute_qualifier)

        Model::References::AttributeReference.new(
          ref: Model::References::GroupReference.new(
            ref: Model::References::SimpleReference.new(
              id: id
            ),
            entity: group_reference.entity # reuse
          ),
          attribute: attribute_reference.attribute # reuse
        )
      end

      def visit_qualifier(ctx)
        ctx__attribute_qualifier = ctx.attribute_qualifier
        ctx__group_qualifier = ctx.group_qualifier
        ctx__index_qualifier = ctx.index_qualifier

        visit_if(ctx__attribute_qualifier || ctx__group_qualifier || ctx__index_qualifier)
      end

      def visit_query_expression(ctx)
        ctx__variable_id = ctx.variable_id
        ctx__aggregate_source = ctx.aggregate_source
        ctx__logical_expression = ctx.logical_expression

        id = visit_if(ctx__variable_id)
        aggregate_source = visit_if(ctx__aggregate_source)
        expression = visit_if(ctx__logical_expression)

        Model::Expressions::QueryExpression.new(
          id: id,
          aggregate_source: aggregate_source,
          expression: expression
        )
      end

      def visit_real_type(ctx)
        ctx__precision_spec = ctx.precision_spec

        precision = visit_if(ctx__precision_spec)

        Model::DataTypes::Real.new(
          precision: precision
        )
      end

      def visit_redeclared_attribute(ctx)
        raise 'Invalid state'
      end

      def visit_referenced_attribute(ctx)
        ctx__attribute_ref = ctx.attribute_ref
        ctx__qualified_attribute = ctx.qualified_attribute

        visit_if(ctx__attribute_ref || ctx__qualified_attribute)
      end

      def visit_reference_clause(ctx)
        ctx__schema_ref = ctx.schema_ref
        ctx__resource_or_rename = ctx.resource_or_rename

        schema = visit_if(ctx__schema_ref)
        items = visit_if_map(ctx__resource_or_rename)

        Model::Declarations::Interface.new(
          kind: Model::Declarations::Interface::REFERENCE,
          schema: schema,
          items: items
        )
      end

      def visit_rel_op(ctx)
        ctx__text = ctx.values[0].text
        ctx__LESS_THAN = ctx__text == '<'
        ctx__GREATER_THAN = ctx__text == '>'
        ctx__LESS_THAN_OR_EQUAL = ctx__text == '<='
        ctx__GREATER_THAN_OR_EQUAL = ctx__text == '>='
        ctx__NOT_EQUAL = ctx__text == '<>'
        ctx__EQUAL = ctx__text == '='
        ctx__INSTANCE_NOT_EQUAL = ctx__text == ':<>:'
        ctx__INSTANCE_EQUAL = ctx__text == ':=:'

        if ctx__LESS_THAN
          Model::Expressions::BinaryExpression::LESS_THAN
        elsif ctx__GREATER_THAN
          Model::Expressions::BinaryExpression::GREATER_THAN
        elsif ctx__LESS_THAN_OR_EQUAL
          Model::Expressions::BinaryExpression::LESS_THAN_OR_EQUAL
        elsif ctx__GREATER_THAN_OR_EQUAL
          Model::Expressions::BinaryExpression::GREATER_THAN_OR_EQUAL
        elsif ctx__NOT_EQUAL
          Model::Expressions::BinaryExpression::NOT_EQUAL
        elsif ctx__EQUAL
          Model::Expressions::BinaryExpression::EQUAL
        elsif ctx__INSTANCE_NOT_EQUAL
          Model::Expressions::BinaryExpression::INSTANCE_NOT_EQUAL
        elsif ctx__INSTANCE_EQUAL
          Model::Expressions::BinaryExpression::INSTANCE_EQUAL
        else
          raise 'Invalid state'
        end
      end

      def visit_rel_op_extended(ctx)
        ctx__rel_op = ctx.rel_op
        ctx__IN = ctx.tIN
        ctx__LIKE = ctx.tLIKE

        if ctx__rel_op
          visit(ctx__rel_op)
        elsif ctx__IN
          Model::Expressions::BinaryExpression::IN
        elsif ctx__LIKE
          Model::Expressions::BinaryExpression::LIKE
        else
          raise 'Invalid state'
        end
      end

      def visit_rename_id(ctx)
        ctx__constant_id = ctx.constant_id
        ctx__entity_id = ctx.entity_id
        ctx__function_id = ctx.function_id
        ctx__procedure_id = ctx.procedure_id
        ctx__type_id = ctx.type_id

        visit_if(ctx__constant_id || ctx__entity_id || ctx__function_id || ctx__procedure_id || ctx__type_id)
      end

      def visit_repeat_control(ctx)
        (SimpleCtx === ctx) ? to_ctx({},:repeatControl) : ctx
      end

      def visit_repeat_stmt(ctx)
        ctx__repeat_control = visit ctx.repeat_control
        ctx__stmt = ctx.stmt
        ctx__repeat_control__increment_control = ctx__repeat_control&.increment_control
        ctx__repeat_control__increment_control__variable_id = ctx__repeat_control__increment_control&.variable_id
        ctx__repeat_control__increment_control__bound1 = ctx__repeat_control__increment_control&.bound1
        ctx__repeat_control__increment_control__bound2 = ctx__repeat_control__increment_control&.bound2
        ctx__repeat_control__increment_control__increment = ctx__repeat_control__increment_control&.increment
        ctx__repeat_control__while_control = ctx__repeat_control&.while_control
        ctx__repeat_control__until_control = ctx__repeat_control&.until_control

        id = visit_if(ctx__repeat_control__increment_control__variable_id)
        bound1 = visit_if(ctx__repeat_control__increment_control__bound1)
        bound2 = visit_if(ctx__repeat_control__increment_control__bound2)
        increment = visit_if(ctx__repeat_control__increment_control__increment)
        while_expression = visit_if(ctx__repeat_control__while_control)
        until_expression = visit_if(ctx__repeat_control__until_control)
        statements = visit_if_map(ctx__stmt)

        Model::Statements::Repeat.new(
          id: id,
          bound1: bound1,
          bound2: bound2,
          increment: increment,
          while_expression: while_expression,
          until_expression: until_expression,
          statements: statements
        )
      end

      def visit_repetition(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_resource_or_rename(ctx)
        ctx__resource_ref = ctx.resource_ref
        ctx__rename_id = ctx.rename_id

        ref = visit_if(ctx__resource_ref)
        id = visit_if(ctx__rename_id)

        Model::Declarations::InterfaceItem.new(
          ref: ref,
          id: id
        )
      end

      def visit_resource_ref(ctx)
        ctx__constant_ref = ctx.constant_ref
        ctx__entity_ref = ctx.entity_ref
        ctx__function_ref = ctx.function_ref
        ctx__procedure_ref = ctx.procedure_ref
        ctx__type_ref = ctx.type_ref

        visit_if(ctx__constant_ref || ctx__entity_ref || ctx__function_ref || ctx__procedure_ref || ctx__type_ref)
      end

      def visit_return_stmt(ctx)
        ctx__expression = ctx.expression

        expression = visit_if(ctx__expression)

        Model::Statements::Return.new(
          expression: expression
        )
      end

      def visit_rule_decl(ctx)
        ctx__rule_head = ctx.rule_head
        ctx__algorithm_head = ctx.algorithm_head
        ctx__stmt = ctx.stmt
        ctx__where_clause = ctx.where_clause
        ctx__rule_head__rule_id = ctx__rule_head&.rule_id
        ctx__rule_head__entity_ref = ctx__rule_head&.entity_ref
        ctx__algorithm_head__declaration = ctx__algorithm_head&.declaration
        ctx__algorithm_head__constant_decl = ctx__algorithm_head&.constant_decl
        ctx__algorithm_head__local_decl = ctx__algorithm_head&.local_decl

        id = visit_if(ctx__rule_head__rule_id)
        applies_to = visit_if_map(ctx__rule_head__entity_ref)
        declarations = visit_if_map(ctx__algorithm_head__declaration)
        types = declarations.select{|x| x.is_a? Model::Declarations::Type}
        entities = declarations.select{|x| x.is_a? Model::Declarations::Entity}
        subtype_constraints = declarations.select{|x| x.is_a? Model::Declarations::SubtypeConstraint}
        functions = declarations.select{|x| x.is_a? Model::Declarations::Function}
        procedures = declarations.select{|x| x.is_a? Model::Declarations::Procedure}
        constants = visit_if(ctx__algorithm_head__constant_decl, [])
        variables = visit_if(ctx__algorithm_head__local_decl, [])
        statements = visit_if_map(ctx__stmt)
        where_rules = visit_if(ctx__where_clause, [])

        Model::Declarations::Rule.new(
          id: id,
          applies_to: applies_to,
          types: types,
          entities: entities,
          subtype_constraints: subtype_constraints,
          functions: functions,
          procedures: procedures,
          constants: constants,
          variables: variables,
          statements: statements,
          where_rules: where_rules
        )
      end

      def visit_rule_head(ctx)
        raise 'Invalid state'
      end

      def visit_rule_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_rule_label_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_schema_body(ctx)
        raise 'Invalid state'
      end

      def visit_schema_body_declaration(ctx)
        ctx__declaration = ctx.declaration
        ctx__rule_decl = ctx.rule_decl

        visit_if(ctx__declaration || ctx__rule_decl)
      end

      def visit_schema_decl(ctx)
        ctx__schema_id = ctx.schema_id
        ctx__schema_version_id = ctx.schema_version_id
        ctx__schema_body = ctx.schema_body
        ctx__schema_body__interface_specification = ctx__schema_body&.interface_specification
        ctx__schema_body__constant_decl = ctx__schema_body&.constant_decl
        ctx__schema_body__schema_body_declaration = ctx__schema_body&.schema_body_declaration

        id = visit_if(ctx__schema_id)
        version = visit_if(ctx__schema_version_id)
        interfaces = visit_if_map(ctx__schema_body__interface_specification)
        constants = visit_if(ctx__schema_body__constant_decl, [])
        declarations = visit_if_map(ctx__schema_body__schema_body_declaration)
        types = declarations.select{|x| x.is_a? Model::Declarations::Type}
        entities = declarations.select{|x| x.is_a? Model::Declarations::Entity}
        subtype_constraints = declarations.select{|x| x.is_a? Model::Declarations::SubtypeConstraint}
        functions = declarations.select{|x| x.is_a? Model::Declarations::Function}
        rules = declarations.select{|x| x.is_a? Model::Declarations::Rule}
        procedures = declarations.select{|x| x.is_a? Model::Declarations::Procedure}

        Model::Declarations::Schema.new(
          id: id,
          version: version,
          interfaces: interfaces,
          constants: constants,
          types: types,
          entities: entities,
          subtype_constraints: subtype_constraints,
          functions: functions,
          rules: rules,
          procedures: procedures
        )
      end

      def visit_schema_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_schema_version_id(ctx)
        ctx__string_literal = ctx.string_literal

        value = visit_if(ctx__string_literal)
        value = value.value

        items = if value.start_with?('{') and value.end_with?('}')
          parts = value.sub(/^\{/, '').sub(/\}$/, '').split(' ')
          parts.map do |part|
            if match = part.match(/^(.+)\((\d+)\)$/)
              Model::Declarations::SchemaVersionItem.new(
                name: match[1],
                value: match[2]
              )
            elsif part.match(/^\d+$/)
              Model::Declarations::SchemaVersionItem.new(
                value: part
              )
            else
              Model::Declarations::SchemaVersionItem.new(
                name: part
              )
            end
          end
        end

        Model::Declarations::SchemaVersion.new(
          value: value,
          items: items
        )
      end

      def visit_selector(ctx)
        raise 'Invalid state'
      end

      def visit_select_extension(ctx)
        ctx__named_types = ctx.named_types

        visit_if_map(ctx__named_types)
      end

      def visit_select_list(ctx)
        ctx__named_types = ctx.named_types

        visit_if_map(ctx__named_types)
      end

      def visit_select_type(ctx)
        ctx__EXTENSIBLE = ctx.tEXTENSIBLE
        ctx__GENERIC_ENTITY = ctx.tGENERIC_ENTITY
        ctx__select_list = ctx.select_list
        ctx__select_extension = ctx.select_extension
        ctx__select_extension__type_ref = ctx.select_extension&.type_ref
        ctx__select_extension__select_list = ctx__select_extension&.select_list

        extensible = ctx__EXTENSIBLE && true
        generic_entity = ctx__GENERIC_ENTITY && true
        based_on = visit_if(ctx__select_extension__type_ref)
        items = visit_if(ctx__select_list || ctx__select_extension__select_list, [])

        Model::DataTypes::Select.new(
          extensible: extensible,
          generic_entity: generic_entity,
          based_on: based_on,
          items: items
        )
      end

      def visit_set_type(ctx)
        ctx__bound_spec = ctx.bound_spec
        ctx__instantiable_type = ctx.instantiable_type
        ctx__bound_spec__bound1 = ctx__bound_spec&.bound1
        ctx__bound_spec__bound2 = ctx__bound_spec&.bound2

        bound1 = visit_if(ctx__bound_spec__bound1)
        bound2 = visit_if(ctx__bound_spec__bound2)
        base_type = visit_if(ctx__instantiable_type)

        Model::DataTypes::Set.new(
          bound1: bound1,
          bound2: bound2,
          base_type: base_type
        )
      end

      def visit_simple_expression(ctx)
        ctx__term = [ctx.term] + ctx.rhs.map { |item| item.term }
        ctx__add_like_op = ctx.rhs.map { |item| item.operator.values[0] }

        if ctx__term
          if ctx__term.length >= 2
            if ctx__add_like_op and ctx__add_like_op.length == ctx__term.length - 1
              operands = ctx__term.map(&self.method(:visit))
              operators = ctx__add_like_op.map(&self.method(:visit))

              handle_binary_expression(operands, operators)
            else
              raise 'Invalid state'
            end
          elsif ctx__term.length == 1
            visit(ctx__term[0])
          else
            raise 'Invalid state'
          end
        end
      end

      def visit_simple_factor(ctx)
        ctx__aggregate_initializer = ctx.aggregate_initializer
        ctx__entity_constructor = ctx.entity_constructor
        ctx__enumeration_reference = ctx.enumeration_reference
        ctx__interval = ctx.interval
        ctx__query_expression = ctx.query_expression
        ctx__simple_factor_expression = ctx.simple_factor_expression
        ctx__simple_factor_unary_expression = ctx.simple_factor_unary_expression

        visit_if(ctx__aggregate_initializer || ctx__entity_constructor || ctx__enumeration_reference || ctx__interval || ctx__query_expression || ctx__simple_factor_expression || ctx__simple_factor_unary_expression)
      end

      def visit_simple_factor_expression(ctx)
        ctx__expression = ctx.expression
        ctx__primary = ctx.primary

        visit_if(ctx__expression || ctx__primary)
      end

      def visit_simple_factor_unary_expression(ctx)
        ctx__unary_op = ctx.unary_op
        ctx__simple_factor_expression = ctx.simple_factor_expression

        operator = visit_if(ctx__unary_op)
        operand = visit_if(ctx__simple_factor_expression)

        Model::Expressions::UnaryExpression.new(
          operator: operator,
          operand: operand
        )
      end

      def visit_simple_types(ctx)
        ctx__binary_type = ctx.binary_type
        ctx__boolean_type = ctx.boolean_type
        ctx__integer_type = ctx.integer_type
        ctx__logical_type = ctx.logical_type
        ctx__number_type = ctx.number_type
        ctx__real_type = ctx.real_type
        ctx__string_type = ctx.string_type

        visit_if(ctx__binary_type || ctx__boolean_type || ctx__integer_type || ctx__logical_type || ctx__number_type || ctx__real_type || ctx__string_type)
      end

      def visit_skip_stmt(ctx)
        Model::Statements::Skip.new
      end

      def visit_stmt(ctx)
        ctx__alias_stmt = ctx.alias_stmt
        ctx__assignment_stmt = ctx.assignment_stmt
        ctx__case_stmt = ctx.case_stmt
        ctx__compound_stmt = ctx.compound_stmt
        ctx__escape_stmt = ctx.escape_stmt
        ctx__if_stmt = ctx.if_stmt
        ctx__null_stmt = ctx.null_stmt
        ctx__procedure_call_stmt = ctx.procedure_call_stmt
        ctx__repeat_stmt = ctx.repeat_stmt
        ctx__return_stmt = ctx.return_stmt
        ctx__skip_stmt = ctx.skip_stmt

        visit_if(ctx__alias_stmt || ctx__assignment_stmt || ctx__case_stmt || ctx__compound_stmt || ctx__escape_stmt || ctx__if_stmt || ctx__null_stmt || ctx__procedure_call_stmt || ctx__repeat_stmt || ctx__return_stmt || ctx__skip_stmt)
      end

      def visit_string_literal(ctx)
        ctx__SimpleStringLiteral = ctx.simpleStringLiteral
        ctx__EncodedStringLiteral = ctx.encodedStringLiteral

        if ctx__SimpleStringLiteral
          handle_simple_string_literal(ctx__SimpleStringLiteral)
        elsif ctx__EncodedStringLiteral
          handle_encoded_string_literal(ctx__EncodedStringLiteral)
        else
          raise 'Invalid state'
        end
      end

      def visit_string_type(ctx)
        ctx__width_spec = ctx.width_spec
        ctx__width_spec__width = ctx__width_spec&.width
        ctx__width_spec__FIXED = ctx__width_spec&.tFIXED

        width = visit_if(ctx__width_spec__width)
        fixed = ctx__width_spec__FIXED && true

        Model::DataTypes::String.new(
          width: width,
          fixed: fixed
        )
      end

      def visit_subsuper(ctx)
        (SimpleCtx === ctx) ? to_ctx({},:subsuper) : ctx
      end

      def visit_subtype_constraint(ctx)
        ctx__supertype_expression = ctx.supertype_expression

        visit_if(ctx__supertype_expression)
      end

      def visit_subtype_constraint_body(ctx)
        (SimpleCtx === ctx) ? to_ctx({},:subtypeConstraintBody) : ctx
      end

      def visit_subtype_constraint_decl(ctx)
        ctx__subtype_constraint_head = ctx.subtype_constraint_head
        ctx__subtype_constraint_body = visit ctx.subtype_constraint_body
        ctx__subtype_constraint_head__subtype_constraint_id = ctx__subtype_constraint_head&.subtype_constraint_id
        ctx__subtype_constraint_head__entity_ref = ctx__subtype_constraint_head&.entity_ref
        ctx__subtype_constraint_body__abstract_supertype = ctx__subtype_constraint_body&.abstract_supertype
        ctx__subtype_constraint_body__total_over = ctx__subtype_constraint_body&.total_over
        ctx__subtype_constraint_body__supertype_expression = ctx__subtype_constraint_body&.supertype_expression

        id = visit_if(ctx__subtype_constraint_head__subtype_constraint_id)
        applies_to = visit_if(ctx__subtype_constraint_head__entity_ref)
        abstract = ctx__subtype_constraint_body__abstract_supertype && true
        total_over = visit_if(ctx__subtype_constraint_body__total_over, [])
        supertype_expression = visit_if(ctx__subtype_constraint_body__supertype_expression)

        Model::Declarations::SubtypeConstraint.new(
          id: id,
          applies_to: applies_to,
          abstract: abstract,
          total_over: total_over,
          supertype_expression: supertype_expression
        )
      end

      def visit_subtype_constraint_head(ctx)
        raise 'Invalid state'
      end

      def visit_subtype_constraint_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_subtype_declaration(ctx)
        ctx__entity_ref = ctx.entity_ref

        visit_if_map(ctx__entity_ref)
      end

      def visit_supertype_constraint(ctx)
        raise 'Invalid state'
      end

      def visit_supertype_expression(ctx)
        ctx__supertype_factor = [ctx.supertype_factor]+ctx.rhs.map { |item| item.supertype_factor }
        ctx__ANDOR = ctx.rhs.map { |item| item.operator.values[0] }

        if ctx__supertype_factor
          if ctx__supertype_factor.length >= 2
            if ctx__ANDOR and ctx__ANDOR.length == ctx__supertype_factor.length - 1
              operands = ctx__supertype_factor.map(&self.method(:visit))
              operators = ctx__ANDOR.map{Model::SupertypeExpressions::BinarySupertypeExpression::ANDOR}

              handle_binary_supertype_expression(operands, operators)
            else
              raise 'Invalid state'
            end
          elsif ctx__supertype_factor.length == 1
            visit(ctx__supertype_factor[0])
          else
            raise 'Invalid state'
          end
        end
      end

      def visit_supertype_factor(ctx)
        ctx__supertype_term = [ctx.supertype_term] + ctx.rhs.map { |item| item.supertype_term }
        ctx__AND = ctx.rhs.map { |item| item.operator.values[0] }

        if ctx__supertype_term
          if ctx__supertype_term.length >= 2
            if ctx__AND and ctx__AND.length == ctx__supertype_term.length - 1
              operands = ctx__supertype_term.map(&self.method(:visit))
              operators = ctx__AND.map{Model::SupertypeExpressions::BinarySupertypeExpression::AND}

              handle_binary_supertype_expression(operands, operators)
            else
              raise 'Invalid state'
            end
          elsif ctx__supertype_term.length == 1
            visit(ctx__supertype_term[0])
          else
            raise 'Invalid state'
          end
        end
      end

      def visit_supertype_rule(ctx)
        ctx__subtype_constraint = ctx.subtype_constraint

        visit_if(ctx__subtype_constraint)
      end

      def visit_supertype_term(ctx)
        ctx__entity_ref = ctx.entity_ref
        ctx__one_of = ctx.one_of
        ctx__supertype_expression = ctx.supertype_expression

        visit_if(ctx__entity_ref || ctx__one_of || ctx__supertype_expression)
      end

      def visit_syntax(ctx)
        ctx__schema_decl = ctx.schema_decl

        schemas = visit_if_map(ctx__schema_decl)

        Model::Repository.new(
          schemas: schemas
        )
      end

      def visit_term(ctx)
        ctx__factor = [ctx.factor] + ctx.rhs.map { |item| item.factor }
        ctx__multiplication_like_op = ctx.rhs.map { |item| item.multiplication_like_op }

        if ctx__factor
          if ctx__factor.length >= 2
            if ctx__multiplication_like_op and ctx__multiplication_like_op.length == ctx__factor.length - 1
              operands = ctx__factor.map(&self.method(:visit))
              operators = ctx__multiplication_like_op.map(&self.method(:visit))

              handle_binary_expression(operands, operators)
            else
              raise 'Invalid state'
            end
          elsif ctx__factor.length == 1
            visit(ctx__factor[0])
          else
            raise 'Invalid state'
          end
        end
      end

      def visit_total_over(ctx)
        ctx__entity_ref = ctx.entity_ref

        visit_if_map(ctx__entity_ref)
      end

      def visit_type_decl(ctx)
        ctx__type_id = ctx.type_id
        ctx__underlying_type = ctx.underlying_type
        ctx__where_clause = ctx.where_clause

        id = visit_if(ctx__type_id)
        underlying_type = visit_if(ctx__underlying_type)
        where_rules = visit_if(ctx__where_clause, [])

        Model::Declarations::Type.new(
          id: id,
          underlying_type: underlying_type,
          where_rules: where_rules
        )
      end

      def visit_type_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_type_label(ctx)
        ctx__type_label_id = ctx.type_label_id
        ctx__type_label_ref = ctx.type_label_ref

        visit_if(ctx__type_label_id || ctx__type_label_ref)
      end

      def visit_type_label_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_unary_op(ctx)
        ctx__text = ctx.values[0].text
        ctx__PLUS = ctx__text == '+'
        ctx__MINUS = ctx__text == '-'
        ctx__NOT = ctx.tNOT

        if ctx__PLUS
          Model::Expressions::UnaryExpression::PLUS
        elsif ctx__MINUS
          Model::Expressions::UnaryExpression::MINUS
        elsif ctx__NOT
          Model::Expressions::UnaryExpression::NOT
        else
          raise 'Invalid state'
        end
      end

      def visit_underlying_type(ctx)
        ctx__concrete_types = ctx.concrete_types
        ctx__constructed_types = ctx.constructed_types

        visit_if(ctx__concrete_types || ctx__constructed_types)
      end

      def visit_unique_clause(ctx)
        ctx__unique_rule = ctx.unique_rule

        visit_if_map(ctx__unique_rule)
      end

      def visit_unique_rule(ctx)
        ctx__rule_label_id = ctx.rule_label_id
        ctx__referenced_attribute = ctx.referenced_attribute

        id = visit_if(ctx__rule_label_id)
        attributes = visit_if_map(ctx__referenced_attribute)

        Model::Declarations::UniqueRule.new(
          id: id,
          attributes: attributes
        )
      end

      def visit_until_control(ctx)
        ctx__logical_expression = ctx.logical_expression

        visit_if(ctx__logical_expression)
      end

      def visit_use_clause(ctx)
        ctx__schema_ref = ctx.schema_ref
        ctx__named_type_or_rename = ctx.named_type_or_rename

        schema = visit_if(ctx__schema_ref)
        items = visit_if_map(ctx__named_type_or_rename)

        Model::Declarations::Interface.new(
          kind: Model::Declarations::Interface::USE,
          schema: schema,
          items: items
        )
      end

      def visit_variable_id(ctx)
        ctx__SimpleId = ctx.simpleId

        handle_simple_id(ctx__SimpleId)
      end

      def visit_where_clause(ctx)
        ctx__domain_rule = ctx.domain_rule

        visit_if_map(ctx__domain_rule)
      end

      def visit_while_control(ctx)
        ctx__logical_expression = ctx.logical_expression

        visit_if(ctx__logical_expression)
      end

      def visit_width(ctx)
        ctx__numeric_expression = ctx.numeric_expression

        visit_if(ctx__numeric_expression)
      end

      def visit_width_spec(ctx)
        raise 'Invalid state'
      end

      def handle_binary_expression(operands, operators)
        if operands.length != operators.length + 1
          raise 'Invalid state'
        end

        expression = Model::Expressions::BinaryExpression.new(
          operator: operators[0],
          operand1: operands[0],
          operand2: operands[1]
        )
        operators[1..(operators.length - 1)].each_with_index do |operator, i|
          expression = Model::Expressions::BinaryExpression.new(
            operator: operator,
            operand1: expression,
            operand2: operands[i + 2]
          )
        end
        expression
      end

      def handle_binary_supertype_expression(operands, operators)
        if operands.length != operators.length + 1
          raise 'Invalid state'
        end

        expression = Model::SupertypeExpressions::BinarySupertypeExpression.new(
          operator: operators[0],
          operand1: operands[0],
          operand2: operands[1]
        )
        operators[1..(operators.length - 1)].each_with_index do |operator, i|
          expression = Model::SupertypeExpressions::BinarySupertypeExpression.new(
            operator: operator,
            operand1: expression,
            operand2: operands[i + 2]
          )
        end
        expression
      end

      def handle_qualified_ref(ref, qualifiers)
        qualifiers.reduce(ref) do |ref, ctx|
          ctx__attribute_qualifier = ctx.attribute_qualifier
          ctx__group_qualifier = ctx.group_qualifier
          ctx__index_qualifier = ctx.index_qualifier

          if ctx__attribute_qualifier
            attribute_reference = visit_if(ctx__attribute_qualifier)

            Model::References::AttributeReference.new(
              ref: ref,
              attribute: attribute_reference.attribute
            )
          elsif ctx__group_qualifier
            group_reference = visit_if(ctx__group_qualifier)

            Model::References::GroupReference.new(
              ref: ref,
              entity: group_reference.entity
            )
          elsif ctx__index_qualifier
            index_reference = visit_if(ctx__index_qualifier)

            Model::References::IndexReference.new(
              ref: ref,
              index1: index_reference.index1,
              index2: index_reference.index2
            )
          else
            raise 'Invalid state'
          end
        end
      end

      def handle_binary_literal(ctx)
        ctx__text = ctx.text

        value = ctx__text[1..(ctx__text.length - 1)]

        Model::Literals::Binary.new(
          value: value
        )
      end

      def handle_integer_literal(ctx)
        ctx__text = ctx.text

        value = ctx__text

        Model::Literals::Integer.new(
          value: value
        )
      end

      def handle_real_literal(ctx)
        ctx__text = ctx.text

        value = ctx__text

        Model::Literals::Real.new(
          value: value
        )
      end

      def handle_simple_id(ctx)
        ctx__text = ctx.text

        ctx__text
      end

      def handle_simple_string_literal(ctx)
        ctx__text = ctx.text

        value = ctx__text[1..(ctx__text.length - 2)].force_encoding('UTF-8')

        Model::Literals::String.new(
          value: value
        )
      end

      def handle_encoded_string_literal(ctx)
        ctx__text = ctx.text

        value = ctx__text[1..(ctx__text.length - 2)].force_encoding('UTF-8')

        Model::Literals::String.new(
          value: value,
          encoded: true
        )
      end
    end
  end
end
--- END FILE: lib/expressir/express/visitor.rb ---
--- START FILE: lib/expressir/model.rb ---
require "expressir/model/model_element"

require "expressir/model/cache"
require "expressir/model/data_type"
require "expressir/model/declaration"
require "expressir/model/expression"
require "expressir/model/identifier"
require "expressir/model/literal"
require "expressir/model/reference"
require "expressir/model/repository"
require "expressir/model/statement"
require "expressir/model/supertype_expression"
require "expressir/model/data_types/aggregate"
require "expressir/model/data_types/array"
require "expressir/model/data_types/bag"
require "expressir/model/data_types/binary"
require "expressir/model/data_types/boolean"
require "expressir/model/data_types/enumeration"
require "expressir/model/data_types/enumeration_item"
require "expressir/model/data_types/generic_entity"
require "expressir/model/data_types/generic"
require "expressir/model/data_types/integer"
require "expressir/model/data_types/list"
require "expressir/model/data_types/logical"
require "expressir/model/data_types/number"
require "expressir/model/data_types/real"
require "expressir/model/data_types/set"
require "expressir/model/data_types/select"
require "expressir/model/data_types/string"
require "expressir/model/declarations/attribute"
require "expressir/model/declarations/constant"
require "expressir/model/declarations/entity"
require "expressir/model/declarations/function"
require "expressir/model/declarations/interface"
require "expressir/model/declarations/interface_item"
require "expressir/model/declarations/interfaced_item"
require "expressir/model/declarations/parameter"
require "expressir/model/declarations/procedure"
require "expressir/model/declarations/remark_item"
require "expressir/model/declarations/rule"
require "expressir/model/declarations/schema"
require "expressir/model/declarations/schema_version"
require "expressir/model/declarations/schema_version_item"
require "expressir/model/declarations/subtype_constraint"
require "expressir/model/declarations/type"
require "expressir/model/declarations/unique_rule"
require "expressir/model/declarations/variable"
require "expressir/model/declarations/where_rule"
require "expressir/model/expressions/aggregate_initializer"
require "expressir/model/expressions/aggregate_initializer_item"
require "expressir/model/expressions/binary_expression"
require "expressir/model/expressions/entity_constructor"
require "expressir/model/expressions/function_call"
require "expressir/model/expressions/interval"
require "expressir/model/expressions/query_expression"
require "expressir/model/expressions/unary_expression"
require "expressir/model/literals/binary"
require "expressir/model/literals/integer"
require "expressir/model/literals/logical"
require "expressir/model/literals/real"
require "expressir/model/literals/string"
require "expressir/model/references/attribute_reference"
require "expressir/model/references/group_reference"
require "expressir/model/references/index_reference"
require "expressir/model/references/simple_reference"
require "expressir/model/statements/alias"
require "expressir/model/statements/assignment"
require "expressir/model/statements/case"
require "expressir/model/statements/case_action"
require "expressir/model/statements/compound"
require "expressir/model/statements/escape"
require "expressir/model/statements/if"
require "expressir/model/statements/null"
require "expressir/model/statements/procedure_call"
require "expressir/model/statements/repeat"
require "expressir/model/statements/return"
require "expressir/model/statements/skip"
require "expressir/model/supertype_expressions/binary_supertype_expression"
require "expressir/model/supertype_expressions/oneof_supertype_expression"
--- END FILE: lib/expressir/model.rb ---
--- START FILE: lib/expressir/model/cache.rb ---
module Expressir
  module Model
    # Cache content object with Expressir version
    class Cache < ModelElement
      model_attr_accessor :version, 'String'
      model_attr_accessor :content, 'ModelElement'

      # @param [Hash] options
      # @option options [String] :version
      # @option options [ModelElement] :content
      def initialize(options = {})
        @version = options[:version]
        @content = options[:content]
      end
    end
  end
end
--- END FILE: lib/expressir/model/cache.rb ---
--- START FILE: lib/expressir/model/data_type.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 8 Data types
    # @abstract
    class DataType < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/data_type.rb ---
--- START FILE: lib/expressir/model/data_types/aggregate.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 9.5.3.1 Aggregate data type
      class Aggregate < DataType
        include Identifier

        model_attr_accessor :base_type, 'Type'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Type] :base_type
        def initialize(options = {})
          initialize_identifier(options)

          @base_type = options[:base_type]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/aggregate.rb ---
--- START FILE: lib/expressir/model/data_types/array.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.2.1 Array data type
      class Array < DataType
        model_attr_accessor :bound1, 'Expression'
        model_attr_accessor :bound2, 'Expression'
        model_attr_accessor :optional, '::Boolean'
        model_attr_accessor :unique, '::Boolean'
        model_attr_accessor :base_type, 'DataType'

        # @param [Hash] options
        # @option options [Expression] :bound1
        # @option options [Expression] :bound2
        # @option options [::Boolean] :optional
        # @option options [::Boolean] :unique
        # @option options [DataType] :base_type
        def initialize(options = {})
          @bound1 = options[:bound1]
          @bound2 = options[:bound2]
          @optional = options[:optional]
          @unique = options[:unique]
          @base_type = options[:base_type]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/array.rb ---
--- START FILE: lib/expressir/model/data_types/bag.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.2.3 Bag data type
      class Bag < DataType
        model_attr_accessor :bound1, 'Expression'
        model_attr_accessor :bound2, 'Expression'
        model_attr_accessor :base_type, 'DataType'

        # @param [Hash] options
        # @option options [Expression] :bound1
        # @option options [Expression] :bound2
        # @option options [DataType] :base_type
        def initialize(options = {})
          @bound1 = options[:bound1]
          @bound2 = options[:bound2]
          @base_type = options[:base_type]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/bag.rb ---
--- START FILE: lib/expressir/model/data_types/binary.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.7 Binary data type
      class Binary < DataType
        model_attr_accessor :width, 'Expression'
        model_attr_accessor :fixed, '::Boolean'

        # @param [Hash] options
        # @option options [Expression] :width
        # @option options [::Boolean] :fixed
        def initialize(options = {})
          @width = options[:width]
          @fixed = options[:fixed]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/binary.rb ---
--- START FILE: lib/expressir/model/data_types/boolean.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.5 Boolean data type
      class Boolean < DataType
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/boolean.rb ---
--- START FILE: lib/expressir/model/data_types/enumeration.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.4.1 Enumeration data type
      class Enumeration < DataType
        model_attr_accessor :extensible, '::Boolean'
        model_attr_accessor :based_on, 'Reference'
        model_attr_accessor :items, '::Array<EnumerationItem>'

        # @param [Hash] options
        # @option options [::Boolean] :extensible
        # @option options [Reference] :based_on
        # @option options [::Array<EnumerationItem>] :items
        def initialize(options = {})
          @extensible = options[:extensible]
          @based_on = options[:based_on]
          @items = options[:items] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/enumeration.rb ---
--- START FILE: lib/expressir/model/data_types/enumeration_item.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.4.1 Enumeration data type
      class EnumerationItem < ModelElement
        include Identifier

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        def initialize(options = {})
          initialize_identifier(options)

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/enumeration_item.rb ---
--- START FILE: lib/expressir/model/data_types/generic.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 9.5.3.2 Generic data type
      class Generic < DataType
        include Identifier

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        def initialize(options = {})
          initialize_identifier(options)

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/generic.rb ---
--- START FILE: lib/expressir/model/data_types/generic_entity.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 9.5.3.3 Generic entity data type
      class GenericEntity < DataType
        include Identifier

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        def initialize(options = {})
          initialize_identifier(options)

          super
        end
      end

      # @return [Array<Declaration>]
      def children
        [
          *remark_items
        ]
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/generic_entity.rb ---
--- START FILE: lib/expressir/model/data_types/integer.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.3 Integer data type
      class Integer < DataType
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/integer.rb ---
--- START FILE: lib/expressir/model/data_types/list.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.2.2 List data type
      class List < DataType
        model_attr_accessor :bound1, 'Expression'
        model_attr_accessor :bound2, 'Expression'
        model_attr_accessor :unique, '::Boolean'
        model_attr_accessor :base_type, 'DataType'

        # @param [Hash] options
        # @option options [Expression] :bound1
        # @option options [Expression] :bound2
        # @option options [::Boolean] :unique
        # @option options [DataType] :base_type
        def initialize(options = {})
          @bound1 = options[:bound1]
          @bound2 = options[:bound2]
          @unique = options[:unique]
          @base_type = options[:base_type]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/list.rb ---
--- START FILE: lib/expressir/model/data_types/logical.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.4 Logical data type
      class Logical < DataType
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/logical.rb ---
--- START FILE: lib/expressir/model/data_types/number.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.1 Number data type
      class Number < DataType
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/number.rb ---
--- START FILE: lib/expressir/model/data_types/real.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.2 Real data type
      class Real < DataType
        model_attr_accessor :precision, 'Expression'

        # @param [Hash] options
        # @option options [Expression] :precision
        def initialize(options = {})
          @precision = options[:precision]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/real.rb ---
--- START FILE: lib/expressir/model/data_types/select.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.4.2 Select data type
      class Select < DataType
        model_attr_accessor :extensible, '::Boolean'
        model_attr_accessor :generic_entity, '::Boolean'
        model_attr_accessor :based_on, 'Reference'
        model_attr_accessor :items, '::Array<Reference>'

        # @param [Hash] options
        # @option options [::Boolean] :extensible
        # @option options [::Boolean] :generic_entity
        # @option options [Reference] :based_on
        # @option options [::Array<Reference>] :items
        def initialize(options = {})
          @extensible = options[:extensible]
          @generic_entity = options[:generic_entity]
          @based_on = options[:based_on]
          @items = options[:items] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/select.rb ---
--- START FILE: lib/expressir/model/data_types/set.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.2.4 Set data type
      class Set < DataType
        model_attr_accessor :bound1, 'Expression'
        model_attr_accessor :bound2, 'Expression'
        model_attr_accessor :base_type, 'DataType'

        # @param [Hash] options
        # @option options [Expression] :bound1
        # @option options [Expression] :bound2
        # @option options [DataType] :base_type
        def initialize(options = {})
          @bound1 = options[:bound1]
          @bound2 = options[:bound2]
          @base_type = options[:base_type]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/set.rb ---
--- START FILE: lib/expressir/model/data_types/string.rb ---
module Expressir
  module Model
    module DataTypes
      # Specified in ISO 10303-11:2004
      # - section 8.1.6 String data type
      class String < DataType
        model_attr_accessor :width, 'Expression'
        model_attr_accessor :fixed, '::Boolean'

        # @param [Hash] options
        # @option options [Expression] :width
        # @option options [::Boolean] :fixed
        def initialize(options = {})
          @width = options[:width]
          @fixed = options[:fixed]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/data_types/string.rb ---
--- START FILE: lib/expressir/model/declaration.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 9 Declarations
    # @abstract
    class Declaration < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/declaration.rb ---
--- START FILE: lib/expressir/model/declarations/attribute.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.2.1 Attributes
      class Attribute < Declaration
        include Identifier

        EXPLICIT = :EXPLICIT
        DERIVED = :DERIVED
        INVERSE = :INVERSE

        model_attr_accessor :kind, ':EXPLICIT, :DERIVED, :INVERSE'
        model_attr_accessor :supertype_attribute, 'Reference'
        model_attr_accessor :optional, 'Boolean'
        model_attr_accessor :type, 'DataType'
        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [:EXPLICIT, :DERIVED, :INVERSE] :kind
        # @option options [Reference] :supertype_attribute
        # @option options [Boolean] :optional
        # @option options [DataType] :type
        # @option options [Expression] :operand
        def initialize(options = {})
          initialize_identifier(options)

          @kind = options[:kind]
          @supertype_attribute = options[:supertype_attribute]
          @optional = options[:optional]
          @type = options[:type]
          @expression = options[:expression]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/attribute.rb ---
--- START FILE: lib/expressir/model/declarations/constant.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.4 Constant
      class Constant < Declaration
        include Identifier

        model_attr_accessor :type, 'DataType'
        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [DataType] :type
        # @option options [Expression] :expression
        def initialize(options = {})
          initialize_identifier(options)

          @type = options[:type]
          @expression = options[:expression]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/constant.rb ---
--- START FILE: lib/expressir/model/declarations/entity.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.2 Entity declaration
      class Entity < Declaration
        include Identifier

        model_attr_accessor :abstract, 'Boolean'
        model_attr_accessor :supertype_expression, 'SupertypeExpression'
        model_attr_accessor :subtype_of, 'Array<Reference>'
        model_attr_accessor :attributes, 'Array<Attribute>'
        model_attr_accessor :unique_rules, 'Array<UniqueRule>'
        model_attr_accessor :where_rules, 'Array<WhereRule>'
        model_attr_accessor :informal_propositions, 'Array<RemarkItem>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Boolean] :abstract
        # @option options [SupertypeExpression] :supertype_expression
        # @option options [Array<Reference>] :subtype_of
        # @option options [Array<Attribute>] :attributes
        # @option options [Array<UniqueRule>] :unique_rules
        # @option options [Array<WhereRule>] :where_rules
        # @option options [Array<RemarkItem>] :informal_propositions
        def initialize(options = {})
          initialize_identifier(options)

          @abstract = options[:abstract]
          @supertype_expression = options[:supertype_expression]
          @subtype_of = options[:subtype_of] || []
          @attributes = options[:attributes] || []
          @unique_rules = options[:unique_rules] || []
          @where_rules = options[:where_rules] || []
          @informal_propositions = options[:informal_propositions] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *attributes,
            *unique_rules,
            *where_rules,
            *informal_propositions,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/entity.rb ---
--- START FILE: lib/expressir/model/declarations/function.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.5.1 Function
      class Function < Declaration
        include Identifier

        model_attr_accessor :parameters, 'Array<Parameter>'
        model_attr_accessor :return_type, 'DataType'
        model_attr_accessor :types, 'Array<Type>'
        model_attr_accessor :entities, 'Array<Entity>'
        model_attr_accessor :subtype_constraints, 'Array<SubtypeConstraint>'
        model_attr_accessor :functions, 'Array<Function>'
        model_attr_accessor :procedures, 'Array<Procedure>'
        model_attr_accessor :constants, 'Array<Constant>'
        model_attr_accessor :variables, 'Array<Variable>'
        model_attr_accessor :statements, 'Array<Statement>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Array<Parameter>] :parameters
        # @option options [DataType] :return_type
        # @option options [Array<Type>] :types
        # @option options [Array<Entity>] :entities
        # @option options [Array<SubtypeConstraint>] :subtype_constraints
        # @option options [Array<Function>] :functions
        # @option options [Array<Procedure>] :procedures
        # @option options [Array<Constant>] :constants
        # @option options [Array<Variable>] :variables
        # @option options [Array<Statement>] :statements
        def initialize(options = {})
          initialize_identifier(options)

          @parameters = options[:parameters] || []
          @return_type = options[:return_type]
          @types = options[:types] || []
          @entities = options[:entities] || []
          @subtype_constraints = options[:subtype_constraints] || []
          @functions = options[:functions] || []
          @procedures = options[:procedures] || []
          @constants = options[:constants] || []
          @variables = options[:variables] || []
          @statements = options[:statements] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *parameters,
            *types,
            *types.flat_map{|x| x.enumeration_items},
            *entities,
            *subtype_constraints,
            *functions,
            *procedures,
            *constants,
            *variables,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/function.rb ---
--- START FILE: lib/expressir/model/declarations/interface.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 11 Interface specification
      class Interface < Declaration
        USE = :USE
        REFERENCE = :REFERENCE

        model_attr_accessor :kind, ':USE, :REFERENCE'
        model_attr_accessor :schema, 'Reference'
        model_attr_accessor :items, 'Array<InterfaceItem>'

        # @param [Hash] options
        # @option options [:USE, :REFERENCE] :kind
        # @option options [Reference] :schema
        # @option options [Array<InterfaceItem>] :items
        def initialize(options = {})
          @kind = options[:kind]
          @schema = options[:schema]
          @items = options[:items] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/interface.rb ---
--- START FILE: lib/expressir/model/declarations/interface_item.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 11 Interface specification
      class InterfaceItem < ModelElement
        model_attr_accessor :ref, 'Reference'
        model_attr_accessor :id, 'String'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Reference] :ref
        # @option options [String] :id
        def initialize(options = {})
          @ref = options[:ref]
          @id = options[:id]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/interface_item.rb ---
--- START FILE: lib/expressir/model/declarations/interfaced_item.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 11 Interface specification
      class InterfacedItem < ModelElement
        model_attr_accessor :id, 'String'
        model_attr_accessor :remarks, 'Array<String>'
        model_attr_accessor :remark_items, 'Array<RemarkItem>'

        model_attr_accessor :base_item, 'ModelElement'

        # @param [Hash] options
        # @option options [String] :id
        # @option options [Array<String>] :remarks
        # @option options [Array<RemarkItem>] :remark_items
        # @option options [ModelElement] :base_item
        def initialize(options = {})
          @id = options[:id]
          @remarks = options[:remarks] || []
          @remark_items = options[:remark_items] || []

          @base_item = options[:base_item]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/interfaced_item.rb ---
--- START FILE: lib/expressir/model/declarations/parameter.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.5.3 Parameters
      class Parameter < Declaration
        include Identifier

        model_attr_accessor :var, 'Boolean'
        model_attr_accessor :type, 'DataType'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Boolean] :var
        # @option options [DataType] :type
        def initialize(options = {})
          initialize_identifier(options)

          @var = options[:var]
          @type = options[:type]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/parameter.rb ---
--- START FILE: lib/expressir/model/declarations/procedure.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.5.2 Procedure
      class Procedure < Declaration
        include Identifier

        model_attr_accessor :parameters, 'Array<Parameter>'
        model_attr_accessor :types, 'Array<Type>'
        model_attr_accessor :entities, 'Array<Entity>'
        model_attr_accessor :subtype_constraints, 'Array<SubtypeConstraint>'
        model_attr_accessor :functions, 'Array<Function>'
        model_attr_accessor :procedures, 'Array<Procedure>'
        model_attr_accessor :constants, 'Array<Constant>'
        model_attr_accessor :variables, 'Array<Variable>'
        model_attr_accessor :statements, 'Array<Statement>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Array<Parameter>] :parameters
        # @option options [Array<Type>] :types
        # @option options [Array<Entity>] :entities
        # @option options [Array<SubtypeConstraint>] :subtype_constraints
        # @option options [Array<Function>] :functions
        # @option options [Array<Procedure>] :procedures
        # @option options [Array<Constant>] :constants
        # @option options [Array<Variable>] :variables
        # @option options [Array<Statement>] :statements
        def initialize(options = {})
          initialize_identifier(options)

          @parameters = options[:parameters] || []
          @types = options[:types] || []
          @entities = options[:entities] || []
          @subtype_constraints = options[:subtype_constraints] || []
          @functions = options[:functions] || []
          @procedures = options[:procedures] || []
          @constants = options[:constants] || []
          @variables = options[:variables] || []
          @statements = options[:statements] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *parameters,
            *types,
            *types.flat_map{|x| x.enumeration_items},
            *entities,
            *subtype_constraints,
            *functions,
            *procedures,
            *constants,
            *variables,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/procedure.rb ---
--- START FILE: lib/expressir/model/declarations/remark_item.rb ---
module Expressir
  module Model
    module Declarations
      # Implicit item with remarks
      class RemarkItem < Declaration
        model_attr_accessor :id, 'String'
        model_attr_accessor :remarks, 'Array<String>'

        # @param [Hash] options
        # @option options [String] :id
        # @option options [Array<String>] :remarks
        def initialize(options = {})
          @id = options[:id]
          @remarks = options[:remarks] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/remark_item.rb ---
--- START FILE: lib/expressir/model/declarations/rule.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.6 Rule
      class Rule < Declaration
        include Identifier

        model_attr_accessor :applies_to, 'Array<Reference>'
        model_attr_accessor :types, 'Array<Type>'
        model_attr_accessor :entities, 'Array<Entity>'
        model_attr_accessor :subtype_constraints, 'Array<SubtypeConstraint>'
        model_attr_accessor :functions, 'Array<Function>'
        model_attr_accessor :procedures, 'Array<Procedure>'
        model_attr_accessor :constants, 'Array<Constant>'
        model_attr_accessor :variables, 'Array<Variable>'
        model_attr_accessor :statements, 'Array<Statement>'
        model_attr_accessor :where_rules, 'Array<WhereRule>'
        model_attr_accessor :informal_propositions, 'Array<RemarkItem>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Array<Reference>] :applies_to
        # @option options [Array<Type>] :types
        # @option options [Array<Entity>] :entities
        # @option options [Array<SubtypeConstraint>] :subtype_constraints
        # @option options [Array<Function>] :functions
        # @option options [Array<Procedure>] :procedures
        # @option options [Array<Constant>] :constants
        # @option options [Array<Variable>] :variables
        # @option options [Array<Statement>] :statements
        # @option options [Array<WhereRule>] :where_rules
        # @option options [Array<RemarkItem>] :informal_propositions
        def initialize(options = {})
          initialize_identifier(options)

          @applies_to = options[:applies_to] || []
          @types = options[:types] || []
          @entities = options[:entities] || []
          @subtype_constraints = options[:subtype_constraints] || []
          @functions = options[:functions] || []
          @procedures = options[:procedures] || []
          @constants = options[:constants] || []
          @variables = options[:variables] || []
          @statements = options[:statements] || []
          @where_rules = options[:where_rules] || []
          @informal_propositions = options[:informal_propositions] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *types,
            *types.flat_map{|x| x.enumeration_items},
            *entities,
            *subtype_constraints,
            *functions,
            *procedures,
            *constants,
            *variables,
            *where_rules,
            *informal_propositions,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/rule.rb ---
--- START FILE: lib/expressir/model/declarations/schema.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.3 Schema
      class Schema < Declaration
        model_attr_accessor :file, 'String'

        include Identifier

        model_attr_accessor :version, 'SchemaVersion'
        model_attr_accessor :interfaces, 'Array<Interface>'
        model_attr_accessor :constants, 'Array<Constant>'
        model_attr_accessor :types, 'Array<Type>'
        model_attr_accessor :entities, 'Array<Entity>'
        model_attr_accessor :subtype_constraints, 'Array<SubtypeConstraint>'
        model_attr_accessor :functions, 'Array<Function>'
        model_attr_accessor :rules, 'Array<Rule>'
        model_attr_accessor :procedures, 'Array<Procedure>'

        # @param [Hash] options
        # @option options [String] :file
        # @option (see Identifier#initialize_identifier)
        # @option options [SchemaVersion] :version
        # @option options [Array<Interface>] :interfaces
        # @option options [Array<Constant>] :constants
        # @option options [Array<Type>] :types
        # @option options [Array<Entity>] :entities
        # @option options [Array<SubtypeConstraint>] :subtype_constraints
        # @option options [Array<Function>] :functions
        # @option options [Array<Rule>] :rules
        # @option options [Array<Procedure>] :procedures
        def initialize(options = {})
          @file = options[:file]

          initialize_identifier(options)

          @version = options[:version]
          @interfaces = options[:interfaces] || []
          @constants = options[:constants] || []
          @types = options[:types] || []
          @entities = options[:entities] || []
          @subtype_constraints = options[:subtype_constraints] || []
          @functions = options[:functions] || []
          @rules = options[:rules] || []
          @procedures = options[:procedures] || []

          super
        end

        # @return [Array<Declaration>]
        def safe_children
          [
            *constants,
            *types,
            *types.flat_map{|x| x.enumeration_items},
            *entities,
            *subtype_constraints,
            *functions,
            *rules,
            *procedures,
            *remark_items
          ]
        end

        # @return [Array<Declaration>]
        def children
          [
            *interfaced_items,
            *safe_children
          ]
        end

        private

        # @param [String] id
        # @param [ModelElement] base_item
        # @return [InterfacedItem]
        def create_interfaced_item(id, base_item)
          interfaced_item = InterfacedItem.new(
            id: id
          )
          interfaced_item.base_item = base_item # skip overriding parent
          interfaced_item.parent = self
          interfaced_item
        end

        # @return [Array<InterfacedItem>]
        def interfaced_items
          return [] unless parent

          interfaces.flat_map do |interface|
            schema = parent.children_by_id[interface.schema.id.safe_downcase]
            if schema
              schema_safe_children = schema.safe_children
              schema_safe_children_by_id = schema_safe_children.select{|x| x.id}.map{|x| [x.id.safe_downcase, x]}.to_h
              if interface.items.length > 0
                interface.items.map do |interface_item|
                  base_item = schema_safe_children_by_id[interface_item.ref.id.safe_downcase]
                  if base_item
                    id = interface_item.id || base_item.id
                    create_interfaced_item(id, base_item)
                  end
                end
              else
                schema_safe_children.map do |base_item|
                  id = base_item.id
                  create_interfaced_item(id, base_item)
                end
              end
            end
          end.select{|x| x}
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/schema.rb ---
--- START FILE: lib/expressir/model/declarations/schema_version.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.3 Schema
      class SchemaVersion < ModelElement
        model_attr_accessor :value, 'String'
        model_attr_accessor :items, 'Array<SchemaVersionItem>'

        # @param [Hash] options
        # @option options [String] :value
        # @option options [Array<SchemaVersionItem>] :items
        def initialize(options = {})
          @value = options[:value]
          @items = options[:items] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/schema_version.rb ---
--- START FILE: lib/expressir/model/declarations/schema_version_item.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.3 Schema
      class SchemaVersionItem < ModelElement
        model_attr_accessor :name, 'String'
        model_attr_accessor :value, 'String'

        # @param [Hash] options
        # @option options [String] :name
        # @option options [String] :value
        def initialize(options = {})
          @name = options[:name]
          @value = options[:value]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/schema_version_item.rb ---
--- START FILE: lib/expressir/model/declarations/subtype_constraint.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.7 Subtype constraints
      class SubtypeConstraint < Declaration
        include Identifier

        model_attr_accessor :applies_to, 'Reference'
        model_attr_accessor :abstract, 'Boolean'
        model_attr_accessor :total_over, 'Array<Reference>'
        model_attr_accessor :supertype_expression, 'SupertypeExpression'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Reference] :applies_to
        # @option options [Boolean] :abstract
        # @option options [Array<Reference>] :total_over
        # @option options [SupertypeExpression] :supertype_expression
        def initialize(options = {})
          initialize_identifier(options)

          @applies_to = options[:applies_to]
          @abstract = options[:abstract]
          @total_over = options[:total_over] || []
          @supertype_expression = options[:supertype_expression]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/subtype_constraint.rb ---
--- START FILE: lib/expressir/model/declarations/type.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.1 Type declaration
      class Type < Declaration
        include Identifier

        model_attr_accessor :underlying_type, 'DataType'
        model_attr_accessor :where_rules, 'Array<WhereRule>'
        model_attr_accessor :informal_propositions, 'Array<RemarkItem>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [DataType] :underlying_type
        # @option options [Array<WhereRule>] :where_rules
        # @option options [Array<RemarkItem>] :informal_propositions
        def initialize(options = {})
          initialize_identifier(options)

          @underlying_type = options[:underlying_type]
          @where_rules = options[:where_rules] || []
          @informal_propositions = options[:informal_propositions] || []

          super
        end

        # @return [Array<DataTypes::EnumerationItem>]
        def enumeration_items
          underlying_type.is_a?(DataTypes::Enumeration) ? underlying_type.items : []
        end

        # @return [Array<Declaration>]
        def children
          [
            *enumeration_items,
            *where_rules,
            *informal_propositions,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/type.rb ---
--- START FILE: lib/expressir/model/declarations/unique_rule.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.2.2.1 Uniqueness rule
      class UniqueRule < Declaration
        include Identifier

        model_attr_accessor :attributes, 'Reference'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Reference] :attributes
        def initialize(options = {})
          initialize_identifier(options)

          @attributes = options[:attributes] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/unique_rule.rb ---
--- START FILE: lib/expressir/model/declarations/variable.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.5.4 Local variables
      class Variable < Declaration
        include Identifier

        model_attr_accessor :type, 'DataType'
        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [DataType] :type
        # @option options [Expression] :expression
        def initialize(options = {})
          initialize_identifier(options)

          @type = options[:type]
          @expression = options[:expression]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/variable.rb ---
--- START FILE: lib/expressir/model/declarations/where_rule.rb ---
module Expressir
  module Model
    module Declarations
      # Specified in ISO 10303-11:2004
      # - section 9.2.2.2 Domain rules (WHERE clause)
      class WhereRule < Declaration
        include Identifier

        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Expression] :expression
        def initialize(options = {})
          initialize_identifier(options)

          @expression = options[:expression]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/declarations/where_rule.rb ---
--- START FILE: lib/expressir/model/expression.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 12 Expression
    # @abstract
    class Expression < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/expression.rb ---
--- START FILE: lib/expressir/model/expressions/aggregate_initializer.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.9 Aggregate initializer
      class AggregateInitializer < Expression
        model_attr_accessor :items, 'Array<AggregateInitializerItem>'

        # @param [Hash] options
        # @option options [Array<AggregateInitializerItem>] :items
        def initialize(options = {})
          @items = options[:items] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/aggregate_initializer.rb ---
--- START FILE: lib/expressir/model/expressions/aggregate_initializer_item.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.9 Aggregate initializer
      class AggregateInitializerItem < Expression
        model_attr_accessor :expression, 'Expression'
        model_attr_accessor :repetition, 'Expression'

        # @param [Hash] options
        # @option options [Expression] :expression
        # @option options [Expression] :repetition
        def initialize(options = {})
          @expression = options[:expression]
          @repetition = options[:repetition]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/aggregate_initializer_item.rb ---
--- START FILE: lib/expressir/model/expressions/binary_expression.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.1 Arithmetic operators
      # - section 12.2 Relational operators
      # - section 12.3 Binary operators
      # - section 12.4 Logical operators
      # - section 12.5 String operators
      # - section 12.6 Aggregate operators
      # - section 12.10 Complex entity instance construction operator
      class BinaryExpression < Expression
        ADDITION = :ADDITION
        AND = :AND
        COMBINE = :COMBINE
        EQUAL = :EQUAL
        EXPONENTIATION = :EXPONENTIATION
        GREATER_THAN = :GREATER_THAN
        GREATER_THAN_OR_EQUAL = :GREATER_THAN_OR_EQUAL
        IN = :IN
        INSTANCE_EQUAL = :INSTANCE_EQUAL
        INSTANCE_NOT_EQUAL = :INSTANCE_NOT_EQUAL
        INTEGER_DIVISION = :INTEGER_DIVISION
        LESS_THAN = :LESS_THAN
        LESS_THAN_OR_EQUAL = :LESS_THAN_OR_EQUAL
        LIKE = :LIKE
        MODULO = :MODULO
        MULTIPLICATION = :MULTIPLICATION
        NOT_EQUAL = :NOT_EQUAL
        OR = :OR
        REAL_DIVISION = :REAL_DIVISION
        SUBTRACTION = :SUBTRACTION
        XOR = :XOR

        model_attr_accessor :operator, ':ADDITION, :AND, :COMBINE, :EQUAL, :EXPONENTIATION, :GREATER_THAN, :GREATER_THAN_OR_EQUAL, :IN, :INSTANCE_EQUAL, :INSTANCE_NOT_EQUAL, :INTEGER_DIVISION, :LESS_THAN, :LESS_THAN_OR_EQUAL, :LIKE, :MODULO, :MULTIPLICATION, :NOT_EQUAL, :OR, :REAL_DIVISION, :SUBTRACTION, :XOR'
        model_attr_accessor :operand1, 'Expression'
        model_attr_accessor :operand2, 'Expression'

        # @param [Hash] options
        # @option options [:ADDITION, :AND, :COMBINE, :EQUAL, :EXPONENTIATION, :GREATER_THAN, :GREATER_THAN_OR_EQUAL, :IN, :INSTANCE_EQUAL, :INSTANCE_NOT_EQUAL, :INTEGER_DIVISION, :LESS_THAN, :LESS_THAN_OR_EQUAL, :LIKE, :MODULO, :MULTIPLICATION, :NOT_EQUAL, :OR, :REAL_DIVISION, :SUBTRACTION, :XOR] :operator
        # @option options [Expression] :operand1
        # @option options [Expression] :operand2
        def initialize(options = {})
          @operator = options[:operator]
          @operand1 = options[:operand1]
          @operand2 = options[:operand2]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/binary_expression.rb ---
--- START FILE: lib/expressir/model/expressions/entity_constructor.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 9.2.6 Implicit declarations
      class EntityConstructor < Expression
        model_attr_accessor :entity, 'Reference'
        model_attr_accessor :parameters, 'Array<Expression>'

        # @param [Hash] options
        # @option options [Reference] :entity
        # @option options [Array<Expression>] :parameters
        def initialize(options = {})
          @entity = options[:entity]
          @parameters = options[:parameters] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/entity_constructor.rb ---
--- START FILE: lib/expressir/model/expressions/function_call.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.8 Function call
      class FunctionCall < Expression
        model_attr_accessor :function, 'Reference'
        model_attr_accessor :parameters, 'Array<Expression>'

        # @param [Hash] options
        # @option options [Reference] :function
        # @option options [Array<Expression>] :parameters
        def initialize(options = {})
          @function = options[:function]
          @parameters = options[:parameters] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/function_call.rb ---
--- START FILE: lib/expressir/model/expressions/interval.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.2.4 Interval expressions
      class Interval < Expression
        LESS_THAN = :LESS_THAN
        LESS_THAN_OR_EQUAL = :LESS_THAN_OR_EQUAL

        model_attr_accessor :low, 'Expression'
        model_attr_accessor :operator1, ':LESS_THAN, :LESS_THAN_OR_EQUAL'
        model_attr_accessor :item, 'Reference'
        model_attr_accessor :operator2, ':LESS_THAN, :LESS_THAN_OR_EQUAL'
        model_attr_accessor :high, 'Expression'

        # @param [Hash] options
        # @option options [Expression] :low
        # @option options [:LESS_THAN, :LESS_THAN_OR_EQUAL] :operator1
        # @option options [Reference] :item
        # @option options [:LESS_THAN, :LESS_THAN_OR_EQUAL] :operator2
        # @option options [Expression] :high
        def initialize(options = {})
          @low = options[:low]
          @operator1 = options[:operator1]
          @item = options[:item]
          @operator2 = options[:operator2]
          @high = options[:high]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/interval.rb ---
--- START FILE: lib/expressir/model/expressions/query_expression.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.6.7 Query expression
      class QueryExpression < Expression
        include Identifier

        model_attr_accessor :aggregate_source, 'Reference'
        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Reference] :aggregace_source
        # @option options [Expression] :expression
        def initialize(options = {})
          initialize_identifier(options)

          @aggregate_source = options[:aggregate_source]
          @expression = options[:expression]

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            self,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/query_expression.rb ---
--- START FILE: lib/expressir/model/expressions/unary_expression.rb ---
module Expressir
  module Model
    module Expressions
      # Specified in ISO 10303-11:2004
      # - section 12.1 Arithmetic operators
      # - section 12.4.1 NOT operator
      class UnaryExpression < Expression
        MINUS = :MINUS
        NOT = :NOT
        PLUS = :PLUS

        model_attr_accessor :operator, ':MINUS, :NOT, :PLUS'
        model_attr_accessor :operand, 'Expression'

        # @param [Hash] options
        # @option options [:MINUS, :NOT, :PLUS] :operator
        # @option options [Expression] :operand
        def initialize(options = {})
          @operator = options[:operator]
          @operand = options[:operand]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/expressions/unary_expression.rb ---
--- START FILE: lib/expressir/model/identifier.rb ---
module Expressir
  module Model
    module Identifier
      # @!attribute id
      #   @return [::String]
      # @!attribute remarks
      #   @return [::Array<::String>]
      # @!attribute remark_items
      #   @return [::Array<RemarkItem>]
      # @!attribute source
      #   @return [::String]
      # @!visibility private
      def self.included(mod)
        mod.model_attr_accessor :id, '::String'
        mod.model_attr_accessor :remarks, '::Array<::String>'
        mod.model_attr_accessor :remark_items, '::Array<RemarkItem>'
        mod.model_attr_accessor :source, '::String'
      end

      # @param [Hash] options
      # @option options [::String] :id
      # @option options [::Array<::String>] :remarks
      # @option options [::Array<RemarkItem>] :remark_items
      # @option options [::String] :source
      # @!visibility private
      def initialize_identifier(options = {})
        @id = options[:id]
        @remarks = options[:remarks] || []
        @remark_items = options[:remark_items] || []
        @source = options[:source]
      end
    end
  end
end
--- END FILE: lib/expressir/model/identifier.rb ---
--- START FILE: lib/expressir/model/literal.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 7.5 Literals
    # @abstract
    class Literal < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/literal.rb ---
--- START FILE: lib/expressir/model/literals/binary.rb ---
module Expressir
  module Model
    module Literals
      # Specified in ISO 10303-11:2004
      # - section 7.5.1 Binary literal
      class Binary < Literal
        model_attr_accessor :value, '::String'

        # @param [Hash] options
        # @option options [::String] :value
        def initialize(options = {})
          @value = options[:value]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/literals/binary.rb ---
--- START FILE: lib/expressir/model/literals/integer.rb ---
module Expressir
  module Model
    module Literals
      # Specified in ISO 10303-11:2004
      # - section 7.5.2 Integer literal
      class Integer < Literal
        model_attr_accessor :value, '::String'

        # @param [Hash] options
        # @option options [::String] :value
        def initialize(options = {})
          @value = options[:value]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/literals/integer.rb ---
--- START FILE: lib/expressir/model/literals/logical.rb ---
module Expressir
  module Model
    module Literals
      # Specified in ISO 10303-11:2004
      # - section 7.5.5 Logical literal
      class Logical < Literal
        TRUE = :TRUE
        FALSE = :FALSE
        UNKNOWN = :UNKNOWN

        model_attr_accessor :value, ':TRUE, :FALSE, :UNKNOWN'

        # @param [Hash] options
        # @option options [:TRUE, :FALSE, :UNKNOWN] :value
        def initialize(options = {})
          @value = options[:value]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/literals/logical.rb ---
--- START FILE: lib/expressir/model/literals/real.rb ---
module Expressir
  module Model
    module Literals
      # Specified in ISO 10303-11:2004
      # - section 7.5.3 Real literal
      class Real < Literal
        model_attr_accessor :value, '::String'

        # @param [Hash] options
        # @option options [::String] :value
        def initialize(options = {})
          @value = options[:value]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/literals/real.rb ---
--- START FILE: lib/expressir/model/literals/string.rb ---
module Expressir
  module Model
    module Literals
      # Specified in ISO 10303-11:2004
      # - section 7.5.4 String literal
      class String < Literal
        model_attr_accessor :value, '::String'
        model_attr_accessor :encoded, '::Boolean'

        # @param [Hash] options
        # @option options [::String] :value
        # @option options [::Boolean] :encoded
        def initialize(options = {})
          @value = options[:value]
          @encoded = options[:encoded]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/literals/string.rb ---
--- START FILE: lib/expressir/model/model_element.rb ---
require 'pathname'

module Expressir
  module Model
    # Base model element
    class ModelElement
      CLASS_KEY = '_class'
      FILE_KEY = 'file'
      SOURCE_KEY = 'source'

      private_constant :CLASS_KEY
      private_constant :FILE_KEY
      private_constant :SOURCE_KEY

      # @return [ModelElement]
      attr_accessor :parent

      # @param [Hash] options
      def initialize(options = {})
        attach_parent_to_children
      end

      # @return [String]
      def path
        # this creates an implicit scope
        return if is_a? Statements::Alias or is_a? Statements::Repeat or is_a? Expressions::QueryExpression

        current_node = self
        path_parts = []
        loop do
          if current_node.class.method_defined? :id and !(current_node.is_a? References::SimpleReference)
            path_parts << current_node.id
          end

          current_node = current_node.parent
          break unless current_node
        end

        return if path_parts.empty?

        path_parts.reverse.join(".")
      end

      # @param [String] path
      # @return [ModelElement]
      def find(path)
        return self if path.empty?

        path_parts = path.safe_downcase.split(/\./).map do |current_path|
          _, _, current_path = current_path.rpartition(":") # ignore prefix
          current_path
        end

        current_scope = self
        target_node = nil
        loop do
          # find in current scope
          current_node = current_scope
          path_parts.each do |current_path|
            current_node = current_node.children_by_id[current_path]
            break unless current_node
          end
          target_node = current_node
          break if target_node

          # retry search in parent scope
          current_scope = current_scope.parent
          break unless current_scope
        end

        if target_node.is_a? Model::Declarations::InterfacedItem
          target_node = target_node.base_item
        end

        target_node
      end

      # @return [Array<Declaration>]
      def children
        []
      end

      # @return [Hash<String, Declaration>]
      def children_by_id
        @children_by_id ||= children.select{|x| x.id}.map{|x| [x.id.safe_downcase, x]}.to_h
      end

      # @return [nil]
      def reset_children_by_id
        @children_by_id = nil
        nil
      end

      # @param [String] root_path
      # @param [Express::Formatter] formatter
      # @param [Boolean] include_empty
      # @param [Proc] select_proc
      # @return [Hash]
      def to_hash(root_path: nil, formatter: nil, include_empty: nil, select_proc: nil)
        # Filter out entries
        has_filter = !select_proc.nil? && select_proc.is_a?(Proc)
        return nil if has_filter && !select_proc.call(self)

        hash = {}
        hash[CLASS_KEY] = self.class.name

        self.class.model_attrs.each do |variable|
          value = self.send(variable)
          empty = value.nil? || (value.is_a?(Array) && value.count == 0)

          # skip empty values
          next unless !empty or include_empty

          value_hash = case value
                       when Array
                         value.map do |v|
                           if v.is_a? ModelElement
                             v.to_hash(
                               root_path: root_path,
                               formatter: formatter,
                               include_empty: include_empty,
                               select_proc: select_proc
                             )
                           else
                             v
                           end
                         end.compact
                       when ModelElement
                         value.to_hash(
                           root_path: root_path,
                           formatter: formatter,
                           include_empty: include_empty,
                           select_proc: select_proc
                         )
                       else
                         value
                       end

          hash[variable.to_s] = value_hash unless value_hash.nil?
        end

        if self.is_a? Declarations::Schema and file
          hash[FILE_KEY] = root_path ? Pathname.new(file).relative_path_from(root_path).to_s : file
        end

        if self.class.method_defined? :source and formatter
          hash[SOURCE_KEY] = formatter.format(self)
        end

        hash
      end

      def to_s
        to_s(no_remarks: false, formatter: nil)
      end

      def to_s(no_remarks: false, formatter: nil)
        formatter ||= Class.new(Expressir::Express::Formatter) do
          if no_remarks
            def format_remarks(node); []; end
          end
        end
        formatter.format(self)
      end

      # @param [Hash] hash
      # @param [String] root_path
      # @return [ModelElement]
      def self.from_hash(hash, root_path: nil)
        node_class = Object.const_get(hash[CLASS_KEY])
        node_options = {}

        node_class.model_attrs.each do |variable|
          value = hash[variable.to_s]

          node_options[variable] = case value
          when Array
            value.map do |value|
              if value.is_a? Hash
                self.from_hash(value, root_path: root_path)
              else
                value
              end
            end
          when Hash
            self.from_hash(value, root_path: root_path)
          else
            value
          end
        end

        if node_class == Declarations::Schema and hash[FILE_KEY]
          node_options[FILE_KEY.to_sym] = root_path ? File.expand_path("#{root_path}/#{hash[FILE_KEY]}") : hash[FILE_KEY]
        end

        node = node_class.new(node_options)

        node
      end

      # @return [Array<Symbol>]
      def self.model_attrs
        @model_attrs ||= []
      end

      # Define a new model attribute
      # @param attr_name [Symbol] attribute name
      # @param attr_type [Symbol] attribute type
      # @!macro [attach] model_attr_accessor
      #   @!attribute $1
      #     @return [$2]
      def self.model_attr_accessor(attr_name, attr_type = nil)
        @model_attrs ||= []
        @model_attrs << attr_name

        attr_accessor attr_name
      end

      private

      # @return [nil]
      def attach_parent_to_children
        self.class.model_attrs.each do |variable|
          value = self.send(variable)

          case value
          when Array
            value.each do |value|
              if value.is_a? ModelElement
                value.parent = self
              end
            end
          when ModelElement
            value.parent = self
          end
        end
        nil
      end
    end
  end
end
--- END FILE: lib/expressir/model/model_element.rb ---
--- START FILE: lib/expressir/model/reference.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 12.7 References
    # @abstract
    class Reference < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/reference.rb ---
--- START FILE: lib/expressir/model/references/attribute_reference.rb ---
module Expressir
  module Model
    module References
      # Specified in ISO 10303-11:2004
      # - section 12.7.3 Attribute references
      class AttributeReference < Reference
        model_attr_accessor :ref, 'Reference'
        model_attr_accessor :attribute, 'Reference'

        # @param [Hash] options
        # @option options [Reference] :ref
        # @option options [Reference] :attribute
        def initialize(options = {})
          @ref = options[:ref]
          @attribute = options[:attribute]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/references/attribute_reference.rb ---
--- START FILE: lib/expressir/model/references/group_reference.rb ---
module Expressir
  module Model
    module References
      # Specified in ISO 10303-11:2004
      # - section 12.7.4 Group references
      class GroupReference < Reference
        model_attr_accessor :ref, 'Reference'
        model_attr_accessor :entity, 'Reference'

        # @param [Hash] options
        # @option options [Reference] :ref
        # @option options [Reference] :entity
        def initialize(options = {})
          @ref = options[:ref]
          @entity = options[:entity]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/references/group_reference.rb ---
--- START FILE: lib/expressir/model/references/index_reference.rb ---
module Expressir
  module Model
    module References
      # Specified in ISO 10303-11:2004
      # - section 12.3.1 Binary indexing
      # - section 12.5.1 String indexing
      # - section 12.6.1 Aggregate indexing
      class IndexReference < Reference
        model_attr_accessor :ref, 'Reference'
        model_attr_accessor :index1, 'Expression'
        model_attr_accessor :index2, 'Expression'

        # @param [Hash] options
        # @option options [Reference] :ref
        # @option options [Expression] :index1
        # @option options [Expression] :index2
        def initialize(options = {})
          @ref = options[:ref]
          @index1 = options[:index1]
          @index2 = options[:index2]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/references/index_reference.rb ---
--- START FILE: lib/expressir/model/references/simple_reference.rb ---
module Expressir
  module Model
    module References
      # Specified in ISO 10303-11:2004
      # - section 12.7.1 Simple references
      class SimpleReference < Reference
        model_attr_accessor :id, 'String'

        model_attr_accessor :base_path, 'String'

        # @param [Hash] options
        # @option options [String] :id
        # @option options [String] :base_path
        def initialize(options = {})
          @id = options[:id]

          @base_path = options[:base_path]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/references/simple_reference.rb ---
--- START FILE: lib/expressir/model/repository.rb ---
module Expressir
  module Model
    # Multi-schema global scope
    class Repository < ModelElement
      model_attr_accessor :schemas, 'Array<Declarations::Schema>'

      # @param [Hash] options
      # @option options [Array<Declarations::Schema>] :schemas
      def initialize(options = {})
        @schemas = options[:schemas] || []

        super
      end

      # @return [Array<Declaration>]
      def children
        [
          *schemas
        ]
      end

    end
  end
end
--- END FILE: lib/expressir/model/repository.rb ---
--- START FILE: lib/expressir/model/statement.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 13 Executable statements
    # @abstract
    class Statement < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/statement.rb ---
--- START FILE: lib/expressir/model/statements/alias.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.2 Alias statement
      class Alias < Statement
        include Identifier

        model_attr_accessor :expression, 'Expression'
        model_attr_accessor :statements, 'Array<Statement>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Expression] :expression
        # @option options [Array<Statement>] :statements
        def initialize(options = {})
          initialize_identifier(options)

          @expression = options[:expression]
          @statements = options[:statements] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            self,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/alias.rb ---
--- START FILE: lib/expressir/model/statements/assignment.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.3 Assignment
      class Assignment < Statement
        model_attr_accessor :ref, 'Reference'
        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option options [Reference] :ref
        # @option options [Expression] :expression
        def initialize(options = {})
          @ref = options[:ref]
          @expression = options[:expression]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/assignment.rb ---
--- START FILE: lib/expressir/model/statements/case.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.4 Case statement
      class Case < Statement
        model_attr_accessor :expression, 'Expression'
        model_attr_accessor :actions, 'Array<CaseAction>'
        model_attr_accessor :otherwise_statement, 'Statement'

        # @param [Hash] options
        # @option options [Expression] :expression
        # @option options [Array<CaseAction>] :statements
        # @option options [Statement] :otherwise_statement
        def initialize(options = {})
          @expression = options[:expression]
          @actions = options[:actions] || []
          @otherwise_statement = options[:otherwise_statement]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/case.rb ---
--- START FILE: lib/expressir/model/statements/case_action.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.4 Case statement
      class CaseAction < ModelElement
        model_attr_accessor :labels, 'Array<Expression>'
        model_attr_accessor :statement, 'Statement'

        # @param [Hash] options
        # @option options [Array<Expression>] :labels
        # @option options [Statement] :statement
        def initialize(options = {})
          @labels = options[:labels] || []
          @statement = options[:statement]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/case_action.rb ---
--- START FILE: lib/expressir/model/statements/compound.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.5 Compound statement
      class Compound < Statement
        model_attr_accessor :statements, 'Array<Statement>'

        # @param [Hash] options
        # @option options [Array<Statement>] :statements
        def initialize(options = {})
          @statements = options[:statements] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/compound.rb ---
--- START FILE: lib/expressir/model/statements/escape.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.6 Escape statement
      class Escape < Statement
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/escape.rb ---
--- START FILE: lib/expressir/model/statements/if.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.7 If ... Then ... Else statement
      class If < Statement
        model_attr_accessor :expression, 'Expression'
        model_attr_accessor :statements, 'Array<Statement>'
        model_attr_accessor :else_statements, 'Array<Statement>'

        # @param [Hash] options
        # @option options [Expression] :expression
        # @option options [Array<Statement>] :statements
        # @option options [Array<Statement>] :else_statements
        def initialize(options = {})
          @expression = options[:expression]
          @statements = options[:statements] || []
          @else_statements = options[:else_statements] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/if.rb ---
--- START FILE: lib/expressir/model/statements/null.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.1 Null (statement)
      class Null < Statement
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/null.rb ---
--- START FILE: lib/expressir/model/statements/procedure_call.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.8 Procedure call statement
      class ProcedureCall < Statement
        model_attr_accessor :procedure, 'Reference'
        model_attr_accessor :parameters, 'Array<Expression>'

        # @param [Hash] options
        # @option options [Reference] :procedure
        # @option options [Array<Expression>] :parameters
        def initialize(options = {})
          @procedure = options[:procedure]
          @parameters = options[:parameters] || []

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/procedure_call.rb ---
--- START FILE: lib/expressir/model/statements/repeat.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.9 Repeat statement
      class Repeat < Statement
        include Identifier

        model_attr_accessor :bound1, 'Expression'
        model_attr_accessor :bound2, 'Expression'
        model_attr_accessor :increment, 'Expression'
        model_attr_accessor :while_expression, 'Expression'
        model_attr_accessor :until_expression, 'Expression'
        model_attr_accessor :statements, 'Array<Statement>'

        # @param [Hash] options
        # @option (see Identifier#initialize_identifier)
        # @option options [Expression] :bound1
        # @option options [Expression] :bound2
        # @option options [Expression] :increment
        # @option options [Expression] :while_expression
        # @option options [Expression] :until_expression
        # @option options [Array<Statement>] :statements
        def initialize(options = {})
          initialize_identifier(options)

          @bound1 = options[:bound1]
          @bound2 = options[:bound2]
          @increment = options[:increment]
          @while_expression = options[:while_expression]
          @until_expression = options[:until_expression]
          @statements = options[:statements] || []

          super
        end

        # @return [Array<Declaration>]
        def children
          [
            self,
            *remark_items
          ]
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/repeat.rb ---
--- START FILE: lib/expressir/model/statements/return.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.10 Return statement
      class Return < Statement
        model_attr_accessor :expression, 'Expression'

        # @param [Hash] options
        # @option options [Expression] :expression
        def initialize(options = {})
          @expression = options[:expression]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/return.rb ---
--- START FILE: lib/expressir/model/statements/skip.rb ---
module Expressir
  module Model
    module Statements
      # Specified in ISO 10303-11:2004
      # - section 13.11 Skip statement
      class Skip < Statement
      end
    end
  end
end
--- END FILE: lib/expressir/model/statements/skip.rb ---
--- START FILE: lib/expressir/model/supertype_expression.rb ---
module Expressir
  module Model
    # Specified in ISO 10303-11:2004
    # - section 9.2.5 Subtype/supertype constraints
    # @abstract
    class SupertypeExpression < ModelElement
    end
  end
end
--- END FILE: lib/expressir/model/supertype_expression.rb ---
--- START FILE: lib/expressir/model/supertype_expressions/binary_supertype_expression.rb ---
module Expressir
  module Model
    module SupertypeExpressions
      # Specified in ISO 10303-11:2004
      # - section 9.2.5.3 ANDOR
      # - section 9.2.5.4 AND
      class BinarySupertypeExpression < SupertypeExpression
        AND = :AND
        ANDOR = :ANDOR

        model_attr_accessor :operator, ':AND, :ANDOR'
        model_attr_accessor :operand1, 'SupertypeExpression'
        model_attr_accessor :operand2, 'SupertypeExpression'

        # @param [Hash] options
        # @option options [:AND, :ANDOR] :operator
        # @option options [SupertypeExpression] :operand1
        # @option options [SupertypeExpression] :operand2
        def initialize(options = {})
          @operator = options[:operator]
          @operand1 = options[:operand1]
          @operand2 = options[:operand2]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/supertype_expressions/binary_supertype_expression.rb ---
--- START FILE: lib/expressir/model/supertype_expressions/oneof_supertype_expression.rb ---
module Expressir
  module Model
    module SupertypeExpressions
      # Specified in ISO 10303-11:2004
      # - section 9.2.5.2 ONEOF
      class OneofSupertypeExpression < SupertypeExpression
        model_attr_accessor :operands, 'Array<SupertypeExpression>'

        # @param [Hash] options
        # @option options [Array<SupertypeExpression>] :operands
        def initialize(options = {})
          @operands = options[:operands]

          super
        end
      end
    end
  end
end
--- END FILE: lib/expressir/model/supertype_expressions/oneof_supertype_expression.rb ---
--- START FILE: lib/expressir/version.rb ---
module Expressir
  VERSION = "1.4.3".freeze
end
--- END FILE: lib/expressir/version.rb ---
--- START FILE: spec/acceptance/version_spec.rb ---
require "spec_helper"

RSpec.describe "Expressir" do
  describe "version" do
    it "has a version number" do |example|
      GC.stress = ENV["GC_STRESS"] == "true"
      puts "Running tests in GC stress mode. It may take a couple of hours ..." if GC.stress

      print "\n[#{example.description}] "
      expect(Expressir::VERSION).not_to be nil

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "displays the current verison" do |example|
      print "\n[#{example.description}] "
      command = %w(version)
      output = capture_stdout { Expressir::Cli.start(command) }
      expect(output).to include(Expressir::VERSION)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end
end
--- END FILE: spec/acceptance/version_spec.rb ---
--- START FILE: spec/expressir/express/cache_spec.rb ---
require "yaml"
require "tempfile"
require "spec_helper"
require "expressir/express/parser"
require "expressir/express/cache"

TEST_VERSION = "0.0.0".freeze

RSpec.describe Expressir::Express::Cache do
  describe ".to_file" do
    it "exports an object" do |example|
      print "\n[#{example.description}] "
      temp_file = Tempfile.new

      repository = Expressir::Model::Repository.new

      begin
        Expressir::Express::Cache.to_file(temp_file, repository, test_overwrite_version: TEST_VERSION)

        size = File.size(temp_file)

        expect(size).to be > 0
      ensure
        temp_file.close
        temp_file.unlink
      end

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end

  describe ".from_file" do
    it "throws an exception if the cache file does not exist" do |example|
      print "\n[#{example.description}] "
      expect do
        Expressir::Express::Cache.from_file("non-existing-file", test_overwrite_version: TEST_VERSION)
      end.to raise_error(Errno::ENOENT)
    end

    it "loads a cache file" do |example|
      print "\n[#{example.description}] "
      temp_file = Tempfile.new

      repository = Expressir::Model::Repository.new

      begin
        Expressir::Express::Cache.to_file(temp_file, repository, test_overwrite_version: TEST_VERSION)

        result = Expressir::Express::Cache.from_file(temp_file, test_overwrite_version: TEST_VERSION)

        expect(result).to be_instance_of(Expressir::Model::Repository)
      ensure
        temp_file.close
        temp_file.unlink
      end

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "fails parsing a cache from a different Expressir version" do |example|
      print "\n[#{example.description}] "
      temp_file = Tempfile.new

      repository = Expressir::Model::Repository.new

      begin
        Expressir::Express::Cache.to_file(temp_file, repository, test_overwrite_version: TEST_VERSION)

        expect do
          Expressir::Express::Cache.from_file(temp_file)
        end.to raise_error(Expressir::Error)
      ensure
        temp_file.close
        temp_file.unlink
      end

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end
end
--- END FILE: spec/expressir/express/cache_spec.rb ---
--- START FILE: spec/expressir/express/formatter_spec.rb ---
require "yaml"
require "spec_helper"
require "expressir/express/parser"
require "expressir/express/formatter"
require "expressir/express/schema_head_formatter"
require "expressir/express/hyperlink_formatter"

RSpec.describe Expressir::Express::Formatter do
  describe ".format" do
    it "exports an object (single.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "single.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "single_formatted.exp")
      repo = Expressir::Express::Parser.from_file(exp_file)
      result = Expressir::Express::Formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "multiple_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      result = Expressir::Express::Formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object (remark.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "remark.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "remark_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      result = Expressir::Express::Formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object (syntax.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "syntax.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "syntax_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      result = Expressir::Express::Formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object with schema head formatter (syntax.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "syntax.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "syntax_schema_head_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      formatter = Class.new(Expressir::Express::Formatter) do
        include Expressir::Express::SchemaHeadFormatter
      end
      result = formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object with hyperlink formatter (syntax.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "syntax.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "syntax_hyperlink_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      formatter = Class.new(Expressir::Express::Formatter) do
        include Expressir::Express::HyperlinkFormatter
      end
      result = formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object with hyperlink formatter (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "multiple_hyperlink_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      formatter = Class.new(Expressir::Express::Formatter) do
        include Expressir::Express::HyperlinkFormatter
      end
      result = formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports an object with schema head and hyperlink formatter (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")
      formatted_exp_file = Expressir.root_path.join("spec", "syntax", "multiple_schema_head_hyperlink_formatted.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      formatter = Class.new(Expressir::Express::Formatter) do
        include Expressir::Express::SchemaHeadFormatter
        include Expressir::Express::HyperlinkFormatter
      end
      result = formatter.format(repo)
      # File.write(formatted_exp_file, result)
      expected_result = File.read(formatted_exp_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end
end
--- END FILE: spec/expressir/express/formatter_spec.rb ---
--- START FILE: spec/expressir/express/parser_spec.rb ---
require "yaml"
require "spec_helper"
require "expressir/express/parser"

RSpec.describe Expressir::Express::Parser do
  describe ".from_file" do
    it "throws an exception if the file to parse does not exist" do |example|
      print "\n[#{example.description}] "
      expect do
        Expressir::Express::Parser.from_file("non-existing-file")
      end.to raise_error(Errno::ENOENT)
    end

    it "parses a file (single.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "single.exp")
      yaml_file = Expressir.root_path.join("spec", "syntax", "single.yaml")

      repo = Expressir::Express::Parser.from_file(exp_file)
      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      # File.write(yaml_file, result)
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses a file (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")
      yaml_file = Expressir.root_path.join("spec", "syntax", "multiple.yaml")

      repo = Expressir::Express::Parser.from_file(exp_file)
      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      # File.write(yaml_file, result)
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses a file (syntax.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "syntax.exp")
      yaml_file = Expressir.root_path.join("spec", "syntax", "syntax.yaml")

      repo = Expressir::Express::Parser.from_file(exp_file)
      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      # File.write(yaml_file, result)
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses a file (remark.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "remark.exp")
      yaml_file = Expressir.root_path.join("spec", "syntax", "remark.yaml")

      repo = Expressir::Express::Parser.from_file(exp_file)
      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      # File.write(yaml_file, result)
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses a file including original source (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")

      input = File.read(exp_file)
      repo = Expressir::Express::Parser.from_file(exp_file, include_source: true)

      schema = repo.schemas.first
      start_index = input.index("SCHEMA")
      stop_index = input.index("END_SCHEMA;") + "END_SCHEMA;".length - 1
      expected_result = input[start_index..stop_index]
      expect(schema.source).to eq(expected_result)

      entity = schema.entities.first
      start_index = input.index("ENTITY")
      stop_index = input.index("END_ENTITY;") + "END_ENTITY;".length - 1
      expected_result = input[start_index..stop_index]
      expect(entity.source).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end

  describe ".from_files" do
    it "parses multiple files (single.exp, multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_files = [
        Expressir.root_path.join("spec", "syntax", "single.exp"),
        Expressir.root_path.join("spec", "syntax", "multiple.exp"),
      ]

      repo = Expressir::Express::Parser.from_files(exp_files)

      schemas = repo.schemas
      expect(schemas.count).to eq(5)
      expect(schemas[0].file).to eq(exp_files[0].to_s)
      expect(schemas[0].id).to eq("single_schema")
      expect(schemas[1].file).to eq(exp_files[1].to_s)
      expect(schemas[1].id).to eq("multiple_schema")
      expect(schemas[2].file).to eq(exp_files[1].to_s)
      expect(schemas[2].id).to eq("multiple_schema2")
      expect(schemas[3].file).to eq(exp_files[1].to_s)
      expect(schemas[3].id).to eq("multiple_schema3")
      expect(schemas[4].file).to eq(exp_files[1].to_s)
      expect(schemas[4].id).to eq("multiple_schema4")

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end
end
--- END FILE: spec/expressir/express/parser_spec.rb ---
--- START FILE: spec/expressir/model/data_types/aggregate_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Aggregate do
  describe ".new" do
    subject(:aggregate) do
      described_class.new(
        id: id,
        base_type: base_type,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_aggregate" }
    let(:base_type) { Expressir::Model::DataTypes::Boolean.new }
    let(:remarks) { ["First remark", "Second remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
      ]
    end

    it "creates an aggregate type" do
      expect(aggregate).to be_a described_class
      expect(aggregate.id).to eq "test_aggregate"
      expect(aggregate.base_type).to be_a Expressir::Model::DataTypes::Boolean
      expect(aggregate.remarks).to eq ["First remark", "Second remark"]
    end

    context "with complex base types" do
      let(:nested_base_type) do
        described_class.new(
          id: "nested",
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles nested aggregate types" do
        aggregate = described_class.new(
          id: "nested_aggregate",
          base_type: nested_base_type,
        )
        expect(aggregate.base_type).to be_a described_class
        expect(aggregate.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end
    end
  end

  describe "#children" do
    subject(:aggregate) do
      described_class.new(
        id: "test_aggregate",
        base_type: base_type,
        remark_items: remarks,
      )
    end

    let(:base_type) { Expressir::Model::DataTypes::Boolean.new }
    let(:remarks) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
      ]
    end

    it "returns all remark items" do
      expect(aggregate.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2"),
      )
    end

    context "with no remarks" do
      let(:remarks) { nil }

      it "returns empty array" do
        expect(aggregate.children).to be_empty
      end
    end
  end

  describe "type compatibility" do
    let(:aggregate_type) { described_class.new(id: "test") }

    it "is not compatible with basic types" do
      expect(aggregate_type).not_to be_a Expressir::Model::DataTypes::Integer
      expect(aggregate_type).not_to be_a Expressir::Model::DataTypes::String
      expect(aggregate_type).not_to be_a Expressir::Model::DataTypes::Boolean
    end
  end

  describe "edge cases" do
    context "with circular references" do
      let(:type_a) { described_class.new(id: "type_a") }
      let(:type_b) { described_class.new(id: "type_b") }

      it "handles circular type references" do
        type_a.base_type = type_b
        type_b.base_type = type_a

        expect(type_a.base_type).to eq type_b
        expect(type_b.base_type).to eq type_a
      end
    end

    context "with nil values" do
      it "handles nil id" do
        aggregate = described_class.new(base_type: Expressir::Model::DataTypes::Boolean.new)
        expect(aggregate.id).to be_nil
      end

      it "handles nil base_type" do
        aggregate = described_class.new(id: "test")
        expect(aggregate.base_type).to be_nil
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/aggregate_spec.rb ---
--- START FILE: spec/expressir/model/data_types/array_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Array do
  describe ".new" do
    subject(:array) do
      described_class.new(
        bound1: bound1,
        bound2: bound2,
        optional: optional,
        unique: unique,
        base_type: base_type,
      )
    end

    let(:bound1) { Expressir::Model::Literals::Integer.new(value: "1") }
    let(:bound2) { Expressir::Model::Literals::Integer.new(value: "10") }
    let(:optional) { true }
    let(:unique) { true }
    let(:base_type) { Expressir::Model::DataTypes::String.new }

    it "creates an array type" do
      expect(array).to be_a described_class
      expect(array.bound1.value).to eq "1"
      expect(array.bound2.value).to eq "10"
      expect(array.optional).to be true
      expect(array.unique).to be true
      expect(array.base_type).to be_a Expressir::Model::DataTypes::String
    end
  end

  describe "array characteristics" do
    context "with different bounds" do
      let(:zero_size_array) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "0"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:equal_bounds_array) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "5"),
          bound2: Expressir::Model::Literals::Integer.new(value: "5"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:large_bounds_array) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "999999"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles zero size arrays" do
        expect(zero_size_array.bound1.value).to eq "1"
        expect(zero_size_array.bound2.value).to eq "0"
      end

      it "handles fixed size arrays" do
        expect(equal_bounds_array.bound1.value).to eq "5"
        expect(equal_bounds_array.bound2.value).to eq "5"
      end

      it "handles large bounds" do
        expect(large_bounds_array.bound1.value).to eq "1"
        expect(large_bounds_array.bound2.value).to eq "999999"
      end
    end
  end

  describe "optional and unique combinations" do
    context "with different flag combinations" do
      let(:optional_unique_array) do
        described_class.new(
          optional: true,
          unique: true,
          base_type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:optional_nonunique_array) do
        described_class.new(
          optional: true,
          unique: false,
          base_type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:required_unique_array) do
        described_class.new(
          optional: false,
          unique: true,
          base_type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:required_nonunique_array) do
        described_class.new(
          optional: false,
          unique: false,
          base_type: Expressir::Model::DataTypes::String.new,
        )
      end

      it "handles optional unique arrays" do
        expect(optional_unique_array.optional).to be true
        expect(optional_unique_array.unique).to be true
      end

      it "handles optional non-unique arrays" do
        expect(optional_nonunique_array.optional).to be true
        expect(optional_nonunique_array.unique).to be false
      end

      it "handles required unique arrays" do
        expect(required_unique_array.optional).to be false
        expect(required_unique_array.unique).to be true
      end

      it "handles required non-unique arrays" do
        expect(required_nonunique_array.optional).to be false
        expect(required_nonunique_array.unique).to be false
      end
    end
  end

  describe "base type compatibility" do
    context "with different base types" do
      let(:integer_array) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:string_array) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:nested_array) do
        described_class.new(
          base_type: described_class.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
          ),
        )
      end

      it "handles integer arrays" do
        expect(integer_array.base_type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles string arrays" do
        expect(string_array.base_type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles nested arrays" do
        expect(nested_array.base_type).to be_a described_class
        expect(nested_array.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end
    end
  end

  describe "edge cases" do
    context "with invalid bounds" do
      let(:negative_bounds_array) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "-5"),
          bound2: Expressir::Model::Literals::Integer.new(value: "-1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:reversed_bounds_array) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "10"),
          bound2: Expressir::Model::Literals::Integer.new(value: "1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles negative bounds" do
        expect(negative_bounds_array.bound1.value).to eq "-5"
        expect(negative_bounds_array.bound2.value).to eq "-1"
      end

      it "handles reversed bounds" do
        expect(reversed_bounds_array.bound1.value).to eq "10"
        expect(reversed_bounds_array.bound2.value).to eq "1"
      end
    end

    context "with nil values" do
      let(:unbounded_array) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:no_base_type_array) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "10"),
        )
      end

      it "handles unbounded arrays" do
        expect(unbounded_array.bound1).to be_nil
        expect(unbounded_array.bound2).to be_nil
      end

      it "handles missing base type" do
        expect(no_base_type_array.base_type).to be_nil
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/array_spec.rb ---
--- START FILE: spec/expressir/model/data_types/bag_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Bag do
  describe ".new" do
    subject(:bag) do
      described_class.new(
        bound1: bound1,
        bound2: bound2,
        base_type: base_type,
      )
    end

    let(:bound1) { Expressir::Model::Literals::Integer.new(value: "1") }
    let(:bound2) { Expressir::Model::Literals::Integer.new(value: "10") }
    let(:base_type) { Expressir::Model::DataTypes::String.new }

    it "creates a bag type" do
      expect(bag).to be_a described_class
      expect(bag.bound1.value).to eq "1"
      expect(bag.bound2.value).to eq "10"
      expect(bag.base_type).to be_a Expressir::Model::DataTypes::String
    end
  end

  describe "bag characteristics" do
    context "with different bounds" do
      let(:unbounded_bag) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:single_element_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:large_bounds_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "999999"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles unbounded bags" do
        expect(unbounded_bag.bound1).to be_nil
        expect(unbounded_bag.bound2).to be_nil
      end

      it "handles single element bags" do
        expect(single_element_bag.bound1.value).to eq "1"
        expect(single_element_bag.bound2.value).to eq "1"
      end

      it "handles large bounds" do
        expect(large_bounds_bag.bound1.value).to eq "1"
        expect(large_bounds_bag.bound2.value).to eq "999999"
      end
    end
  end

  describe "base type compatibility" do
    context "with different base types" do
      let(:integer_bag) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:nested_bag) do
        described_class.new(
          base_type: described_class.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
          ),
        )
      end

      let(:array_bag) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
          ),
        )
      end

      it "handles basic type elements" do
        expect(integer_bag.base_type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles nested bags" do
        expect(nested_bag.base_type).to be_a described_class
        expect(nested_bag.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles array base types" do
        expect(array_bag.base_type).to be_a Expressir::Model::DataTypes::Array
        expect(array_bag.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end
    end
  end

  describe "edge cases" do
    context "with invalid bounds" do
      let(:zero_bounds_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "0"),
          bound2: Expressir::Model::Literals::Integer.new(value: "0"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:negative_bounds_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "-5"),
          bound2: Expressir::Model::Literals::Integer.new(value: "-1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:reversed_bounds_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "10"),
          bound2: Expressir::Model::Literals::Integer.new(value: "1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles zero bounds" do
        expect(zero_bounds_bag.bound1.value).to eq "0"
        expect(zero_bounds_bag.bound2.value).to eq "0"
      end

      it "handles negative bounds" do
        expect(negative_bounds_bag.bound1.value).to eq "-5"
        expect(negative_bounds_bag.bound2.value).to eq "-1"
      end

      it "handles reversed bounds" do
        expect(reversed_bounds_bag.bound1.value).to eq "10"
        expect(reversed_bounds_bag.bound2.value).to eq "1"
      end
    end

    context "with nil values" do
      let(:no_bounds_bag) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:partial_bounds_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:no_base_type_bag) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "10"),
        )
      end

      it "handles missing bounds" do
        expect(no_bounds_bag.bound1).to be_nil
        expect(no_bounds_bag.bound2).to be_nil
      end

      it "handles partial bounds" do
        expect(partial_bounds_bag.bound1.value).to eq "1"
        expect(partial_bounds_bag.bound2).to be_nil
      end

      it "handles missing base type" do
        expect(no_base_type_bag.base_type).to be_nil
      end
    end
  end

  describe "type comparisons" do
    let(:bag1) do
      described_class.new(
        bound1: Expressir::Model::Literals::Integer.new(value: "1"),
        bound2: Expressir::Model::Literals::Integer.new(value: "10"),
        base_type: Expressir::Model::DataTypes::Integer.new,
      )
    end

    let(:bag2) do
      described_class.new(
        bound1: Expressir::Model::Literals::Integer.new(value: "1"),
        bound2: Expressir::Model::Literals::Integer.new(value: "10"),
        base_type: Expressir::Model::DataTypes::Integer.new,
      )
    end

    let(:different_bag) do
      described_class.new(
        bound1: Expressir::Model::Literals::Integer.new(value: "1"),
        bound2: Expressir::Model::Literals::Integer.new(value: "5"),
        base_type: Expressir::Model::DataTypes::String.new,
      )
    end

    it "identifies identical bags" do
      expect(bag1.bound1.value).to eq bag2.bound1.value
      expect(bag1.bound2.value).to eq bag2.bound2.value
      expect(bag1.base_type).to be_a Expressir::Model::DataTypes::Integer
      expect(bag2.base_type).to be_a Expressir::Model::DataTypes::Integer
    end

    it "identifies different bags" do
      expect(different_bag.bound2.value).not_to eq bag1.bound2.value
      expect(different_bag.base_type).not_to be_a Expressir::Model::DataTypes::Integer
    end
  end
end
--- END FILE: spec/expressir/model/data_types/bag_spec.rb ---
--- START FILE: spec/expressir/model/data_types/binary_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Binary do
  describe ".new" do
    subject(:binary) do
      described_class.new(
        width: width,
        fixed: fixed,
      )
    end

    let(:width) { Expressir::Model::Literals::Integer.new(value: "8") }
    let(:fixed) { true }

    it "creates a binary type" do
      expect(binary).to be_a described_class
      expect(binary.width.value).to eq "8"
      expect(binary.fixed).to be true
    end
  end

  describe "width characteristics" do
    context "with different width specifications" do
      let(:zero_width_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "0"),
          fixed: true,
        )
      end

      let(:large_width_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "32768"),
          fixed: true,
        )
      end

      let(:unbounded_binary) do
        described_class.new
      end

      it "handles zero width" do
        expect(zero_width_binary.width.value).to eq "0"
        expect(zero_width_binary.fixed).to be true
      end

      it "handles large width" do
        expect(large_width_binary.width.value).to eq "32768"
        expect(large_width_binary.fixed).to be true
      end

      it "handles unbounded width" do
        expect(unbounded_binary.width).to be_nil
        expect(unbounded_binary.fixed).to be_nil
      end
    end
  end

  describe "fixed vs variable width" do
    context "with different fixity settings" do
      let(:fixed_width_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "8"),
          fixed: true,
        )
      end

      let(:variable_width_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "8"),
          fixed: false,
        )
      end

      it "enforces fixed width" do
        expect(fixed_width_binary.width.value).to eq "8"
        expect(fixed_width_binary.fixed).to be true
      end

      it "allows variable width" do
        expect(variable_width_binary.width.value).to eq "8"
        expect(variable_width_binary.fixed).to be false
      end
    end
  end

  describe "edge cases" do
    context "with invalid width values" do
      let(:negative_width_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "-8"),
          fixed: true,
        )
      end

      let(:max_width_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "2147483647"),
          fixed: true,
        )
      end

      it "handles negative width" do
        expect(negative_width_binary.width.value).to eq "-8"
      end

      it "handles maximum width" do
        expect(max_width_binary.width.value).to eq "2147483647"
      end
    end

    context "with partial specifications" do
      let(:width_only_binary) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "8"),
        )
      end

      let(:fixed_only_binary) do
        described_class.new(
          fixed: true,
        )
      end

      it "handles width without fixed specification" do
        expect(width_only_binary.width.value).to eq "8"
        expect(width_only_binary.fixed).to be_nil
      end

      it "handles fixed without width specification" do
        expect(fixed_only_binary.width).to be_nil
        expect(fixed_only_binary.fixed).to be true
      end
    end
  end

  describe "type comparisons" do
    let(:binary1) do
      described_class.new(
        width: Expressir::Model::Literals::Integer.new(value: "8"),
        fixed: true,
      )
    end

    let(:binary2) do
      described_class.new(
        width: Expressir::Model::Literals::Integer.new(value: "8"),
        fixed: true,
      )
    end

    let(:different_binary) do
      described_class.new(
        width: Expressir::Model::Literals::Integer.new(value: "16"),
        fixed: false,
      )
    end

    it "identifies identical binary types" do
      expect(binary1.width.value).to eq binary2.width.value
      expect(binary1.fixed).to eq binary2.fixed
    end

    it "identifies different binary types" do
      expect(different_binary.width.value).not_to eq binary1.width.value
      expect(different_binary.fixed).not_to eq binary1.fixed
    end
  end
end
--- END FILE: spec/expressir/model/data_types/binary_spec.rb ---
--- START FILE: spec/expressir/model/data_types/boolean_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Boolean do
  describe ".new" do
    subject(:boolean) { described_class.new }

    it "creates a boolean type" do
      expect(boolean).to be_a described_class
    end
  end

  describe "logical operations" do
    let(:boolean_type) { described_class.new }
    let(:logical_type) { Expressir::Model::DataTypes::Logical.new }

    it "is distinct from logical type" do
      expect(boolean_type).not_to be_a Expressir::Model::DataTypes::Logical
    end

    context "when used in expressions" do
      let(:true_value) { Expressir::Model::Literals::Logical.new(value: :TRUE) }
      let(:false_value) { Expressir::Model::Literals::Logical.new(value: :FALSE) }

      it "handles boolean operations" do
        # Test AND operation
        and_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :AND,
          operand1: true_value,
          operand2: false_value,
        )
        expect(and_expr.operator).to eq :AND
        expect(and_expr.operand1.value).to eq :TRUE
        expect(and_expr.operand2.value).to eq :FALSE

        # Test OR operation
        or_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :OR,
          operand1: true_value,
          operand2: false_value,
        )
        expect(or_expr.operator).to eq :OR
        expect(or_expr.operand1.value).to eq :TRUE
        expect(or_expr.operand2.value).to eq :FALSE

        # Test NOT operation
        not_expr = Expressir::Model::Expressions::UnaryExpression.new(
          operator: :NOT,
          operand: true_value,
        )
        expect(not_expr.operator).to eq :NOT
        expect(not_expr.operand.value).to eq :TRUE
      end
    end
  end

  describe "type compatibility" do
    let(:boolean_type) { described_class.new }

    it "is not compatible with numeric types" do
      expect(boolean_type).not_to be_a Expressir::Model::DataTypes::Number
      expect(boolean_type).not_to be_a Expressir::Model::DataTypes::Integer
      expect(boolean_type).not_to be_a Expressir::Model::DataTypes::Real
    end

    it "is not compatible with string type" do
      expect(boolean_type).not_to be_a Expressir::Model::DataTypes::String
    end
  end

  describe "edge cases" do
    let(:boolean_type) { described_class.new }

    context "when used in conditional expressions" do
      let(:true_value) { Expressir::Model::Literals::Logical.new(value: :TRUE) }

      it "can be used in if statements" do
        if_stmt = Expressir::Model::Statements::If.new(
          expression: true_value,
          statements: [],
          else_statements: [],
        )
        expect(if_stmt.expression.value).to eq :TRUE
      end

      it "can be used in where rules" do
        where_rule = Expressir::Model::Declarations::WhereRule.new(
          id: "test_rule",
          expression: true_value,
        )
        expect(where_rule.expression.value).to eq :TRUE
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/boolean_spec.rb ---
--- START FILE: spec/expressir/model/data_types/enumeration_item_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::EnumerationItem do
  describe ".new" do
    subject(:enum_item) do
      described_class.new(
        id: id,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "RED" }
    let(:remarks) { ["Primary color", "First item in list"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1", remarks: ["Detail 1"]),
        Expressir::Model::Declarations::RemarkItem.new(id: "remark2", remarks: ["Detail 2"]),
      ]
    end

    it "creates an enumeration item" do
      expect(enum_item).to be_a described_class
      expect(enum_item.id).to eq "RED"
      expect(enum_item.remarks).to eq ["Primary color", "First item in list"]
      expect(enum_item.remark_items).to contain_exactly(
        have_attributes(id: "remark1", remarks: ["Detail 1"]),
        have_attributes(id: "remark2", remarks: ["Detail 2"]),
      )
    end
  end

  describe "#children" do
    subject(:enum_item) do
      described_class.new(
        id: "RED",
        remark_items: remark_items,
      )
    end

    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
      ]
    end

    it "returns remark items" do
      expect(enum_item.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2"),
      )
    end

    context "without remark items" do
      let(:remark_items) { nil }

      it "returns empty array" do
        expect(enum_item.children).to be_empty
      end
    end
  end

  describe "identifier handling" do
    context "with different id formats" do
      let(:lowercase_item) { described_class.new(id: "red") }
      let(:mixed_case_item) { described_class.new(id: "Red") }
      let(:numeric_item) { described_class.new(id: "COLOR_1") }
      let(:special_chars_item) { described_class.new(id: "RED_BLUE_GREEN") }

      it "handles lowercase identifiers" do
        expect(lowercase_item.id).to eq "red"
      end

      it "handles mixed case identifiers" do
        expect(mixed_case_item.id).to eq "Red"
      end

      it "handles identifiers with numbers" do
        expect(numeric_item.id).to eq "COLOR_1"
      end

      it "handles identifiers with underscores" do
        expect(special_chars_item.id).to eq "RED_BLUE_GREEN"
      end
    end

    context "with edge cases" do
      let(:empty_id_item) { described_class.new(id: "") }
      let(:single_char_item) { described_class.new(id: "R") }
      let(:very_long_id_item) { described_class.new(id: "A" * 100) }

      it "handles empty identifiers" do
        expect(empty_id_item.id).to eq ""
      end

      it "handles single character identifiers" do
        expect(single_char_item.id).to eq "R"
      end

      it "handles very long identifiers" do
        expect(very_long_id_item.id.length).to eq 100
      end
    end
  end

  describe "remark handling" do
    context "with different remark formats" do
      let(:multiline_remarks) do
        described_class.new(
          id: "RED",
          remarks: [
            "First line\nSecond line",
            "Third line\nFourth line",
          ],
        )
      end

      let(:special_chars_remarks) do
        described_class.new(
          id: "RED",
          remarks: [
            "Contains special chars: !@#$%^&*()",
            "Unicode: αβγδε",
          ],
        )
      end

      let(:empty_remarks) do
        described_class.new(
          id: "RED",
          remarks: ["", "  ", "\n"],
        )
      end

      it "handles multiline remarks" do
        expect(multiline_remarks.remarks).to contain_exactly(
          "First line\nSecond line",
          "Third line\nFourth line",
        )
      end

      it "handles special characters in remarks" do
        expect(special_chars_remarks.remarks).to contain_exactly(
          "Contains special chars: !@#$%^&*()",
          "Unicode: αβγδε",
        )
      end

      it "handles empty remarks" do
        expect(empty_remarks.remarks).to contain_exactly("", "  ", "\n")
      end
    end
  end

  describe "parent-child relationships" do
    let(:parent_enum) do
      Expressir::Model::DataTypes::Enumeration.new(
        id: "COLOR",
        items: [
          described_class.new(id: "RED"),
          described_class.new(id: "GREEN"),
          described_class.new(id: "BLUE"),
        ],
      )
    end

    it "establishes correct parent relationship" do
      expect(parent_enum.items.first.parent).to eq parent_enum
      expect(parent_enum.items.last.parent).to eq parent_enum
    end

    it "maintains correct ordering" do
      expect(parent_enum.items.map(&:id)).to eq ["RED", "GREEN", "BLUE"]
    end
  end
end
--- END FILE: spec/expressir/model/data_types/enumeration_item_spec.rb ---
--- START FILE: spec/expressir/model/data_types/enumeration_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Enumeration do
  describe ".new" do
    subject(:enumeration) do
      described_class.new(
        extensible: extensible,
        based_on: based_on,
        items: items,
      )
    end

    let(:extensible) { true }
    let(:based_on) do
      Expressir::Model::References::SimpleReference.new(
        id: "base_enum",
      )
    end
    let(:items) do
      [
        Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
        Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
      ]
    end

    it "creates an enumeration type" do
      expect(enumeration).to be_a described_class
      expect(enumeration.extensible).to be true
      expect(enumeration.based_on.id).to eq "base_enum"
      expect(enumeration.items.map(&:id)).to eq ["ITEM1", "ITEM2"]
    end
  end

  describe "extensibility behavior" do
    context "with different extensibility settings" do
      let(:extensible_enum) do
        described_class.new(
          extensible: true,
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
          ],
        )
      end

      let(:non_extensible_enum) do
        described_class.new(
          extensible: false,
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
          ],
        )
      end

      let(:default_enum) do
        described_class.new(
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
          ],
        )
      end

      it "handles extensible enumerations" do
        expect(extensible_enum.extensible).to be true
      end

      it "handles non-extensible enumerations" do
        expect(non_extensible_enum.extensible).to be false
      end

      it "handles default extensibility" do
        expect(default_enum.extensible).to be_nil
      end
    end
  end

  describe "inheritance behavior" do
    context "with different base types" do
      let(:base_enum) do
        described_class.new(
          id: "BASE",
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
          ],
        )
      end

      let(:derived_enum) do
        described_class.new(
          id: "DERIVED",
          based_on: Expressir::Model::References::SimpleReference.new(id: "BASE"),
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM3"),
          ],
        )
      end

      let(:empty_derived_enum) do
        described_class.new(
          id: "EMPTY_DERIVED",
          based_on: Expressir::Model::References::SimpleReference.new(id: "BASE"),
        )
      end

      it "handles base enumeration" do
        expect(base_enum.items.map(&:id)).to eq ["ITEM1", "ITEM2"]
        expect(base_enum.based_on).to be_nil
      end

      it "handles derived enumeration with additional items" do
        expect(derived_enum.based_on.id).to eq "BASE"
        expect(derived_enum.items.map(&:id)).to eq ["ITEM3"]
      end

      it "handles derived enumeration without additional items" do
        expect(empty_derived_enum.based_on.id).to eq "BASE"
        expect(empty_derived_enum.items).to be_empty
      end
    end
  end

  describe "item management" do
    context "with different item configurations" do
      let(:empty_enum) { described_class.new }

      let(:single_item_enum) do
        described_class.new(
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
          ],
        )
      end

      let(:duplicate_items_enum) do
        described_class.new(
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
          ],
        )
      end

      let(:complex_items_enum) do
        described_class.new(
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(
              id: "ITEM1",
              remarks: ["First item"],
            ),
            Expressir::Model::DataTypes::EnumerationItem.new(
              id: "ITEM2",
              remarks: ["Second item"],
            ),
          ],
        )
      end

      it "handles empty enumeration" do
        expect(empty_enum.items).to be_empty
      end

      it "handles single item enumeration" do
        expect(single_item_enum.items.length).to eq 1
        expect(single_item_enum.items.first.id).to eq "ITEM1"
      end

      it "handles duplicate items" do
        expect(duplicate_items_enum.items.map(&:id)).to eq ["ITEM1", "ITEM1"]
      end

      it "handles items with remarks" do
        expect(complex_items_enum.items.first.remarks).to eq ["First item"]
        expect(complex_items_enum.items.last.remarks).to eq ["Second item"]
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:circular_reference) do
        enum1 = described_class.new(id: "ENUM1")
        described_class.new(
          id: "ENUM2",
          based_on: Expressir::Model::References::SimpleReference.new(id: "ENUM1"),
        )
        enum1.based_on = Expressir::Model::References::SimpleReference.new(id: "ENUM2")
        enum1
      end

      let(:deeply_nested_enum) do
        described_class.new(
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(
              id: "ITEM1",
              remark_items: [
                Expressir::Model::Declarations::RemarkItem.new(
                  id: "remark1",
                  remarks: ["Nested remark"],
                ),
              ],
            ),
          ],
        )
      end

      let(:mixed_case_enum) do
        described_class.new(
          items: [
            Expressir::Model::DataTypes::EnumerationItem.new(id: "item1"),
            Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
            Expressir::Model::DataTypes::EnumerationItem.new(id: "Item3"),
          ],
        )
      end

      it "handles circular references" do
        expect(circular_reference.based_on.id).to eq "ENUM2"
      end

      it "handles deeply nested structures" do
        expect(deeply_nested_enum.items.first.remark_items.first.remarks).to eq ["Nested remark"]
      end

      it "preserves item case sensitivity" do
        expect(mixed_case_enum.items.map(&:id)).to eq ["item1", "ITEM2", "Item3"]
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/enumeration_spec.rb ---
--- START FILE: spec/expressir/model/data_types/integer_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Integer do
  describe ".new" do
    subject(:integer) { described_class.new }

    it "creates an integer type" do
      expect(integer).to be_a described_class
    end
  end

  describe "type compatibility" do
    let(:integer_type) { described_class.new }
    let(:real_type) { Expressir::Model::DataTypes::Real.new }
    let(:number_type) { Expressir::Model::DataTypes::Number.new }
    let(:string_type) { Expressir::Model::DataTypes::String.new }

    it "is compatible with itself" do
      expect(integer_type).to be_a described_class
    end

    it "is assignable to real" do
      # In EXPRESS, INTEGER is compatible with REAL
      expect(real_type).to be_a Expressir::Model::DataTypes::Real
    end

    it "is assignable to number" do
      # In EXPRESS, INTEGER is compatible with NUMBER
      expect(number_type).to be_a Expressir::Model::DataTypes::Number
    end

    it "is not compatible with string" do
      # In EXPRESS, INTEGER is not compatible with STRING
      expect(string_type).not_to be_a described_class
    end
  end

  describe "value range" do
    let(:min_value) { Expressir::Model::Literals::Integer.new(value: "-2147483648") }
    let(:max_value) { Expressir::Model::Literals::Integer.new(value: "2147483647") }
    let(:out_of_range_value) { Expressir::Model::Literals::Integer.new(value: "9999999999999999999") }

    it "accepts values within range" do
      expect(min_value.value).to eq "-2147483648"
      expect(max_value.value).to eq "2147483647"
    end

    it "handles boundary cases" do
      expect(min_value.value.to_i).to be <= 2147483647
      expect(max_value.value.to_i).to be >= -2147483648
    end

    # Test for potential overflow handling
    it "maintains precision for large values" do
      expect(out_of_range_value.value).to eq "9999999999999999999"
    end
  end
end
--- END FILE: spec/expressir/model/data_types/integer_spec.rb ---
--- START FILE: spec/expressir/model/data_types/logical_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Logical do
  describe ".new" do
    subject(:logical) { described_class.new }

    it "creates a logical type" do
      expect(logical).to be_a described_class
    end
  end

  describe "tristate behavior" do
    let(:true_value) { Expressir::Model::Literals::Logical.new(value: :TRUE) }
    let(:false_value) { Expressir::Model::Literals::Logical.new(value: :FALSE) }
    let(:unknown_value) { Expressir::Model::Literals::Logical.new(value: :UNKNOWN) }

    context "with UNKNOWN values" do
      it "handles UNKNOWN in AND operations" do
        and_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :AND,
          operand1: unknown_value,
          operand2: true_value,
        )
        expect(and_expr.operand1.value).to eq :UNKNOWN
      end

      it "handles UNKNOWN in OR operations" do
        or_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :OR,
          operand1: unknown_value,
          operand2: false_value,
        )
        expect(or_expr.operand1.value).to eq :UNKNOWN
      end

      it "handles NOT of UNKNOWN" do
        not_expr = Expressir::Model::Expressions::UnaryExpression.new(
          operator: :NOT,
          operand: unknown_value,
        )
        expect(not_expr.operand.value).to eq :UNKNOWN
      end
    end
  end

  describe "type compatibility" do
    let(:logical_type) { described_class.new }
    let(:boolean_type) { Expressir::Model::DataTypes::Boolean.new }

    it "is not equivalent to boolean" do
      expect(logical_type).not_to be_a Expressir::Model::DataTypes::Boolean
    end

    it "cannot be directly assigned to boolean" do
      # In EXPRESS, LOGICAL cannot be directly assigned to BOOLEAN
      expect(logical_type).not_to be_a Expressir::Model::DataTypes::Boolean
    end
  end

  describe "edge cases" do
    let(:unknown_value) { Expressir::Model::Literals::Logical.new(value: :UNKNOWN) }

    context "when used in conditions" do
      it "handles UNKNOWN in where rules" do
        where_rule = Expressir::Model::Declarations::WhereRule.new(
          id: "test_rule",
          expression: unknown_value,
        )
        expect(where_rule.expression.value).to eq :UNKNOWN
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/logical_spec.rb ---
--- START FILE: spec/expressir/model/data_types/number_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Number do
  describe ".new" do
    subject(:number) { described_class.new }

    it "creates a number type" do
      expect(number).to be_a described_class
    end
  end

  describe "type compatibility" do
    let(:number_type) { described_class.new }
    let(:integer_type) { Expressir::Model::DataTypes::Integer.new }
    let(:real_type) { Expressir::Model::DataTypes::Real.new }

    it "is compatible with integer values" do
      # In EXPRESS, NUMBER can accept INTEGER values
      expect(integer_type).to be_a Expressir::Model::DataTypes::Integer
    end

    it "is compatible with real values" do
      # In EXPRESS, NUMBER can accept REAL values
      expect(real_type).to be_a Expressir::Model::DataTypes::Real
    end
  end

  describe "arithmetic operations" do
    let(:number_type) { described_class.new }

    context "when used in expressions" do
      let(:integer_value) { Expressir::Model::Literals::Integer.new(value: "5") }
      let(:real_value) { Expressir::Model::Literals::Real.new(value: "5.5") }

      it "handles mixed-type arithmetic" do
        add_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :ADDITION,
          operand1: integer_value,
          operand2: real_value,
        )
        expect(add_expr.operator).to eq :ADDITION
        expect(add_expr.operand1.value).to eq "5"
        expect(add_expr.operand2.value).to eq "5.5"
      end
    end
  end

  describe "edge cases" do
    context "with extreme values" do
      let(:max_integer) { Expressir::Model::Literals::Integer.new(value: "2147483647") }
      let(:min_integer) { Expressir::Model::Literals::Integer.new(value: "-2147483648") }
      let(:large_real) { Expressir::Model::Literals::Real.new(value: "1.7976931348623157E+308") }
      let(:small_real) { Expressir::Model::Literals::Real.new(value: "2.2250738585072014E-308") }

      it "handles maximum integer values" do
        expect(max_integer.value).to eq "2147483647"
        expect(min_integer.value).to eq "-2147483648"
      end

      it "handles extreme real values" do
        expect(large_real.value).to eq "1.7976931348623157E+308"
        expect(small_real.value).to eq "2.2250738585072014E-308"
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/number_spec.rb ---
--- START FILE: spec/expressir/model/data_types/real_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Real do
  describe ".new" do
    subject(:real) do
      described_class.new(
        precision: precision,
      )
    end

    let(:precision) { Expressir::Model::Literals::Integer.new(value: "15") }

    it "creates a real type" do
      expect(real).to be_a described_class
      expect(real.precision.value).to eq "15"
    end
  end

  describe "precision handling" do
    context "with different precision values" do
      let(:zero_precision) { described_class.new(precision: Expressir::Model::Literals::Integer.new(value: "0")) }
      let(:high_precision) { described_class.new(precision: Expressir::Model::Literals::Integer.new(value: "30")) }
      let(:negative_precision) { described_class.new(precision: Expressir::Model::Literals::Integer.new(value: "-1")) }

      it "handles zero precision" do
        expect(zero_precision.precision.value).to eq "0"
      end

      it "handles high precision" do
        expect(high_precision.precision.value).to eq "30"
      end

      it "handles negative precision" do
        expect(negative_precision.precision.value).to eq "-1"
      end
    end
  end

  describe "type compatibility" do
    let(:real_type) { described_class.new }
    let(:integer_type) { Expressir::Model::DataTypes::Integer.new }
    let(:number_type) { Expressir::Model::DataTypes::Number.new }

    it "is compatible with number type" do
      expect(number_type).to be_a Expressir::Model::DataTypes::Number
    end

    it "can accept integer values" do
      expect(integer_type).to be_a Expressir::Model::DataTypes::Integer
    end
  end

  describe "edge cases" do
    context "with extreme values" do
      let(:max_value) { Expressir::Model::Literals::Real.new(value: "1.7976931348623157E+308") }
      let(:min_value) { Expressir::Model::Literals::Real.new(value: "2.2250738585072014E-308") }
      let(:zero) { Expressir::Model::Literals::Real.new(value: "0.0") }
      let(:negative_zero) { Expressir::Model::Literals::Real.new(value: "-0.0") }

      it "handles maximum values" do
        expect(max_value.value).to eq "1.7976931348623157E+308"
      end

      it "handles minimum values" do
        expect(min_value.value).to eq "2.2250738585072014E-308"
      end

      it "handles zero values" do
        expect(zero.value).to eq "0.0"
        expect(negative_zero.value).to eq "-0.0"
      end
    end

    context "with special cases" do
      let(:scientific_notation) { Expressir::Model::Literals::Real.new(value: "1.23E-4") }
      let(:trailing_zeros) { Expressir::Model::Literals::Real.new(value: "1.230000") }
      let(:leading_zeros) { Expressir::Model::Literals::Real.new(value: "00123.45") }

      it "handles scientific notation" do
        expect(scientific_notation.value).to eq "1.23E-4"
      end

      it "preserves trailing zeros" do
        expect(trailing_zeros.value).to eq "1.230000"
      end

      it "handles leading zeros" do
        expect(leading_zeros.value).to eq "00123.45"
      end
    end
  end

  describe "arithmetic operations" do
    let(:value1) { Expressir::Model::Literals::Real.new(value: "1.5") }
    let(:value2) { Expressir::Model::Literals::Real.new(value: "2.5") }

    it "handles basic arithmetic expressions" do
      add_expr = Expressir::Model::Expressions::BinaryExpression.new(
        operator: :ADDITION,
        operand1: value1,
        operand2: value2,
      )
      expect(add_expr.operator).to eq :ADDITION
      expect(add_expr.operand1.value).to eq "1.5"
      expect(add_expr.operand2.value).to eq "2.5"

      mult_expr = Expressir::Model::Expressions::BinaryExpression.new(
        operator: :MULTIPLICATION,
        operand1: value1,
        operand2: value2,
      )
      expect(mult_expr.operator).to eq :MULTIPLICATION
      expect(mult_expr.operand1.value).to eq "1.5"
      expect(mult_expr.operand2.value).to eq "2.5"
    end
  end
end
--- END FILE: spec/expressir/model/data_types/real_spec.rb ---
--- START FILE: spec/expressir/model/data_types/set_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::Set do
  describe ".new" do
    subject(:set) do
      described_class.new(
        bound1: bound1,
        bound2: bound2,
        base_type: base_type,
      )
    end

    let(:bound1) { Expressir::Model::Literals::Integer.new(value: "1") }
    let(:bound2) { Expressir::Model::Literals::Integer.new(value: "10") }
    let(:base_type) { Expressir::Model::DataTypes::String.new }

    it "creates a set type" do
      expect(set).to be_a described_class
      expect(set.bound1.value).to eq "1"
      expect(set.bound2.value).to eq "10"
      expect(set.base_type).to be_a Expressir::Model::DataTypes::String
    end
  end

  describe "set characteristics" do
    context "with different bounds" do
      let(:unbounded_set) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:zero_bound_set) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "0"),
          bound2: Expressir::Model::Literals::Integer.new(value: "0"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:single_element_set) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "1"),
          bound2: Expressir::Model::Literals::Integer.new(value: "1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles unbounded sets" do
        expect(unbounded_set.bound1).to be_nil
        expect(unbounded_set.bound2).to be_nil
      end

      it "handles zero-sized sets" do
        expect(zero_bound_set.bound1.value).to eq "0"
        expect(zero_bound_set.bound2.value).to eq "0"
      end

      it "handles single-element sets" do
        expect(single_element_set.bound1.value).to eq "1"
        expect(single_element_set.bound2.value).to eq "1"
      end
    end
  end

  describe "set operations" do
    let(:integer_set) do
      described_class.new(
        base_type: Expressir::Model::DataTypes::Integer.new,
      )
    end

    context "when initializing sets" do
      let(:empty_set) { Expressir::Model::Expressions::AggregateInitializer.new(items: []) }
      let(:single_item_set) do
        Expressir::Model::Expressions::AggregateInitializer.new(
          items: [Expressir::Model::Literals::Integer.new(value: "1")],
        )
      end

      it "handles empty set initialization" do
        expect(empty_set.items).to be_empty
      end

      it "handles single item initialization" do
        expect(single_item_set.items.length).to eq 1
        expect(single_item_set.items.first.value).to eq "1"
      end
    end
  end

  describe "edge cases" do
    context "with invalid bounds" do
      let(:reversed_bounds_set) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "10"),
          bound2: Expressir::Model::Literals::Integer.new(value: "1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:negative_bounds_set) do
        described_class.new(
          bound1: Expressir::Model::Literals::Integer.new(value: "-5"),
          bound2: Expressir::Model::Literals::Integer.new(value: "-1"),
          base_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles reversed bounds" do
        expect(reversed_bounds_set.bound1.value).to eq "10"
        expect(reversed_bounds_set.bound2.value).to eq "1"
      end

      it "handles negative bounds" do
        expect(negative_bounds_set.bound1.value).to eq "-5"
        expect(negative_bounds_set.bound2.value).to eq "-1"
      end
    end

    context "with complex base types" do
      let(:set_of_sets) do
        described_class.new(
          base_type: described_class.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
          ),
        )
      end

      let(:set_of_arrays) do
        described_class.new(
          base_type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
          ),
        )
      end

      it "handles nested set types" do
        expect(set_of_sets.base_type).to be_a described_class
        expect(set_of_sets.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles sets of arrays" do
        expect(set_of_arrays.base_type).to be_a Expressir::Model::DataTypes::Array
        expect(set_of_arrays.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/set_spec.rb ---
--- START FILE: spec/expressir/model/data_types/string_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::DataTypes::String do
  describe ".new" do
    subject(:string) do
      described_class.new(
        width: width,
        fixed: fixed,
      )
    end

    let(:width) { Expressir::Model::Literals::Integer.new(value: "10") }
    let(:fixed) { true }

    it "creates a string type" do
      expect(string).to be_a described_class
      expect(string.width.value).to eq "10"
      expect(string.fixed).to be true
    end
  end

  describe "string constraints" do
    context "with fixed width" do
      let(:fixed_string) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "5"),
          fixed: true,
        )
      end

      let(:variable_string) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "5"),
          fixed: false,
        )
      end

      it "enforces fixed width constraint" do
        expect(fixed_string.width.value).to eq "5"
        expect(fixed_string.fixed).to be true
      end

      it "allows variable width up to maximum" do
        expect(variable_string.width.value).to eq "5"
        expect(variable_string.fixed).to be false
      end
    end

    context "with edge cases" do
      let(:zero_width) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "0"),
          fixed: true,
        )
      end

      let(:large_width) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "2147483647"),
          fixed: true,
        )
      end

      let(:negative_width) do
        described_class.new(
          width: Expressir::Model::Literals::Integer.new(value: "-1"),
          fixed: true,
        )
      end

      it "handles zero width" do
        expect(zero_width.width.value).to eq "0"
      end

      it "handles maximum width" do
        expect(large_width.width.value).to eq "2147483647"
      end

      it "handles negative width" do
        expect(negative_width.width.value).to eq "-1"
      end
    end
  end

  describe "string operations" do
    let(:string_type) { described_class.new }

    context "when used in expressions" do
      let(:string1) { Expressir::Model::Literals::String.new(value: "test") }
      let(:string2) { Expressir::Model::Literals::String.new(value: "TEST") }

      it "handles string concatenation" do
        concat_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :COMBINE,
          operand1: string1,
          operand2: string2,
        )
        expect(concat_expr.operator).to eq :COMBINE
        expect(concat_expr.operand1.value).to eq "test"
        expect(concat_expr.operand2.value).to eq "TEST"
      end

      it "handles LIKE operations" do
        like_expr = Expressir::Model::Expressions::BinaryExpression.new(
          operator: :LIKE,
          operand1: string1,
          operand2: string2,
        )
        expect(like_expr.operator).to eq :LIKE
      end
    end
  end

  describe "character encoding" do
    context "with special characters" do
      let(:unicode_string) { Expressir::Model::Literals::String.new(value: "αβγδε") }
      let(:escaped_string) { Expressir::Model::Literals::String.new(value: "line1\nline2") }
      let(:empty_string) { Expressir::Model::Literals::String.new(value: "") }

      it "handles Unicode characters" do
        expect(unicode_string.value).to eq "αβγδε"
      end

      it "handles escape sequences" do
        expect(escaped_string.value).to eq "line1\nline2"
      end

      it "handles empty strings" do
        expect(empty_string.value).to eq ""
      end
    end
  end
end
--- END FILE: spec/expressir/model/data_types/string_spec.rb ---
--- START FILE: spec/expressir/model/declarations/attribute_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Attribute do
  describe ".new" do
    subject(:attribute) do
      described_class.new(
        id: id,
        kind: kind,
        supertype_attribute: supertype_attribute,
        optional: optional,
        type: type,
        expression: expression,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_attribute" }
    let(:kind) { described_class::EXPLICIT }
    let(:supertype_attribute) { nil }
    let(:optional) { true }
    let(:type) { Expressir::Model::DataTypes::String.new }
    let(:expression) { nil }
    let(:remarks) { ["Test remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates an explicit attribute" do
      expect(attribute).to be_a described_class
      expect(attribute.id).to eq "test_attribute"
      expect(attribute.kind).to eq :EXPLICIT
      expect(attribute.optional).to be true
      expect(attribute.type).to be_a Expressir::Model::DataTypes::String
      expect(attribute.remarks).to eq ["Test remark"]
    end
  end

  describe "attribute kinds" do
    context "with different kinds" do
      let(:explicit_attr) do
        described_class.new(
          id: "explicit_attr",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:derived_attr) do
        described_class.new(
          id: "derived_attr",
          kind: described_class::DERIVED,
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      let(:inverse_attr) do
        described_class.new(
          id: "inverse_attr",
          kind: described_class::INVERSE,
          type: Expressir::Model::DataTypes::String.new,
          expression: Expressir::Model::References::SimpleReference.new(id: "other_attr"),
        )
      end

      it "handles explicit attributes" do
        expect(explicit_attr.kind).to eq :EXPLICIT
        expect(explicit_attr.expression).to be_nil
      end

      it "handles derived attributes" do
        expect(derived_attr.kind).to eq :DERIVED
        expect(derived_attr.expression.value).to eq "42"
      end

      it "handles inverse attributes" do
        expect(inverse_attr.kind).to eq :INVERSE
        expect(inverse_attr.expression.id).to eq "other_attr"
      end
    end
  end

  describe "type handling" do
    context "with different types" do
      let(:simple_type_attr) do
        described_class.new(
          id: "simple_attr",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:array_type_attr) do
        described_class.new(
          id: "array_attr",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
            bound1: Expressir::Model::Literals::Integer.new(value: "1"),
            bound2: Expressir::Model::Literals::Integer.new(value: "10"),
          ),
        )
      end

      let(:enum_type_attr) do
        described_class.new(
          id: "enum_attr",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::Enumeration.new(
            items: [
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
            ],
          ),
        )
      end

      it "handles simple types" do
        expect(simple_type_attr.type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles array types" do
        expect(array_type_attr.type).to be_a Expressir::Model::DataTypes::Array
        expect(array_type_attr.type.base_type).to be_a Expressir::Model::DataTypes::Integer
        expect(array_type_attr.type.bound1.value).to eq "1"
        expect(array_type_attr.type.bound2.value).to eq "10"
      end

      it "handles enumeration types" do
        expect(enum_type_attr.type).to be_a Expressir::Model::DataTypes::Enumeration
        expect(enum_type_attr.type.items.map(&:id)).to eq ["ITEM1", "ITEM2"]
      end
    end
  end

  describe "inheritance handling" do
    context "with supertype attributes" do
      let(:supertype_ref) do
        Expressir::Model::References::AttributeReference.new(
          ref: Expressir::Model::References::GroupReference.new(
            ref: Expressir::Model::References::SimpleReference.new(id: "SELF"),
            entity: Expressir::Model::References::SimpleReference.new(id: "parent_entity"),
          ),
          attribute: Expressir::Model::References::SimpleReference.new(id: "parent_attr"),
        )
      end

      let(:redeclared_attr) do
        described_class.new(
          kind: described_class::EXPLICIT,
          supertype_attribute: supertype_ref,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:renamed_attr) do
        described_class.new(
          id: "new_name",
          kind: described_class::EXPLICIT,
          supertype_attribute: supertype_ref,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles redeclared attributes" do
        expect(redeclared_attr.supertype_attribute).to eq supertype_ref
        expect(redeclared_attr.supertype_attribute.attribute.id).to eq "parent_attr"
      end

      it "handles renamed attributes" do
        expect(renamed_attr.id).to eq "new_name"
        expect(renamed_attr.supertype_attribute.attribute.id).to eq "parent_attr"
      end
    end
  end

  describe "edge cases" do
    context "with invalid configurations" do
      let(:no_type_attr) do
        described_class.new(
          id: "no_type",
          kind: described_class::EXPLICIT,
        )
      end

      let(:derived_no_expr_attr) do
        described_class.new(
          id: "derived_no_expr",
          kind: described_class::DERIVED,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:explicit_with_expr_attr) do
        described_class.new(
          id: "explicit_with_expr",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      it "handles missing type" do
        expect(no_type_attr.type).to be_nil
      end

      it "handles derived attribute without expression" do
        expect(derived_no_expr_attr.expression).to be_nil
      end

      it "handles explicit attribute with expression" do
        expect(explicit_with_expr_attr.expression.value).to eq "42"
      end
    end

    context "with unusual values" do
      let(:empty_id_attr) do
        described_class.new(
          id: "",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:long_id_attr) do
        described_class.new(
          id: "a" * 100,
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:special_chars_attr) do
        described_class.new(
          id: "attr_with_$pecial_chars",
          kind: described_class::EXPLICIT,
          type: Expressir::Model::DataTypes::String.new,
        )
      end

      it "handles empty identifier" do
        expect(empty_id_attr.id).to eq ""
      end

      it "handles long identifier" do
        expect(long_id_attr.id.length).to eq 100
      end

      it "handles special characters in identifier" do
        expect(special_chars_attr.id).to eq "attr_with_$pecial_chars"
      end
    end
  end

  describe "#children" do
    let(:attribute) do
      described_class.new(
        id: "test_attr",
        kind: described_class::EXPLICIT,
        type: Expressir::Model::DataTypes::String.new,
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns remark items" do
      expect(attribute.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2"),
      )
    end
  end
end
--- END FILE: spec/expressir/model/declarations/attribute_spec.rb ---
--- START FILE: spec/expressir/model/declarations/constant_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Constant do
  describe ".new" do
    subject(:constant) do
      described_class.new(
        id: id,
        type: type,
        expression: expression,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "TEST_CONSTANT" }
    let(:type) { Expressir::Model::DataTypes::Integer.new }
    let(:expression) { Expressir::Model::Literals::Integer.new(value: "42") }
    let(:remarks) { ["Test constant remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a constant" do
      expect(constant).to be_a described_class
      expect(constant.id).to eq "TEST_CONSTANT"
      expect(constant.type).to be_a Expressir::Model::DataTypes::Integer
      expect(constant.expression.value).to eq "42"
      expect(constant.remarks).to eq ["Test constant remark"]
    end
  end

  describe "type compatibility" do
    context "with different type and expression combinations" do
      let(:integer_constant) do
        described_class.new(
          id: "INT_CONST",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      let(:real_constant) do
        described_class.new(
          id: "REAL_CONST",
          type: Expressir::Model::DataTypes::Real.new,
          expression: Expressir::Model::Literals::Real.new(value: "3.14"),
        )
      end

      let(:string_constant) do
        described_class.new(
          id: "STR_CONST",
          type: Expressir::Model::DataTypes::String.new,
          expression: Expressir::Model::Literals::String.new(value: "test"),
        )
      end

      let(:logical_constant) do
        described_class.new(
          id: "BOOL_CONST",
          type: Expressir::Model::DataTypes::Logical.new,
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      it "handles integer constants" do
        expect(integer_constant.type).to be_a Expressir::Model::DataTypes::Integer
        expect(integer_constant.expression.value).to eq "42"
      end

      it "handles real constants" do
        expect(real_constant.type).to be_a Expressir::Model::DataTypes::Real
        expect(real_constant.expression.value).to eq "3.14"
      end

      it "handles string constants" do
        expect(string_constant.type).to be_a Expressir::Model::DataTypes::String
        expect(string_constant.expression.value).to eq "test"
      end

      it "handles logical constants" do
        expect(logical_constant.type).to be_a Expressir::Model::DataTypes::Logical
        expect(logical_constant.expression.value).to eq :TRUE
      end
    end
  end

  describe "complex expressions" do
    context "with different expression types" do
      let(:arithmetic_constant) do
        described_class.new(
          id: "CALC_CONST",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :ADDITION,
            operand1: Expressir::Model::Literals::Integer.new(value: "5"),
            operand2: Expressir::Model::Literals::Integer.new(value: "3"),
          ),
        )
      end

      let(:function_constant) do
        described_class.new(
          id: "FUNC_CONST",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Expressions::FunctionCall.new(
            function: Expressir::Model::References::SimpleReference.new(id: "ABS"),
            parameters: [Expressir::Model::Literals::Integer.new(value: "-42")],
          ),
        )
      end

      let(:reference_constant) do
        described_class.new(
          id: "REF_CONST",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::References::SimpleReference.new(id: "OTHER_CONST"),
        )
      end

      it "handles arithmetic expressions" do
        expect(arithmetic_constant.expression).to be_a Expressir::Model::Expressions::BinaryExpression
        expect(arithmetic_constant.expression.operator).to eq :ADDITION
        expect(arithmetic_constant.expression.operand1.value).to eq "5"
        expect(arithmetic_constant.expression.operand2.value).to eq "3"
      end

      it "handles function calls" do
        expect(function_constant.expression).to be_a Expressir::Model::Expressions::FunctionCall
        expect(function_constant.expression.function.id).to eq "ABS"
        expect(function_constant.expression.parameters.first.value).to eq "-42"
      end

      it "handles references" do
        expect(reference_constant.expression).to be_a Expressir::Model::References::SimpleReference
        expect(reference_constant.expression.id).to eq "OTHER_CONST"
      end
    end
  end

  describe "edge cases" do
    context "with invalid configurations" do
      let(:missing_type_constant) do
        described_class.new(
          id: "NO_TYPE",
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      let(:missing_expression_constant) do
        described_class.new(
          id: "NO_EXPR",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:empty_id_constant) do
        described_class.new(
          id: "",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      it "handles missing type" do
        expect(missing_type_constant.type).to be_nil
      end

      it "handles missing expression" do
        expect(missing_expression_constant.expression).to be_nil
      end

      it "handles empty identifier" do
        expect(empty_id_constant.id).to eq ""
      end
    end

    context "with unusual values" do
      let(:very_long_id_constant) do
        described_class.new(
          id: "CONST_#{'X' * 100}",
          type: Expressir::Model::DataTypes::String.new,
          expression: Expressir::Model::Literals::String.new(value: "test"),
        )
      end

      let(:special_chars_constant) do
        described_class.new(
          id: "CONST_$PECIAL",
          type: Expressir::Model::DataTypes::String.new,
          expression: Expressir::Model::Literals::String.new(value: "test"),
        )
      end

      let(:unicode_constant) do
        described_class.new(
          id: "CONST_UNICODE",
          type: Expressir::Model::DataTypes::String.new,
          expression: Expressir::Model::Literals::String.new(value: "αβγδε"),
        )
      end

      it "handles very long identifiers" do
        expect(very_long_id_constant.id.length).to be > 100
      end

      it "handles special characters in identifier" do
        expect(special_chars_constant.id).to eq "CONST_$PECIAL"
      end

      it "handles Unicode in expression" do
        expect(unicode_constant.expression.value).to eq "αβγδε"
      end
    end
  end

  describe "scope and visibility" do
    let(:parent_schema) do
      Expressir::Model::Declarations::Schema.new(
        id: "TEST_SCHEMA",
        constants: [
          described_class.new(
            id: "SCHEMA_CONST",
            type: Expressir::Model::DataTypes::Integer.new,
            expression: Expressir::Model::Literals::Integer.new(value: "42"),
          ),
        ],
      )
    end

    let(:parent_function) do
      Expressir::Model::Declarations::Function.new(
        id: "TEST_FUNCTION",
        constants: [
          described_class.new(
            id: "FUNCTION_CONST",
            type: Expressir::Model::DataTypes::Integer.new,
            expression: Expressir::Model::Literals::Integer.new(value: "42"),
          ),
        ],
      )
    end

    it "can be defined in schema scope" do
      expect(parent_schema.constants.first.id).to eq "SCHEMA_CONST"
      expect(parent_schema.constants.first.parent).to eq parent_schema
    end

    it "can be defined in function scope" do
      expect(parent_function.constants.first.id).to eq "FUNCTION_CONST"
      expect(parent_function.constants.first.parent).to eq parent_function
    end
  end

  describe "#children" do
    let(:constant) do
      described_class.new(
        id: "TEST_CONST",
        type: Expressir::Model::DataTypes::Integer.new,
        expression: Expressir::Model::Literals::Integer.new(value: "42"),
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns remark items" do
      expect(constant.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2"),
      )
    end

    context "without remark items" do
      let(:constant_without_remarks) do
        described_class.new(
          id: "TEST_CONST",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      it "returns empty array" do
        expect(constant_without_remarks.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/constant_spec.rb ---
--- START FILE: spec/expressir/model/declarations/entity_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Entity do
  describe ".new" do
    subject(:entity) do
      described_class.new(
        id: id,
        abstract: abstract,
        supertype_expression: supertype_expression,
        subtype_of: subtype_of,
        attributes: attributes,
        unique_rules: unique_rules,
        where_rules: where_rules,
        remarks: remarks,
        remark_items: remark_items,
        informal_propositions: informal_propositions,
      )
    end

    let(:id) { "test_entity" }
    let(:abstract) { true }
    let(:supertype_expression) { nil }
    let(:subtype_of) { [] }
    let(:attributes) { [] }
    let(:unique_rules) { [] }
    let(:where_rules) { [] }
    let(:remarks) { ["Test entity remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end
    let(:informal_propositions) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "IP1", remarks: ["First proposition"]),
      ]
    end

    it "creates an entity" do
      expect(entity).to be_a described_class
      expect(entity.id).to eq "test_entity"
      expect(entity.abstract).to be true
      expect(entity.remarks).to eq ["Test entity remark"]
      expect(entity.informal_propositions.first.remarks).to eq ["First proposition"]
    end
  end

  describe "inheritance hierarchy" do
    context "with different inheritance patterns" do
      let(:base_entity) do
        described_class.new(
          id: "base_entity",
          attributes: [
            Expressir::Model::Declarations::Attribute.new(
              id: "base_attr",
              kind: Expressir::Model::Declarations::Attribute::EXPLICIT,
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
        )
      end

      let(:subtype_entity) do
        described_class.new(
          id: "subtype_entity",
          subtype_of: [
            Expressir::Model::References::SimpleReference.new(id: "base_entity"),
          ],
        )
      end

      let(:multiple_inheritance_entity) do
        described_class.new(
          id: "multiple_inheritance",
          subtype_of: [
            Expressir::Model::References::SimpleReference.new(id: "base_entity"),
            Expressir::Model::References::SimpleReference.new(id: "other_entity"),
          ],
        )
      end

      let(:abstract_supertype_entity) do
        described_class.new(
          id: "abstract_super",
          abstract: true,
          supertype_expression: Expressir::Model::References::SimpleReference.new(id: "subtype_entity"),
        )
      end

      it "handles base entities" do
        expect(base_entity.subtype_of).to be_empty
        expect(base_entity.attributes.first.id).to eq "base_attr"
      end

      it "handles single inheritance" do
        expect(subtype_entity.subtype_of.first.id).to eq "base_entity"
      end

      it "handles multiple inheritance" do
        expect(multiple_inheritance_entity.subtype_of.map(&:id)).to eq ["base_entity", "other_entity"]
      end

      it "handles abstract supertypes" do
        expect(abstract_supertype_entity.abstract).to be true
        expect(abstract_supertype_entity.supertype_expression.id).to eq "subtype_entity"
      end
    end
  end

  describe "attribute handling" do
    context "with different attribute types" do
      let(:entity_with_attributes) do
        described_class.new(
          id: "test_entity",
          attributes: [
            Expressir::Model::Declarations::Attribute.new(
              id: "explicit_attr",
              kind: Expressir::Model::Declarations::Attribute::EXPLICIT,
              type: Expressir::Model::DataTypes::String.new,
            ),
            Expressir::Model::Declarations::Attribute.new(
              id: "derived_attr",
              kind: Expressir::Model::Declarations::Attribute::DERIVED,
              type: Expressir::Model::DataTypes::Integer.new,
              expression: Expressir::Model::Literals::Integer.new(value: "42"),
            ),
            Expressir::Model::Declarations::Attribute.new(
              id: "inverse_attr",
              kind: Expressir::Model::Declarations::Attribute::INVERSE,
              type: Expressir::Model::References::SimpleReference.new(id: "other_entity"),
              expression: Expressir::Model::References::SimpleReference.new(id: "other_attr"),
            ),
          ],
        )
      end

      let(:optional_attributes_entity) do
        described_class.new(
          id: "optional_entity",
          attributes: [
            Expressir::Model::Declarations::Attribute.new(
              id: "optional_attr",
              kind: Expressir::Model::Declarations::Attribute::EXPLICIT,
              optional: true,
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
        )
      end

      it "handles different attribute kinds" do
        expect(entity_with_attributes.attributes.map(&:kind)).to eq [:EXPLICIT, :DERIVED, :INVERSE]
      end

      it "handles explicit attributes" do
        explicit_attr = entity_with_attributes.attributes.first
        expect(explicit_attr.kind).to eq :EXPLICIT
        expect(explicit_attr.type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles derived attributes" do
        derived_attr = entity_with_attributes.attributes[1]
        expect(derived_attr.kind).to eq :DERIVED
        expect(derived_attr.expression.value).to eq "42"
      end

      it "handles inverse attributes" do
        inverse_attr = entity_with_attributes.attributes.last
        expect(inverse_attr.kind).to eq :INVERSE
        expect(inverse_attr.expression.id).to eq "other_attr"
      end

      it "handles optional attributes" do
        expect(optional_attributes_entity.attributes.first.optional).to be true
      end
    end
  end

  describe "rules and constraints" do
    context "with various rules" do
      let(:entity_with_rules) do
        described_class.new(
          id: "rule_entity",
          attributes: [
            Expressir::Model::Declarations::Attribute.new(
              id: "test_attr",
              kind: Expressir::Model::Declarations::Attribute::EXPLICIT,
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
          unique_rules: [
            Expressir::Model::Declarations::UniqueRule.new(
              id: "UR1",
              attributes: [
                Expressir::Model::References::SimpleReference.new(id: "test_attr"),
              ],
            ),
          ],
          where_rules: [
            Expressir::Model::Declarations::WhereRule.new(
              id: "WR1",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
          ],
        )
      end

      let(:multiple_rules_entity) do
        described_class.new(
          id: "multi_rule_entity",
          unique_rules: [
            Expressir::Model::Declarations::UniqueRule.new(id: "UR1"),
            Expressir::Model::Declarations::UniqueRule.new(id: "UR2"),
          ],
          where_rules: [
            Expressir::Model::Declarations::WhereRule.new(id: "WR1"),
            Expressir::Model::Declarations::WhereRule.new(id: "WR2"),
          ],
        )
      end

      it "handles unique rules" do
        expect(entity_with_rules.unique_rules.first.id).to eq "UR1"
        expect(entity_with_rules.unique_rules.first.attributes.first.id).to eq "test_attr"
      end

      it "handles where rules" do
        expect(entity_with_rules.where_rules.first.id).to eq "WR1"
        expect(entity_with_rules.where_rules.first.expression.value).to eq :TRUE
      end

      it "handles multiple rules" do
        expect(multiple_rules_entity.unique_rules.map(&:id)).to eq ["UR1", "UR2"]
        expect(multiple_rules_entity.where_rules.map(&:id)).to eq ["WR1", "WR2"]
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_entity) do
        described_class.new(
          id: "empty_entity",
        )
      end

      let(:circular_inheritance) do
        entity1 = described_class.new(
          id: "entity1",
          subtype_of: [Expressir::Model::References::SimpleReference.new(id: "entity2")],
        )
        entity2 = described_class.new(
          id: "entity2",
          subtype_of: [Expressir::Model::References::SimpleReference.new(id: "entity1")],
        )
        entity1
      end

      let(:complex_supertype_expression) do
        described_class.new(
          id: "complex_super",
          supertype_expression: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
            operator: :AND,
            operand1: Expressir::Model::References::SimpleReference.new(id: "entity1"),
            operand2: Expressir::Model::References::SimpleReference.new(id: "entity2"),
          ),
        )
      end

      it "handles empty entities" do
        expect(empty_entity.attributes).to be_empty
        expect(empty_entity.unique_rules).to be_empty
        expect(empty_entity.where_rules).to be_empty
      end

      it "handles circular inheritance" do
        expect(circular_inheritance.subtype_of.first.id).to eq "entity2"
      end

      it "handles complex supertype expressions" do
        expect(complex_supertype_expression.supertype_expression).to be_a Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
        expect(complex_supertype_expression.supertype_expression.operator).to eq :AND
      end
    end
  end

  describe "#children" do
    let(:entity) do
      described_class.new(
        id: "test_entity",
        attributes: [
          Expressir::Model::Declarations::Attribute.new(id: "attr1"),
          Expressir::Model::Declarations::Attribute.new(id: "attr2"),
        ],
        unique_rules: [
          Expressir::Model::Declarations::UniqueRule.new(id: "UR1"),
        ],
        where_rules: [
          Expressir::Model::Declarations::WhereRule.new(id: "WR1"),
        ],
        informal_propositions: [
          Expressir::Model::Declarations::RemarkItem.new(id: "IP1"),
        ],
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        ],
      )
    end

    it "returns all child elements" do
      children_ids = entity.children.map(&:id)
      expect(children_ids).to contain_exactly(
        "attr1", "attr2", "UR1", "WR1", "IP1", "remark1"
      )
    end

    context "with empty entity" do
      let(:empty_entity) { described_class.new(id: "empty_entity") }

      it "returns empty array for entity without children" do
        expect(empty_entity.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/entity_spec.rb ---
--- START FILE: spec/expressir/model/declarations/function_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Function do
  describe ".new" do
    subject(:function) do
      described_class.new(
        id: id,
        parameters: parameters,
        return_type: return_type,
        types: types,
        entities: entities,
        subtype_constraints: subtype_constraints,
        functions: functions,
        procedures: procedures,
        constants: constants,
        variables: variables,
        statements: statements,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_function" }
    let(:parameters) do
      [
        Expressir::Model::Declarations::Parameter.new(
          id: "param1",
          type: Expressir::Model::DataTypes::Integer.new,
        ),
      ]
    end
    let(:return_type) { Expressir::Model::DataTypes::Boolean.new }
    let(:types) { [] }
    let(:entities) { [] }
    let(:subtype_constraints) { [] }
    let(:functions) { [] }
    let(:procedures) { [] }
    let(:constants) { [] }
    let(:variables) { [] }
    let(:statements) do
      [
        Expressir::Model::Statements::Return.new(
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        ),
      ]
    end
    let(:remarks) { ["Test function remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a function" do
      expect(function).to be_a described_class
      expect(function.id).to eq "test_function"
      expect(function.parameters.first.id).to eq "param1"
      expect(function.return_type).to be_a Expressir::Model::DataTypes::Boolean
      expect(function.statements.first).to be_a Expressir::Model::Statements::Return
      expect(function.remarks).to eq ["Test function remark"]
    end
  end

  describe "parameter handling" do
    context "with different parameter configurations" do
      let(:no_params_function) do
        described_class.new(
          id: "no_params",
          return_type: Expressir::Model::DataTypes::Boolean.new,
        )
      end

      let(:multiple_params_function) do
        described_class.new(
          id: "multi_params",
          parameters: [
            Expressir::Model::Declarations::Parameter.new(
              id: "param1",
              type: Expressir::Model::DataTypes::Integer.new,
            ),
            Expressir::Model::Declarations::Parameter.new(
              id: "param2",
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
          return_type: Expressir::Model::DataTypes::Boolean.new,
        )
      end

      let(:optional_params_function) do
        described_class.new(
          id: "optional_params",
          parameters: [
            Expressir::Model::Declarations::Parameter.new(
              id: "param1",
              type: Expressir::Model::DataTypes::Integer.new,
              var: true,
            ),
          ],
          return_type: Expressir::Model::DataTypes::Boolean.new,
        )
      end

      it "handles functions without parameters" do
        expect(no_params_function.parameters).to be_empty
      end

      it "handles multiple parameters" do
        expect(multiple_params_function.parameters.map(&:id)).to eq ["param1", "param2"]
        expect(multiple_params_function.parameters.first.type).to be_a Expressir::Model::DataTypes::Integer
        expect(multiple_params_function.parameters.last.type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles optional parameters" do
        expect(optional_params_function.parameters.first.var).to be true
      end
    end
  end

  describe "local declarations" do
    context "with different local declarations" do
      let(:function_with_locals) do
        described_class.new(
          id: "func_with_locals",
          return_type: Expressir::Model::DataTypes::Boolean.new,
          types: [
            Expressir::Model::Declarations::Type.new(
              id: "local_type",
              underlying_type: Expressir::Model::DataTypes::String.new,
            ),
          ],
          entities: [
            Expressir::Model::Declarations::Entity.new(
              id: "local_entity",
            ),
          ],
          constants: [
            Expressir::Model::Declarations::Constant.new(
              id: "local_const",
              type: Expressir::Model::DataTypes::Integer.new,
              expression: Expressir::Model::Literals::Integer.new(value: "42"),
            ),
          ],
          variables: [
            Expressir::Model::Declarations::Variable.new(
              id: "local_var",
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
        )
      end

      let(:nested_functions) do
        described_class.new(
          id: "outer_func",
          return_type: Expressir::Model::DataTypes::Boolean.new,
          functions: [
            described_class.new(
              id: "inner_func",
              return_type: Expressir::Model::DataTypes::Integer.new,
            ),
          ],
          procedures: [
            Expressir::Model::Declarations::Procedure.new(
              id: "inner_proc",
            ),
          ],
        )
      end

      it "handles local type declarations" do
        expect(function_with_locals.types.first.id).to eq "local_type"
        expect(function_with_locals.types.first.underlying_type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles local entity declarations" do
        expect(function_with_locals.entities.first.id).to eq "local_entity"
      end

      it "handles local constant declarations" do
        expect(function_with_locals.constants.first.id).to eq "local_const"
        expect(function_with_locals.constants.first.expression.value).to eq "42"
      end

      it "handles local variable declarations" do
        expect(function_with_locals.variables.first.id).to eq "local_var"
        expect(function_with_locals.variables.first.type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles nested functions and procedures" do
        expect(nested_functions.functions.first.id).to eq "inner_func"
        expect(nested_functions.procedures.first.id).to eq "inner_proc"
      end
    end
  end

  describe "statement handling" do
    context "with different statement types" do
      let(:function_with_statements) do
        described_class.new(
          id: "func_with_statements",
          return_type: Expressir::Model::DataTypes::Boolean.new,
          variables: [
            Expressir::Model::Declarations::Variable.new(
              id: "test_var",
              type: Expressir::Model::DataTypes::Boolean.new,
            ),
          ],
          statements: [
            Expressir::Model::Statements::Assignment.new(
              ref: Expressir::Model::References::SimpleReference.new(id: "test_var"),
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
            Expressir::Model::Statements::If.new(
              expression: Expressir::Model::References::SimpleReference.new(id: "test_var"),
              statements: [
                Expressir::Model::Statements::Return.new(
                  expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
                ),
              ],
              else_statements: [
                Expressir::Model::Statements::Return.new(
                  expression: Expressir::Model::Literals::Logical.new(value: :FALSE),
                ),
              ],
            ),
          ],
        )
      end

      let(:complex_statements_function) do
        described_class.new(
          id: "complex_func",
          return_type: Expressir::Model::DataTypes::Integer.new,
          statements: [
            Expressir::Model::Statements::Case.new(
              expression: Expressir::Model::Literals::Integer.new(value: "1"),
              actions: [
                Expressir::Model::Statements::CaseAction.new(
                  labels: [Expressir::Model::Literals::Integer.new(value: "1")],
                  statement: Expressir::Model::Statements::Return.new(
                    expression: Expressir::Model::Literals::Integer.new(value: "42"),
                  ),
                ),
              ],
            ),
            Expressir::Model::Statements::Repeat.new(
              statements: [
                Expressir::Model::Statements::Skip.new,
              ],
            ),
          ],
        )
      end

      it "handles basic statements" do
        expect(function_with_statements.statements.first).to be_a Expressir::Model::Statements::Assignment
        expect(function_with_statements.statements.last).to be_a Expressir::Model::Statements::If
      end

      it "handles complex control flow statements" do
        expect(complex_statements_function.statements.first).to be_a Expressir::Model::Statements::Case
        expect(complex_statements_function.statements.last).to be_a Expressir::Model::Statements::Repeat
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:minimal_function) do
        described_class.new(
          id: "minimal_func",
          return_type: Expressir::Model::DataTypes::Boolean.new,
        )
      end

      let(:empty_body_function) do
        described_class.new(
          id: "empty_body",
          return_type: Expressir::Model::DataTypes::Boolean.new,
          statements: [
            Expressir::Model::Statements::Null.new,
          ],
        )
      end

      let(:complex_return_type) do
        described_class.new(
          id: "complex_return",
          return_type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Set.new(
              base_type: Expressir::Model::DataTypes::String.new,
            ),
          ),
        )
      end

      it "handles minimal function definition" do
        expect(minimal_function.parameters).to be_empty
        expect(minimal_function.statements).to be_empty
      end

      it "handles empty function body" do
        expect(empty_body_function.statements.first).to be_a Expressir::Model::Statements::Null
      end

      it "handles complex return types" do
        expect(complex_return_type.return_type).to be_a Expressir::Model::DataTypes::Array
        expect(complex_return_type.return_type.base_type).to be_a Expressir::Model::DataTypes::Set
        expect(complex_return_type.return_type.base_type.base_type).to be_a Expressir::Model::DataTypes::String
      end
    end
  end

  describe "#children" do
    let(:function) do
      described_class.new(
        id: "test_function",
        parameters: [
          Expressir::Model::Declarations::Parameter.new(id: "param1"),
        ],
        types: [
          Expressir::Model::Declarations::Type.new(id: "type1"),
        ],
        entities: [
          Expressir::Model::Declarations::Entity.new(id: "entity1"),
        ],
        constants: [
          Expressir::Model::Declarations::Constant.new(id: "const1"),
        ],
        variables: [
          Expressir::Model::Declarations::Variable.new(id: "var1"),
        ],
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        ],
      )
    end

    it "returns all child elements" do
      children_ids = function.children.map(&:id)
      expect(children_ids).to contain_exactly(
        "param1", "type1", "entity1", "const1", "var1", "remark1"
      )
    end

    context "with enumeration items" do
      let(:function_with_enum) do
        described_class.new(
          id: "func_with_enum",
          types: [
            Expressir::Model::Declarations::Type.new(
              id: "enum_type",
              underlying_type: Expressir::Model::DataTypes::Enumeration.new(
                items: [
                  Expressir::Model::DataTypes::EnumerationItem.new(id: "ENUM1"),
                  Expressir::Model::DataTypes::EnumerationItem.new(id: "ENUM2"),
                ],
              ),
            ),
          ],
        )
      end

      it "includes enumeration items in children" do
        type = function_with_enum.types.first
        enum_items = type.enumeration_items
        expect(enum_items.map(&:id)).to eq ["ENUM1", "ENUM2"]
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/function_spec.rb ---
--- START FILE: spec/expressir/model/declarations/interface_item_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::InterfaceItem do
  describe ".new" do
    subject(:interface_item) do
      described_class.new(
        ref: ref,
        id: id,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:ref) { Expressir::Model::References::SimpleReference.new(id: "referenced_entity") }
    let(:id) { "local_name" }
    let(:remarks) { ["Test interface item remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates an interface item" do
      expect(interface_item).to be_a described_class
      expect(interface_item.ref.id).to eq "referenced_entity"
      expect(interface_item.id).to eq "local_name"
      expect(interface_item.remarks).to eq ["Test interface item remark"]
      expect(interface_item.remark_items.first.id).to eq "remark1"
    end
  end

  describe "reference handling" do
    context "with different reference types" do
      let(:simple_reference) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
        )
      end

      let(:attribute_reference) do
        described_class.new(
          ref: Expressir::Model::References::AttributeReference.new(
            ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
            attribute: Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ),
        )
      end

      let(:group_reference) do
        described_class.new(
          ref: Expressir::Model::References::GroupReference.new(
            ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
            entity: Expressir::Model::References::SimpleReference.new(id: "group1"),
          ),
        )
      end

      let(:index_reference) do
        described_class.new(
          ref: Expressir::Model::References::IndexReference.new(
            ref: Expressir::Model::References::SimpleReference.new(id: "array1"),
            index: Expressir::Model::Literals::Integer.new(value: "1"),
          ),
        )
      end

      it "handles simple references" do
        expect(simple_reference.ref).to be_a Expressir::Model::References::SimpleReference
        expect(simple_reference.ref.id).to eq "entity1"
      end

      it "handles attribute references" do
        expect(attribute_reference.ref).to be_a Expressir::Model::References::AttributeReference
        expect(attribute_reference.ref.ref.id).to eq "entity1"
        expect(attribute_reference.ref.attribute.id).to eq "attr1"
      end

      it "handles group references" do
        expect(group_reference.ref).to be_a Expressir::Model::References::GroupReference
        expect(group_reference.ref.ref.id).to eq "entity1"
        expect(group_reference.ref.entity.id).to eq "group1"
      end

      it "handles index references" do
        expect(index_reference.ref).to be_a Expressir::Model::References::IndexReference
        expect(index_reference.ref.ref.id).to eq "array1"
        expect(index_reference.ref.index.value).to eq "1"
      end
    end
  end

  describe "naming conventions" do
    context "with different naming patterns" do
      let(:default_name_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "original_name"),
        )
      end

      let(:renamed_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "original_name"),
          id: "new_name",
        )
      end

      let(:case_sensitive_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "OriginalName"),
          id: "NewName",
        )
      end

      let(:special_chars_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "name_with_underscore"),
          id: "local_name_with_underscore",
        )
      end

      it "handles default naming" do
        expect(default_name_item.ref.id).to eq "original_name"
        expect(default_name_item.id).to be_nil
      end

      it "handles renamed items" do
        expect(renamed_item.ref.id).to eq "original_name"
        expect(renamed_item.id).to eq "new_name"
      end

      it "preserves case sensitivity" do
        expect(case_sensitive_item.ref.id).to eq "OriginalName"
        expect(case_sensitive_item.id).to eq "NewName"
      end

      it "handles special characters" do
        expect(special_chars_item.ref.id).to eq "name_with_underscore"
        expect(special_chars_item.id).to eq "local_name_with_underscore"
      end
    end
  end

  describe "remarks handling" do
    context "with different remark patterns" do
      let(:no_remarks_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
        )
      end

      let(:multiple_remarks_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
          remarks: ["First remark", "Second remark"],
          remark_items: [
            Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
            Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
          ],
        )
      end

      let(:multiline_remarks_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
          remarks: ["First line\nSecond line", "Third line\nFourth line"],
        )
      end

      it "handles items without remarks" do
        expect(no_remarks_item.remarks).to be_empty
        expect(no_remarks_item.remark_items).to be_empty
      end

      it "handles multiple remarks" do
        expect(multiple_remarks_item.remarks).to eq ["First remark", "Second remark"]
        expect(multiple_remarks_item.remark_items.map(&:id)).to eq ["remark1", "remark2"]
      end

      it "handles multiline remarks" do
        expect(multiline_remarks_item.remarks).to eq [
             "First line\nSecond line",
             "Third line\nFourth line",
           ]
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:nil_reference_item) do
        described_class.new(
          id: "local_name",
        )
      end

      let(:empty_id_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
          id: "",
        )
      end

      let(:long_names_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "a" * 100),
          id: "b" * 100,
        )
      end

      it "handles missing reference" do
        expect(nil_reference_item.ref).to be_nil
      end

      it "handles empty identifier" do
        expect(empty_id_item.id).to eq ""
      end

      it "handles very long identifiers" do
        expect(long_names_item.ref.id.length).to eq 100
        expect(long_names_item.id.length).to eq 100
      end
    end
  end

  describe "#children" do
    let(:interface_item) do
      described_class.new(
        ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(interface_item.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_item) do
        described_class.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
        )
      end

      it "returns empty array" do
        expect(simple_item.children).to be_empty
      end
    end
  end

  describe "parent-child relationships" do
    let(:parent_interface) do
      Expressir::Model::Declarations::Interface.new(
        kind: Expressir::Model::Declarations::Interface::USE,
        schema: Expressir::Model::References::SimpleReference.new(id: "schema1"),
        items: [
          described_class.new(
            ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
          ),
        ],
      )
    end

    it "establishes correct parent relationship" do
      interface_item = parent_interface.items.first
      expect(interface_item.parent).to eq parent_interface
    end
  end
end
--- END FILE: spec/expressir/model/declarations/interface_item_spec.rb ---
--- START FILE: spec/expressir/model/declarations/parameter_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Parameter do
  describe ".new" do
    subject(:parameter) do
      described_class.new(
        id: id,
        var: var,
        type: type,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_param" }
    let(:var) { true }
    let(:type) { Expressir::Model::DataTypes::Integer.new }
    let(:remarks) { ["Test parameter remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a parameter" do
      expect(parameter).to be_a described_class
      expect(parameter.id).to eq "test_param"
      expect(parameter.var).to be true
      expect(parameter.type).to be_a Expressir::Model::DataTypes::Integer
      expect(parameter.remarks).to eq ["Test parameter remark"]
      expect(parameter.remark_items.first.id).to eq "remark1"
    end
  end

  describe "type handling" do
    context "with different parameter types" do
      let(:simple_type_param) do
        described_class.new(
          id: "simple_param",
          type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:array_type_param) do
        described_class.new(
          id: "array_param",
          type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
            bound1: Expressir::Model::Literals::Integer.new(value: "1"),
            bound2: Expressir::Model::Literals::Integer.new(value: "10"),
          ),
        )
      end

      let(:enum_type_param) do
        described_class.new(
          id: "enum_param",
          type: Expressir::Model::DataTypes::Enumeration.new(
            items: [
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
            ],
          ),
        )
      end

      let(:entity_type_param) do
        described_class.new(
          id: "entity_param",
          type: Expressir::Model::References::SimpleReference.new(id: "SomeEntity"),
        )
      end

      it "handles simple types" do
        expect(simple_type_param.type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles array types" do
        expect(array_type_param.type).to be_a Expressir::Model::DataTypes::Array
        expect(array_type_param.type.base_type).to be_a Expressir::Model::DataTypes::Integer
        expect(array_type_param.type.bound1.value).to eq "1"
        expect(array_type_param.type.bound2.value).to eq "10"
      end

      it "handles enumeration types" do
        expect(enum_type_param.type).to be_a Expressir::Model::DataTypes::Enumeration
        expect(enum_type_param.type.items.map(&:id)).to eq ["ITEM1", "ITEM2"]
      end

      it "handles entity references" do
        expect(entity_type_param.type).to be_a Expressir::Model::References::SimpleReference
        expect(entity_type_param.type.id).to eq "SomeEntity"
      end
    end
  end

  describe "variable parameters" do
    context "with different var settings" do
      let(:var_param) do
        described_class.new(
          id: "var_param",
          var: true,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:non_var_param) do
        described_class.new(
          id: "non_var_param",
          var: false,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:default_var_param) do
        described_class.new(
          id: "default_param",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles variable parameters" do
        expect(var_param.var).to be true
      end

      it "handles non-variable parameters" do
        expect(non_var_param.var).to be false
      end

      it "handles default var setting" do
        expect(default_var_param.var).to be_nil
      end
    end
  end

  describe "function context" do
    let(:parent_function) do
      Expressir::Model::Declarations::Function.new(
        id: "test_function",
        parameters: [
          described_class.new(
            id: "param1",
            type: Expressir::Model::DataTypes::Integer.new,
          ),
          described_class.new(
            id: "param2",
            type: Expressir::Model::DataTypes::String.new,
          ),
        ],
      )
    end

    it "establishes correct parent relationship" do
      params = parent_function.parameters
      expect(params[0].parent).to eq parent_function
      expect(params[1].parent).to eq parent_function
    end

    it "maintains parameter order" do
      params = parent_function.parameters
      expect(params.map(&:id)).to eq ["param1", "param2"]
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:no_type_param) do
        described_class.new(
          id: "no_type_param",
        )
      end

      let(:empty_id_param) do
        described_class.new(
          id: "",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:complex_type_param) do
        described_class.new(
          id: "complex_param",
          type: Expressir::Model::DataTypes::Set.new(
            base_type: Expressir::Model::DataTypes::Array.new(
              base_type: Expressir::Model::DataTypes::String.new,
              bound1: Expressir::Model::Literals::Integer.new(value: "1"),
              bound2: Expressir::Model::Literals::Integer.new(value: "10"),
            ),
          ),
        )
      end

      it "handles missing type" do
        expect(no_type_param.type).to be_nil
      end

      it "handles empty identifier" do
        expect(empty_id_param.id).to eq ""
      end

      it "handles complex nested types" do
        expect(complex_type_param.type).to be_a Expressir::Model::DataTypes::Set
        expect(complex_type_param.type.base_type).to be_a Expressir::Model::DataTypes::Array
        expect(complex_type_param.type.base_type.base_type).to be_a Expressir::Model::DataTypes::String
      end
    end

    context "with special naming patterns" do
      let(:long_name_param) do
        described_class.new(
          id: "a" * 100,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:special_chars_param) do
        described_class.new(
          id: "param_with_$pecial_chars",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:numeric_name_param) do
        described_class.new(
          id: "param123",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles long identifiers" do
        expect(long_name_param.id.length).to eq 100
      end

      it "handles special characters in identifier" do
        expect(special_chars_param.id).to eq "param_with_$pecial_chars"
      end

      it "handles numeric characters in identifier" do
        expect(numeric_name_param.id).to eq "param123"
      end
    end
  end

  describe "#children" do
    let(:parameter) do
      described_class.new(
        id: "test_param",
        type: Expressir::Model::DataTypes::Integer.new,
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(parameter.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_parameter) do
        described_class.new(
          id: "simple_param",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "returns empty array" do
        expect(simple_parameter.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/parameter_spec.rb ---
--- START FILE: spec/expressir/model/declarations/procedure_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Procedure do
  describe ".new" do
    subject(:procedure) do
      described_class.new(
        id: id,
        parameters: parameters,
        types: types,
        entities: entities,
        subtype_constraints: subtype_constraints,
        functions: functions,
        procedures: procedures,
        constants: constants,
        variables: variables,
        statements: statements,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_procedure" }
    let(:parameters) do
      [
        Expressir::Model::Declarations::Parameter.new(
          id: "param1",
          type: Expressir::Model::DataTypes::Integer.new,
        ),
      ]
    end
    let(:types) { [] }
    let(:entities) { [] }
    let(:subtype_constraints) { [] }
    let(:functions) { [] }
    let(:procedures) { [] }
    let(:constants) { [] }
    let(:variables) { [] }
    let(:statements) do
      [
        Expressir::Model::Statements::Assignment.new(
          ref: Expressir::Model::References::SimpleReference.new(id: "param1"),
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        ),
      ]
    end
    let(:remarks) { ["Test procedure remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a procedure" do
      expect(procedure).to be_a described_class
      expect(procedure.id).to eq "test_procedure"
      expect(procedure.parameters.first.id).to eq "param1"
      expect(procedure.statements.first).to be_a Expressir::Model::Statements::Assignment
      expect(procedure.remarks).to eq ["Test procedure remark"]
      expect(procedure.remark_items.first.id).to eq "remark1"
    end
  end

  describe "parameter handling" do
    context "with different parameter configurations" do
      let(:no_params_procedure) do
        described_class.new(
          id: "no_params_proc",
        )
      end

      let(:multiple_params_procedure) do
        described_class.new(
          id: "multi_params_proc",
          parameters: [
            Expressir::Model::Declarations::Parameter.new(
              id: "param1",
              type: Expressir::Model::DataTypes::Integer.new,
            ),
            Expressir::Model::Declarations::Parameter.new(
              id: "param2",
              type: Expressir::Model::DataTypes::String.new,
              var: true,
            ),
          ],
        )
      end

      let(:complex_params_procedure) do
        described_class.new(
          id: "complex_params_proc",
          parameters: [
            Expressir::Model::Declarations::Parameter.new(
              id: "array_param",
              type: Expressir::Model::DataTypes::Array.new(
                base_type: Expressir::Model::DataTypes::Integer.new,
                bound1: Expressir::Model::Literals::Integer.new(value: "1"),
                bound2: Expressir::Model::Literals::Integer.new(value: "10"),
              ),
            ),
          ],
        )
      end

      it "handles procedures without parameters" do
        expect(no_params_procedure.parameters).to be_empty
      end

      it "handles multiple parameters" do
        params = multiple_params_procedure.parameters
        expect(params.map(&:id)).to eq ["param1", "param2"]
        expect(params[0].type).to be_a Expressir::Model::DataTypes::Integer
        expect(params[1].type).to be_a Expressir::Model::DataTypes::String
        expect(params[1].var).to be true
      end

      it "handles complex parameter types" do
        param = complex_params_procedure.parameters.first
        expect(param.type).to be_a Expressir::Model::DataTypes::Array
        expect(param.type.base_type).to be_a Expressir::Model::DataTypes::Integer
        expect(param.type.bound1.value).to eq "1"
        expect(param.type.bound2.value).to eq "10"
      end
    end
  end

  describe "local declarations" do
    context "with various local declarations" do
      let(:procedure_with_locals) do
        described_class.new(
          id: "proc_with_locals",
          types: [
            Expressir::Model::Declarations::Type.new(
              id: "local_type",
              underlying_type: Expressir::Model::DataTypes::String.new,
            ),
          ],
          entities: [
            Expressir::Model::Declarations::Entity.new(
              id: "local_entity",
            ),
          ],
          constants: [
            Expressir::Model::Declarations::Constant.new(
              id: "local_const",
              type: Expressir::Model::DataTypes::Integer.new,
              expression: Expressir::Model::Literals::Integer.new(value: "42"),
            ),
          ],
          variables: [
            Expressir::Model::Declarations::Variable.new(
              id: "local_var",
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
        )
      end

      let(:nested_procedures) do
        described_class.new(
          id: "outer_proc",
          procedures: [
            described_class.new(
              id: "inner_proc",
            ),
          ],
          functions: [
            Expressir::Model::Declarations::Function.new(
              id: "inner_func",
              return_type: Expressir::Model::DataTypes::Integer.new,
            ),
          ],
        )
      end

      it "handles local type declarations" do
        expect(procedure_with_locals.types.first.id).to eq "local_type"
        expect(procedure_with_locals.types.first.underlying_type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles local entity declarations" do
        expect(procedure_with_locals.entities.first.id).to eq "local_entity"
      end

      it "handles local constant declarations" do
        const = procedure_with_locals.constants.first
        expect(const.id).to eq "local_const"
        expect(const.expression.value).to eq "42"
      end

      it "handles local variable declarations" do
        var = procedure_with_locals.variables.first
        expect(var.id).to eq "local_var"
        expect(var.type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles nested procedures and functions" do
        expect(nested_procedures.procedures.first.id).to eq "inner_proc"
        expect(nested_procedures.functions.first.id).to eq "inner_func"
      end
    end
  end

  describe "statement handling" do
    context "with different statement types" do
      let(:procedure_with_statements) do
        described_class.new(
          id: "proc_with_statements",
          variables: [
            Expressir::Model::Declarations::Variable.new(
              id: "test_var",
              type: Expressir::Model::DataTypes::Integer.new,
            ),
          ],
          statements: [
            Expressir::Model::Statements::Assignment.new(
              ref: Expressir::Model::References::SimpleReference.new(id: "test_var"),
              expression: Expressir::Model::Literals::Integer.new(value: "42"),
            ),
            Expressir::Model::Statements::If.new(
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
              statements: [
                Expressir::Model::Statements::Skip.new,
              ],
              else_statements: [
                Expressir::Model::Statements::Null.new,
              ],
            ),
            Expressir::Model::Statements::Repeat.new(
              statements: [
                Expressir::Model::Statements::Assignment.new(
                  ref: Expressir::Model::References::SimpleReference.new(id: "test_var"),
                  expression: Expressir::Model::Literals::Integer.new(value: "0"),
                ),
              ],
              while_expression: Expressir::Model::Literals::Logical.new(value: :FALSE),
            ),
          ],
        )
      end

      it "handles assignment statements" do
        assignment = procedure_with_statements.statements[0]
        expect(assignment).to be_a Expressir::Model::Statements::Assignment
        expect(assignment.ref.id).to eq "test_var"
        expect(assignment.expression.value).to eq "42"
      end

      it "handles conditional statements" do
        if_stmt = procedure_with_statements.statements[1]
        expect(if_stmt).to be_a Expressir::Model::Statements::If
        expect(if_stmt.expression.value).to eq :TRUE
        expect(if_stmt.statements.first).to be_a Expressir::Model::Statements::Skip
        expect(if_stmt.else_statements.first).to be_a Expressir::Model::Statements::Null
      end

      it "handles loop statements" do
        repeat_stmt = procedure_with_statements.statements[2]
        expect(repeat_stmt).to be_a Expressir::Model::Statements::Repeat
        expect(repeat_stmt.statements.first).to be_a Expressir::Model::Statements::Assignment
        expect(repeat_stmt.while_expression.value).to eq :FALSE
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_procedure) do
        described_class.new(
          id: "empty_proc",
        )
      end

      let(:only_remarks_procedure) do
        described_class.new(
          id: "remarks_proc",
          remarks: ["Remark 1", "Remark 2"],
          remark_items: [
            Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
            Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
          ],
        )
      end

      let(:deep_nesting_procedure) do
        described_class.new(
          id: "deep_nested_proc",
          procedures: [
            described_class.new(
              id: "level1",
              procedures: [
                described_class.new(
                  id: "level2",
                ),
              ],
            ),
          ],
        )
      end

      it "handles empty procedures" do
        expect(empty_procedure.parameters).to be_empty
        expect(empty_procedure.statements).to be_empty
      end

      it "handles procedures with only remarks" do
        expect(only_remarks_procedure.remarks).to eq ["Remark 1", "Remark 2"]
        expect(only_remarks_procedure.remark_items.map(&:id)).to eq ["remark1", "remark2"]
      end

      it "handles deeply nested procedures" do
        level1 = deep_nesting_procedure.procedures.first
        level2 = level1.procedures.first
        expect(level1.id).to eq "level1"
        expect(level2.id).to eq "level2"
      end
    end
  end

  describe "#children" do
    let(:procedure) do
      described_class.new(
        id: "test_proc",
        parameters: [
          Expressir::Model::Declarations::Parameter.new(id: "param1"),
        ],
        types: [
          Expressir::Model::Declarations::Type.new(id: "type1"),
        ],
        entities: [
          Expressir::Model::Declarations::Entity.new(id: "entity1"),
        ],
        constants: [
          Expressir::Model::Declarations::Constant.new(id: "const1"),
        ],
        variables: [
          Expressir::Model::Declarations::Variable.new(id: "var1"),
        ],
        procedures: [
          described_class.new(id: "proc1"),
        ],
        functions: [
          Expressir::Model::Declarations::Function.new(id: "func1"),
        ],
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        ],
      )
    end

    it "returns all child elements" do
      children_ids = procedure.children.map(&:id)
      expect(children_ids).to contain_exactly(
        "param1", "type1", "entity1", "const1", "var1",
        "proc1", "func1", "remark1"
      )
    end

    context "with empty procedure" do
      let(:empty_procedure) do
        described_class.new(id: "empty_proc")
      end

      it "returns empty array for procedure without children" do
        expect(empty_procedure.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/procedure_spec.rb ---
--- START FILE: spec/expressir/model/declarations/remark_item_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::RemarkItem do
  describe ".new" do
    subject(:remark_item) do
      described_class.new(
        id: id,
        remarks: remarks,
      )
    end

    let(:id) { "test_remark" }
    let(:remarks) { ["First remark line", "Second remark line"] }

    it "creates a remark item" do
      expect(remark_item).to be_a described_class
      expect(remark_item.id).to eq "test_remark"
      expect(remark_item.remarks).to eq ["First remark line", "Second remark line"]
    end
  end

  describe "remark content handling" do
    context "with different remark formats" do
      let(:single_line_remark) do
        described_class.new(
          id: "single_line",
          remarks: ["Simple single line remark"],
        )
      end

      let(:multiline_remark) do
        described_class.new(
          id: "multiline",
          remarks: [
            "First paragraph\nSecond line of first paragraph",
            "Second paragraph\nSecond line of second paragraph",
          ],
        )
      end

      let(:formatted_remark) do
        described_class.new(
          id: "formatted",
          remarks: [
            "* Bullet point 1",
            "* Bullet point 2",
            "1. Numbered item",
            "2. Another numbered item",
          ],
        )
      end

      let(:special_chars_remark) do
        described_class.new(
          id: "special_chars",
          remarks: [
            "Special characters: !@#$%^&*()",
            "Unicode: αβγδε",
            "Symbols: ©®™",
          ],
        )
      end

      it "handles single line remarks" do
        expect(single_line_remark.remarks).to eq ["Simple single line remark"]
      end

      it "handles multiline remarks" do
        expect(multiline_remark.remarks).to eq [
             "First paragraph\nSecond line of first paragraph",
             "Second paragraph\nSecond line of second paragraph",
           ]
      end

      it "handles formatted remarks" do
        expect(formatted_remark.remarks).to eq [
             "* Bullet point 1",
             "* Bullet point 2",
             "1. Numbered item",
             "2. Another numbered item",
           ]
      end

      it "handles special characters" do
        expect(special_chars_remark.remarks).to eq [
             "Special characters: !@#$%^&*()",
             "Unicode: αβγδε",
             "Symbols: ©®™",
           ]
      end
    end
  end

  describe "identifier handling" do
    context "with different identifier formats" do
      let(:simple_id_remark) do
        described_class.new(
          id: "simple_remark",
          remarks: ["Simple remark"],
        )
      end

      let(:numeric_id_remark) do
        described_class.new(
          id: "remark123",
          remarks: ["Numeric ID remark"],
        )
      end

      let(:special_chars_id_remark) do
        described_class.new(
          id: "remark_with_$pecial_chars",
          remarks: ["Special chars in ID"],
        )
      end

      let(:long_id_remark) do
        described_class.new(
          id: "a" * 100,
          remarks: ["Very long identifier"],
        )
      end

      it "handles simple identifiers" do
        expect(simple_id_remark.id).to eq "simple_remark"
      end

      it "handles numeric identifiers" do
        expect(numeric_id_remark.id).to eq "remark123"
      end

      it "handles special characters in identifiers" do
        expect(special_chars_id_remark.id).to eq "remark_with_$pecial_chars"
      end

      it "handles long identifiers" do
        expect(long_id_remark.id.length).to eq 100
      end
    end
  end

  describe "parent-child relationships" do
    context "with different parent types" do
      let(:parent_entity) do
        Expressir::Model::Declarations::Entity.new(
          id: "test_entity",
          remark_items: [
            described_class.new(id: "entity_remark", remarks: ["Entity remark"]),
          ],
        )
      end

      let(:parent_function) do
        Expressir::Model::Declarations::Function.new(
          id: "test_function",
          remark_items: [
            described_class.new(id: "function_remark", remarks: ["Function remark"]),
          ],
        )
      end

      let(:parent_schema) do
        Expressir::Model::Declarations::Schema.new(
          id: "test_schema",
          remark_items: [
            described_class.new(id: "schema_remark", remarks: ["Schema remark"]),
          ],
        )
      end

      it "establishes correct parent relationship for entity remarks" do
        remark = parent_entity.remark_items.first
        expect(remark.parent).to eq parent_entity
        expect(remark.id).to eq "entity_remark"
      end

      it "establishes correct parent relationship for function remarks" do
        remark = parent_function.remark_items.first
        expect(remark.parent).to eq parent_function
        expect(remark.id).to eq "function_remark"
      end

      it "establishes correct parent relationship for schema remarks" do
        remark = parent_schema.remark_items.first
        expect(remark.parent).to eq parent_schema
        expect(remark.id).to eq "schema_remark"
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_id_remark) do
        described_class.new(
          id: "",
          remarks: ["Remark with empty ID"],
        )
      end

      let(:nil_id_remark) do
        described_class.new(
          remarks: ["Remark with nil ID"],
        )
      end

      let(:empty_remarks_remark) do
        described_class.new(
          id: "empty_remarks",
        )
      end

      let(:empty_strings_remarks) do
        described_class.new(
          id: "empty_strings",
          remarks: ["", "  ", "\n"],
        )
      end

      let(:nil_remarks_remark) do
        described_class.new(
          id: "nil_remarks",
          remarks: nil,
        )
      end

      it "handles empty identifier" do
        expect(empty_id_remark.id).to eq ""
      end

      it "handles nil identifier" do
        expect(nil_id_remark.id).to be_nil
      end

      it "handles empty remarks array" do
        expect(empty_remarks_remark.remarks).to be_empty
      end

      it "handles empty string remarks" do
        expect(empty_strings_remarks.remarks).to eq ["", "  ", "\n"]
      end

      it "handles nil remarks" do
        expect(nil_remarks_remark.remarks).to be_nil
      end
    end
  end

  describe "remark collection handling" do
    context "with multiple remarks in different contexts" do
      let(:multiple_remarks_item) do
        described_class.new(
          id: "multiple_remarks",
          remarks: [
            "First remark",
            "Second remark",
            "Third remark",
          ],
        )
      end

      let(:single_remark_item) do
        described_class.new(
          id: "single_remark",
          remarks: ["Single remark"],
        )
      end

      let(:mixed_content_remarks) do
        described_class.new(
          id: "mixed_content",
          remarks: [
            "Plain text",
            "* Bullet point",
            "Code sample:\n  function example() {\n    return true;\n  }",
            "Regular text again",
          ],
        )
      end

      it "handles multiple remarks" do
        expect(multiple_remarks_item.remarks.length).to eq 3
        expect(multiple_remarks_item.remarks).to eq [
             "First remark",
             "Second remark",
             "Third remark",
           ]
      end

      it "handles single remark" do
        expect(single_remark_item.remarks.length).to eq 1
        expect(single_remark_item.remarks.first).to eq "Single remark"
      end

      it "handles mixed content remarks" do
        expect(mixed_content_remarks.remarks.length).to eq 4
        expect(mixed_content_remarks.remarks[2]).to include("function example()")
      end
    end
  end

  describe "#children" do
    let(:remark_item) do
      described_class.new(
        id: "test_remark",
        remarks: ["Test remark content"],
      )
    end

    it "returns empty array as remark items have no children" do
      expect(remark_item.children).to be_empty
    end
  end
end
--- END FILE: spec/expressir/model/declarations/remark_item_spec.rb ---
--- START FILE: spec/expressir/model/declarations/rule_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Rule do
  describe ".new" do
    subject(:rule) do
      described_class.new(
        id: id,
        expression: expression,
        algorithm: algorithm,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_rule" }
    let(:expression) do
      Expressir::Model::Expressions::BinaryExpression.new(
        operator: :EQUAL,
        operand1: Expressir::Model::References::SimpleReference.new(id: "x"),
        operand2: Expressir::Model::Literals::Integer.new(value: "42"),
      )
    end
    let(:algorithm) { nil }
    let(:remarks) { ["Test rule remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a rule" do
      expect(rule).to be_a described_class
      expect(rule.id).to eq "test_rule"
      expect(rule.expression).to be_a Expressir::Model::Expressions::BinaryExpression
      expect(rule.remarks).to eq ["Test rule remark"]
      expect(rule.remark_items.first.id).to eq "remark1"
    end
  end

  describe "expression handling" do
    context "with different expression types" do
      let(:binary_expression_rule) do
        described_class.new(
          id: "binary_rule",
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :AND,
            operand1: Expressir::Model::Literals::Logical.new(value: :TRUE),
            operand2: Expressir::Model::Literals::Logical.new(value: :TRUE),
          ),
        )
      end

      let(:unary_expression_rule) do
        described_class.new(
          id: "unary_rule",
          expression: Expressir::Model::Expressions::UnaryExpression.new(
            operator: :NOT,
            operand: Expressir::Model::Literals::Logical.new(value: :FALSE),
          ),
        )
      end

      let(:function_call_rule) do
        described_class.new(
          id: "function_rule",
          expression: Expressir::Model::Expressions::FunctionCall.new(
            function: Expressir::Model::References::SimpleReference.new(id: "SIZEOF"),
            parameters: [
              Expressir::Model::References::SimpleReference.new(id: "items"),
            ],
          ),
        )
      end

      it "handles binary expressions" do
        expect(binary_expression_rule.expression).to be_a Expressir::Model::Expressions::BinaryExpression
        expect(binary_expression_rule.expression.operator).to eq :AND
      end

      it "handles unary expressions" do
        expect(unary_expression_rule.expression).to be_a Expressir::Model::Expressions::UnaryExpression
        expect(unary_expression_rule.expression.operator).to eq :NOT
      end

      it "handles function calls" do
        expect(function_call_rule.expression).to be_a Expressir::Model::Expressions::FunctionCall
        expect(function_call_rule.expression.function.id).to eq "SIZEOF"
      end
    end
  end

  describe "algorithm handling" do
    context "with different algorithm implementations" do
      let(:rule_with_algorithm) do
        described_class.new(
          id: "algorithm_rule",
          algorithm: Expressir::Model::Declarations::Algorithm.new(
            statements: [
              Expressir::Model::Statements::Assignment.new(
                ref: Expressir::Model::References::SimpleReference.new(id: "result"),
                expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
              ),
            ],
          ),
        )
      end

      let(:rule_with_complex_algorithm) do
        described_class.new(
          id: "complex_algorithm",
          algorithm: Expressir::Model::Declarations::Algorithm.new(
            variables: [
              Expressir::Model::Declarations::Variable.new(
                id: "temp",
                type: Expressir::Model::DataTypes::Integer.new,
              ),
            ],
            statements: [
              Expressir::Model::Statements::Assignment.new(
                ref: Expressir::Model::References::SimpleReference.new(id: "temp"),
                expression: Expressir::Model::Literals::Integer.new(value: "0"),
              ),
              Expressir::Model::Statements::Return.new(
                expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
              ),
            ],
          ),
        )
      end

      it "handles simple algorithms" do
        expect(rule_with_algorithm.algorithm).to be_a Expressir::Model::Declarations::Algorithm
        expect(rule_with_algorithm.algorithm.statements.first).to be_a Expressir::Model::Statements::Assignment
      end

      it "handles complex algorithms" do
        expect(rule_with_complex_algorithm.algorithm.variables.first.id).to eq "temp"
        expect(rule_with_complex_algorithm.algorithm.statements.length).to eq 2
      end
    end
  end

  describe "parent-child relationships" do
    context "with different parent contexts" do
      let(:parent_entity) do
        Expressir::Model::Declarations::Entity.new(
          id: "test_entity",
          where_rules: [
            described_class.new(
              id: "entity_rule",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
          ],
        )
      end

      let(:parent_schema) do
        Expressir::Model::Declarations::Schema.new(
          id: "test_schema",
          rules: [
            described_class.new(
              id: "schema_rule",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
          ],
        )
      end

      it "establishes correct parent relationship for entity rules" do
        rule = parent_entity.where_rules.first
        expect(rule.parent).to eq parent_entity
      end

      it "establishes correct parent relationship for schema rules" do
        rule = parent_schema.rules.first
        expect(rule.parent).to eq parent_schema
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_rule) do
        described_class.new(
          id: "empty_rule",
        )
      end

      let(:expression_only_rule) do
        described_class.new(
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      let(:algorithm_only_rule) do
        described_class.new(
          algorithm: Expressir::Model::Declarations::Algorithm.new(
            statements: [Expressir::Model::Statements::Null.new],
          ),
        )
      end

      let(:complex_nested_expression) do
        described_class.new(
          id: "complex_rule",
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :AND,
            operand1: Expressir::Model::Expressions::BinaryExpression.new(
              operator: :EQUAL,
              operand1: Expressir::Model::References::SimpleReference.new(id: "x"),
              operand2: Expressir::Model::Literals::Integer.new(value: "1"),
            ),
            operand2: Expressir::Model::Expressions::UnaryExpression.new(
              operator: :NOT,
              operand: Expressir::Model::Expressions::BinaryExpression.new(
                operator: :LESS_THAN,
                operand1: Expressir::Model::References::SimpleReference.new(id: "y"),
                operand2: Expressir::Model::Literals::Integer.new(value: "0"),
              ),
            ),
          ),
        )
      end

      it "handles empty rules" do
        expect(empty_rule.expression).to be_nil
        expect(empty_rule.algorithm).to be_nil
      end

      it "handles expression-only rules" do
        expect(expression_only_rule.id).to be_nil
        expect(expression_only_rule.expression).to be_a Expressir::Model::Literals::Logical
      end

      it "handles algorithm-only rules" do
        expect(algorithm_only_rule.id).to be_nil
        expect(algorithm_only_rule.algorithm).to be_a Expressir::Model::Declarations::Algorithm
      end

      it "handles complex nested expressions" do
        expect(complex_nested_expression.expression).to be_a Expressir::Model::Expressions::BinaryExpression
        expect(complex_nested_expression.expression.operator).to eq :AND
        expect(complex_nested_expression.expression.operand2).to be_a Expressir::Model::Expressions::UnaryExpression
      end
    end
  end

  describe "#children" do
    let(:rule) do
      described_class.new(
        id: "test_rule",
        expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        algorithm: Expressir::Model::Declarations::Algorithm.new(
          statements: [Expressir::Model::Statements::Null.new],
        ),
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(rule.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_rule) do
        described_class.new(
          id: "simple_rule",
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      it "returns empty array" do
        expect(simple_rule.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/rule_spec.rb ---
--- START FILE: spec/expressir/model/declarations/schema_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Schema do
  describe ".new" do
    subject(:schema) do
      described_class.new(
        id: id,
        version: version,
        interfaces: interfaces,
        types: types,
        entities: entities,
        subtype_constraints: subtype_constraints,
        functions: functions,
        procedures: procedures,
        rules: rules,
        constants: constants,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_schema" }
    let(:version) { "1.0" }
    let(:interfaces) do
      [
        Expressir::Model::Declarations::Interface.new(
          kind: Expressir::Model::Declarations::Interface::USE,
          schema: Expressir::Model::References::SimpleReference.new(id: "other_schema"),
        ),
      ]
    end
    let(:types) do
      [
        Expressir::Model::Declarations::Type.new(
          id: "custom_type",
          underlying_type: Expressir::Model::DataTypes::String.new,
        ),
      ]
    end
    let(:entities) do
      [
        Expressir::Model::Declarations::Entity.new(
          id: "test_entity",
        ),
      ]
    end
    let(:subtype_constraints) { [] }
    let(:functions) do
      [
        Expressir::Model::Declarations::Function.new(
          id: "test_function",
          return_type: Expressir::Model::DataTypes::Boolean.new,
        ),
      ]
    end
    let(:procedures) do
      [
        Expressir::Model::Declarations::Procedure.new(
          id: "test_procedure",
        ),
      ]
    end
    let(:rules) do
      [
        Expressir::Model::Declarations::Rule.new(
          id: "test_rule",
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        ),
      ]
    end
    let(:constants) do
      [
        Expressir::Model::Declarations::Constant.new(
          id: "TEST_CONSTANT",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        ),
      ]
    end
    let(:remarks) { ["Test schema remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a schema" do
      expect(schema).to be_a described_class
      expect(schema.id).to eq "test_schema"
      expect(schema.version).to eq "1.0"
      expect(schema.interfaces.first).to be_a Expressir::Model::Declarations::Interface
      expect(schema.types.first.id).to eq "custom_type"
      expect(schema.entities.first.id).to eq "test_entity"
      expect(schema.functions.first.id).to eq "test_function"
      expect(schema.procedures.first.id).to eq "test_procedure"
      expect(schema.rules.first.id).to eq "test_rule"
      expect(schema.constants.first.id).to eq "TEST_CONSTANT"
      expect(schema.remarks).to eq ["Test schema remark"]
      expect(schema.remark_items.first.id).to eq "remark1"
    end
  end

  describe "interface handling" do
    context "with different interface configurations" do
      let(:schema_with_multiple_interfaces) do
        described_class.new(
          id: "multi_interface_schema",
          interfaces: [
            Expressir::Model::Declarations::Interface.new(
              kind: Expressir::Model::Declarations::Interface::USE,
              schema: Expressir::Model::References::SimpleReference.new(id: "schema1"),
            ),
            Expressir::Model::Declarations::Interface.new(
              kind: Expressir::Model::Declarations::Interface::REFERENCE,
              schema: Expressir::Model::References::SimpleReference.new(id: "schema2"),
            ),
          ],
        )
      end

      let(:schema_with_interface_items) do
        described_class.new(
          id: "interface_items_schema",
          interfaces: [
            Expressir::Model::Declarations::Interface.new(
              kind: Expressir::Model::Declarations::Interface::USE,
              schema: Expressir::Model::References::SimpleReference.new(id: "schema1"),
              items: [
                Expressir::Model::Declarations::InterfaceItem.new(
                  ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
                ),
                Expressir::Model::Declarations::InterfaceItem.new(
                  ref: Expressir::Model::References::SimpleReference.new(id: "entity2"),
                  id: "local_name",
                ),
              ],
            ),
          ],
        )
      end

      it "handles multiple interfaces" do
        interfaces = schema_with_multiple_interfaces.interfaces
        expect(interfaces.length).to eq 2
        expect(interfaces[0].kind).to eq :USE
        expect(interfaces[1].kind).to eq :REFERENCE
      end

      it "handles interface items" do
        interface = schema_with_interface_items.interfaces.first
        expect(interface.items.length).to eq 2
        expect(interface.items[0].ref.id).to eq "entity1"
        expect(interface.items[1].id).to eq "local_name"
      end
    end
  end

  describe "versioning" do
    context "with different version formats" do
      let(:unversioned_schema) do
        described_class.new(
          id: "unversioned",
        )
      end

      let(:semantic_versioned_schema) do
        described_class.new(
          id: "semantic",
          version: "2.1.0",
        )
      end

      let(:custom_versioned_schema) do
        described_class.new(
          id: "custom",
          version: "2023a",
        )
      end

      it "handles schemas without version" do
        expect(unversioned_schema.version).to be_nil
      end

      it "handles semantic versioning" do
        expect(semantic_versioned_schema.version).to eq "2.1.0"
      end

      it "handles custom version formats" do
        expect(custom_versioned_schema.version).to eq "2023a"
      end
    end
  end

  describe "declaration handling" do
    context "with different declaration types" do
      let(:schema_with_declarations) do
        described_class.new(
          id: "declaration_schema",
          types: [
            Expressir::Model::Declarations::Type.new(
              id: "custom_type",
              underlying_type: Expressir::Model::DataTypes::String.new,
            ),
          ],
          entities: [
            Expressir::Model::Declarations::Entity.new(
              id: "test_entity",
              attributes: [
                Expressir::Model::Declarations::Attribute.new(
                  id: "attr1",
                  type: Expressir::Model::DataTypes::String.new,
                ),
              ],
            ),
          ],
          constants: [
            Expressir::Model::Declarations::Constant.new(
              id: "MAX_VALUE",
              type: Expressir::Model::DataTypes::Integer.new,
              expression: Expressir::Model::Literals::Integer.new(value: "100"),
            ),
          ],
          functions: [
            Expressir::Model::Declarations::Function.new(
              id: "calculate",
              return_type: Expressir::Model::DataTypes::Integer.new,
              parameters: [
                Expressir::Model::Declarations::Parameter.new(
                  id: "input",
                  type: Expressir::Model::DataTypes::Integer.new,
                ),
              ],
            ),
          ],
        )
      end

      it "handles type declarations" do
        type = schema_with_declarations.types.first
        expect(type.id).to eq "custom_type"
        expect(type.underlying_type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles entity declarations" do
        entity = schema_with_declarations.entities.first
        expect(entity.id).to eq "test_entity"
        expect(entity.attributes.first.id).to eq "attr1"
      end

      it "handles constant declarations" do
        constant = schema_with_declarations.constants.first
        expect(constant.id).to eq "MAX_VALUE"
        expect(constant.expression.value).to eq "100"
      end

      it "handles function declarations" do
        function = schema_with_declarations.functions.first
        expect(function.id).to eq "calculate"
        expect(function.parameters.first.id).to eq "input"
      end
    end
  end

  describe "rule handling" do
    context "with different rule types" do
      let(:schema_with_rules) do
        described_class.new(
          id: "rule_schema",
          rules: [
            Expressir::Model::Declarations::Rule.new(
              id: "simple_rule",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
            Expressir::Model::Declarations::Rule.new(
              id: "complex_rule",
              expression: Expressir::Model::Expressions::BinaryExpression.new(
                operator: :AND,
                operand1: Expressir::Model::Literals::Logical.new(value: :TRUE),
                operand2: Expressir::Model::Literals::Logical.new(value: :TRUE),
              ),
            ),
            Expressir::Model::Declarations::Rule.new(
              id: "algorithm_rule",
              algorithm: Expressir::Model::Declarations::Algorithm.new(
                statements: [
                  Expressir::Model::Statements::Return.new(
                    expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
                  ),
                ],
              ),
            ),
          ],
        )
      end

      it "handles simple rules" do
        rule = schema_with_rules.rules[0]
        expect(rule.id).to eq "simple_rule"
        expect(rule.expression).to be_a Expressir::Model::Literals::Logical
      end

      it "handles complex rules" do
        rule = schema_with_rules.rules[1]
        expect(rule.id).to eq "complex_rule"
        expect(rule.expression).to be_a Expressir::Model::Expressions::BinaryExpression
      end

      it "handles algorithm rules" do
        rule = schema_with_rules.rules[2]
        expect(rule.id).to eq "algorithm_rule"
        expect(rule.algorithm).to be_a Expressir::Model::Declarations::Algorithm
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_schema) do
        described_class.new(
          id: "empty_schema",
        )
      end

      let(:minimal_schema) do
        described_class.new(
          id: "minimal",
        )
      end

      let(:schema_with_circular_references) do
        schema1 = described_class.new(id: "schema1")
        schema2 = described_class.new(
          id: "schema2",
          interfaces: [
            Expressir::Model::Declarations::Interface.new(
              kind: Expressir::Model::Declarations::Interface::USE,
              schema: Expressir::Model::References::SimpleReference.new(id: "schema1"),
            ),
          ],
        )
        schema1.interfaces = [
          Expressir::Model::Declarations::Interface.new(
            kind: Expressir::Model::Declarations::Interface::USE,
            schema: Expressir::Model::References::SimpleReference.new(id: "schema2"),
          ),
        ]
        schema1
      end

      it "handles empty schemas" do
        expect(empty_schema.interfaces).to be_empty
        expect(empty_schema.types).to be_empty
        expect(empty_schema.entities).to be_empty
        expect(empty_schema.rules).to be_empty
      end

      it "handles minimal schemas" do
        expect(minimal_schema.id).to eq "minimal"
        expect(minimal_schema.version).to be_nil
      end

      it "handles circular references" do
        expect(schema_with_circular_references.interfaces.first.schema.id).to eq "schema2"
      end
    end
  end

  describe "#children" do
    let(:schema) do
      described_class.new(
        id: "test_schema",
        interfaces: [
          Expressir::Model::Declarations::Interface.new(id: "interface1"),
        ],
        types: [
          Expressir::Model::Declarations::Type.new(id: "type1"),
        ],
        entities: [
          Expressir::Model::Declarations::Entity.new(id: "entity1"),
        ],
        functions: [
          Expressir::Model::Declarations::Function.new(id: "function1"),
        ],
        procedures: [
          Expressir::Model::Declarations::Procedure.new(id: "procedure1"),
        ],
        rules: [
          Expressir::Model::Declarations::Rule.new(id: "rule1"),
        ],
        constants: [
          Expressir::Model::Declarations::Constant.new(id: "constant1"),
        ],
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
        ],
      )
    end

    it "returns all child elements" do
      children_ids = schema.children.map(&:id)
      expect(children_ids).to contain_exactly(
        "interface1", "type1", "entity1", "function1",
        "procedure1", "rule1", "constant1", "remark1"
      )
    end

    context "with empty schema" do
      let(:empty_schema) do
        described_class.new(id: "empty_schema")
      end

      it "returns empty array for schema without children" do
        expect(empty_schema.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/schema_spec.rb ---
--- START FILE: spec/expressir/model/declarations/subtype_constraint_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::SubtypeConstraint do
  describe ".new" do
    subject(:subtype_constraint) do
      described_class.new(
        id: id,
        abstract_supertype: abstract_supertype,
        abstract_entities: abstract_entities,
        supertype_expression: supertype_expression,
        total_over: total_over,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_constraint" }
    let(:abstract_supertype) { true }
    let(:abstract_entities) do
      [
        Expressir::Model::References::SimpleReference.new(id: "entity1"),
        Expressir::Model::References::SimpleReference.new(id: "entity2"),
      ]
    end
    let(:supertype_expression) do
      Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
        operator: :AND,
        operand1: Expressir::Model::References::SimpleReference.new(id: "entity1"),
        operand2: Expressir::Model::References::SimpleReference.new(id: "entity2"),
      )
    end
    let(:total_over) do
      [
        Expressir::Model::References::SimpleReference.new(id: "entity3"),
      ]
    end
    let(:remarks) { ["Test constraint remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a subtype constraint" do
      expect(subtype_constraint).to be_a described_class
      expect(subtype_constraint.id).to eq "test_constraint"
      expect(subtype_constraint.abstract_supertype).to be true
      expect(subtype_constraint.abstract_entities.map(&:id)).to eq ["entity1", "entity2"]
      expect(subtype_constraint.supertype_expression).to be_a Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      expect(subtype_constraint.total_over.first.id).to eq "entity3"
      expect(subtype_constraint.remarks).to eq ["Test constraint remark"]
      expect(subtype_constraint.remark_items.first.id).to eq "remark1"
    end
  end

  describe "abstract entity handling" do
    context "with different abstract entity configurations" do
      let(:single_abstract_entity) do
        described_class.new(
          id: "single_abstract",
          abstract_entities: [
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
          ],
        )
      end

      let(:multiple_abstract_entities) do
        described_class.new(
          id: "multiple_abstract",
          abstract_entities: [
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
            Expressir::Model::References::SimpleReference.new(id: "entity2"),
            Expressir::Model::References::SimpleReference.new(id: "entity3"),
          ],
        )
      end

      let(:no_abstract_entities) do
        described_class.new(
          id: "no_abstract",
        )
      end

      it "handles single abstract entity" do
        expect(single_abstract_entity.abstract_entities.length).to eq 1
        expect(single_abstract_entity.abstract_entities.first.id).to eq "entity1"
      end

      it "handles multiple abstract entities" do
        expect(multiple_abstract_entities.abstract_entities.length).to eq 3
        expect(multiple_abstract_entities.abstract_entities.map(&:id)).to eq ["entity1", "entity2", "entity3"]
      end

      it "handles no abstract entities" do
        expect(no_abstract_entities.abstract_entities).to be_empty
      end
    end
  end

  describe "supertype expression handling" do
    context "with different supertype expressions" do
      let(:simple_supertype) do
        described_class.new(
          id: "simple_super",
          supertype_expression: Expressir::Model::References::SimpleReference.new(id: "entity1"),
        )
      end

      let(:and_supertype) do
        described_class.new(
          id: "and_super",
          supertype_expression: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
            operator: :AND,
            operand1: Expressir::Model::References::SimpleReference.new(id: "entity1"),
            operand2: Expressir::Model::References::SimpleReference.new(id: "entity2"),
          ),
        )
      end

      let(:or_supertype) do
        described_class.new(
          id: "or_super",
          supertype_expression: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
            operator: :OR,
            operand1: Expressir::Model::References::SimpleReference.new(id: "entity1"),
            operand2: Expressir::Model::References::SimpleReference.new(id: "entity2"),
          ),
        )
      end

      let(:oneof_supertype) do
        described_class.new(
          id: "oneof_super",
          supertype_expression: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
            operator: :ONEOF,
            operand1: Expressir::Model::References::SimpleReference.new(id: "entity1"),
            operand2: Expressir::Model::References::SimpleReference.new(id: "entity2"),
          ),
        )
      end

      it "handles simple supertype references" do
        expect(simple_supertype.supertype_expression).to be_a Expressir::Model::References::SimpleReference
        expect(simple_supertype.supertype_expression.id).to eq "entity1"
      end

      it "handles AND supertype expressions" do
        expect(and_supertype.supertype_expression.operator).to eq :AND
        expect(and_supertype.supertype_expression.operand1.id).to eq "entity1"
        expect(and_supertype.supertype_expression.operand2.id).to eq "entity2"
      end

      it "handles OR supertype expressions" do
        expect(or_supertype.supertype_expression.operator).to eq :OR
        expect(or_supertype.supertype_expression.operand1.id).to eq "entity1"
        expect(or_supertype.supertype_expression.operand2.id).to eq "entity2"
      end

      it "handles ONEOF supertype expressions" do
        expect(oneof_supertype.supertype_expression.operator).to eq :ONEOF
        expect(oneof_supertype.supertype_expression.operand1.id).to eq "entity1"
        expect(oneof_supertype.supertype_expression.operand2.id).to eq "entity2"
      end
    end
  end

  describe "total_over handling" do
    context "with different total_over configurations" do
      let(:single_total) do
        described_class.new(
          id: "single_total",
          total_over: [
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
          ],
        )
      end

      let(:multiple_total) do
        described_class.new(
          id: "multiple_total",
          total_over: [
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
            Expressir::Model::References::SimpleReference.new(id: "entity2"),
          ],
        )
      end

      let(:no_total) do
        described_class.new(
          id: "no_total",
        )
      end

      it "handles single total_over entity" do
        expect(single_total.total_over.length).to eq 1
        expect(single_total.total_over.first.id).to eq "entity1"
      end

      it "handles multiple total_over entities" do
        expect(multiple_total.total_over.length).to eq 2
        expect(multiple_total.total_over.map(&:id)).to eq ["entity1", "entity2"]
      end

      it "handles no total_over entities" do
        expect(no_total.total_over).to be_empty
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_constraint) do
        described_class.new(
          id: "empty_constraint",
        )
      end

      let(:complex_nested_supertype) do
        described_class.new(
          id: "complex_nested",
          supertype_expression: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
            operator: :AND,
            operand1: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression.new(
              operator: :OR,
              operand1: Expressir::Model::References::SimpleReference.new(id: "entity1"),
              operand2: Expressir::Model::References::SimpleReference.new(id: "entity2"),
            ),
            operand2: Expressir::Model::References::SimpleReference.new(id: "entity3"),
          ),
        )
      end

      let(:duplicate_references) do
        described_class.new(
          id: "duplicate_refs",
          abstract_entities: [
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
          ],
          total_over: [
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
            Expressir::Model::References::SimpleReference.new(id: "entity1"),
          ],
        )
      end

      it "handles empty constraints" do
        expect(empty_constraint.abstract_entities).to be_empty
        expect(empty_constraint.supertype_expression).to be_nil
        expect(empty_constraint.total_over).to be_empty
      end

      it "handles complex nested supertype expressions" do
        expr = complex_nested_supertype.supertype_expression
        expect(expr.operator).to eq :AND
        expect(expr.operand1).to be_a Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
        expect(expr.operand1.operator).to eq :OR
      end

      it "handles duplicate references" do
        expect(duplicate_references.abstract_entities.map(&:id)).to eq ["entity1", "entity1"]
        expect(duplicate_references.total_over.map(&:id)).to eq ["entity1", "entity1"]
      end
    end
  end

  describe "#children" do
    let(:subtype_constraint) do
      described_class.new(
        id: "test_constraint",
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(subtype_constraint.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_constraint) do
        described_class.new(
          id: "simple_constraint",
        )
      end

      it "returns empty array" do
        expect(simple_constraint.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/subtype_constraint_spec.rb ---
--- START FILE: spec/expressir/model/declarations/type_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Type do
  describe ".new" do
    subject(:type) do
      described_class.new(
        id: id,
        underlying_type: underlying_type,
        where_rules: where_rules,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_type" }
    let(:underlying_type) { Expressir::Model::DataTypes::String.new }
    let(:where_rules) do
      [
        Expressir::Model::Declarations::WhereRule.new(
          id: "WR1",
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        ),
      ]
    end
    let(:remarks) { ["Test type remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a type" do
      expect(type).to be_a described_class
      expect(type.id).to eq "test_type"
      expect(type.underlying_type).to be_a Expressir::Model::DataTypes::String
      expect(type.where_rules.first.id).to eq "WR1"
      expect(type.remarks).to eq ["Test type remark"]
      expect(type.remark_items.first.id).to eq "remark1"
    end
  end

  describe "underlying type handling" do
    context "with different underlying types" do
      let(:simple_type) do
        described_class.new(
          id: "simple_type",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:array_type) do
        described_class.new(
          id: "array_type",
          underlying_type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
            bound1: Expressir::Model::Literals::Integer.new(value: "1"),
            bound2: Expressir::Model::Literals::Integer.new(value: "10"),
          ),
        )
      end

      let(:enumeration_type) do
        described_class.new(
          id: "enum_type",
          underlying_type: Expressir::Model::DataTypes::Enumeration.new(
            items: [
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
            ],
          ),
        )
      end

      let(:select_type) do
        described_class.new(
          id: "select_type",
          underlying_type: Expressir::Model::DataTypes::Select.new(
            items: [
              Expressir::Model::References::SimpleReference.new(id: "type1"),
              Expressir::Model::References::SimpleReference.new(id: "type2"),
            ],
          ),
        )
      end

      it "handles simple types" do
        expect(simple_type.underlying_type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles array types" do
        expect(array_type.underlying_type).to be_a Expressir::Model::DataTypes::Array
        expect(array_type.underlying_type.base_type).to be_a Expressir::Model::DataTypes::Integer
        expect(array_type.underlying_type.bound1.value).to eq "1"
        expect(array_type.underlying_type.bound2.value).to eq "10"
      end

      it "handles enumeration types" do
        expect(enumeration_type.underlying_type).to be_a Expressir::Model::DataTypes::Enumeration
        expect(enumeration_type.underlying_type.items.map(&:id)).to eq ["ITEM1", "ITEM2"]
      end

      it "handles select types" do
        expect(select_type.underlying_type).to be_a Expressir::Model::DataTypes::Select
        expect(select_type.underlying_type.items.map(&:id)).to eq ["type1", "type2"]
      end
    end
  end

  describe "where rule handling" do
    context "with different where rule configurations" do
      let(:type_with_single_rule) do
        described_class.new(
          id: "single_rule_type",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
          where_rules: [
            Expressir::Model::Declarations::WhereRule.new(
              id: "WR1",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
          ],
        )
      end

      let(:type_with_multiple_rules) do
        described_class.new(
          id: "multi_rule_type",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
          where_rules: [
            Expressir::Model::Declarations::WhereRule.new(
              id: "WR1",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
            Expressir::Model::Declarations::WhereRule.new(
              id: "WR2",
              expression: Expressir::Model::Expressions::BinaryExpression.new(
                operator: :GREATER_THAN,
                operand1: Expressir::Model::References::SimpleReference.new(id: "SELF"),
                operand2: Expressir::Model::Literals::Integer.new(value: "0"),
              ),
            ),
          ],
        )
      end

      let(:type_without_rules) do
        described_class.new(
          id: "no_rules_type",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles single where rule" do
        expect(type_with_single_rule.where_rules.length).to eq 1
        expect(type_with_single_rule.where_rules.first.id).to eq "WR1"
      end

      it "handles multiple where rules" do
        expect(type_with_multiple_rules.where_rules.length).to eq 2
        expect(type_with_multiple_rules.where_rules.map(&:id)).to eq ["WR1", "WR2"]
      end

      it "handles no where rules" do
        expect(type_without_rules.where_rules).to be_empty
      end
    end
  end

  describe "complex type definitions" do
    context "with nested type structures" do
      let(:nested_array_type) do
        described_class.new(
          id: "nested_array",
          underlying_type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Array.new(
              base_type: Expressir::Model::DataTypes::Integer.new,
              bound1: Expressir::Model::Literals::Integer.new(value: "1"),
              bound2: Expressir::Model::Literals::Integer.new(value: "3"),
            ),
            bound1: Expressir::Model::Literals::Integer.new(value: "1"),
            bound2: Expressir::Model::Literals::Integer.new(value: "2"),
          ),
        )
      end

      let(:complex_select_type) do
        described_class.new(
          id: "complex_select",
          underlying_type: Expressir::Model::DataTypes::Select.new(
            items: [
              Expressir::Model::References::SimpleReference.new(id: "type1"),
              Expressir::Model::References::SimpleReference.new(id: "type2"),
            ],
            extensible: true,
          ),
        )
      end

      it "handles nested array types" do
        expect(nested_array_type.underlying_type).to be_a Expressir::Model::DataTypes::Array
        expect(nested_array_type.underlying_type.base_type).to be_a Expressir::Model::DataTypes::Array
        expect(nested_array_type.underlying_type.base_type.base_type).to be_a Expressir::Model::DataTypes::Integer
      end

      it "handles complex select types" do
        expect(complex_select_type.underlying_type).to be_a Expressir::Model::DataTypes::Select
        expect(complex_select_type.underlying_type.items.length).to eq 2
        expect(complex_select_type.underlying_type.extensible).to be true
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:type_without_underlying) do
        described_class.new(
          id: "no_underlying",
        )
      end

      let(:type_with_empty_id) do
        described_class.new(
          id: "",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:type_with_very_long_id) do
        described_class.new(
          id: "a" * 100,
          underlying_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:type_with_special_chars) do
        described_class.new(
          id: "type_with_$pecial_chars",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles missing underlying type" do
        expect(type_without_underlying.underlying_type).to be_nil
      end

      it "handles empty identifier" do
        expect(type_with_empty_id.id).to eq ""
      end

      it "handles very long identifier" do
        expect(type_with_very_long_id.id.length).to eq 100
      end

      it "handles special characters in identifier" do
        expect(type_with_special_chars.id).to eq "type_with_$pecial_chars"
      end
    end
  end

  describe "enumeration handling" do
    context "when type has enumeration items" do
      let(:enumeration_type) do
        described_class.new(
          id: "color_type",
          underlying_type: Expressir::Model::DataTypes::Enumeration.new(
            items: [
              Expressir::Model::DataTypes::EnumerationItem.new(
                id: "RED",
                remarks: ["Primary color"],
              ),
              Expressir::Model::DataTypes::EnumerationItem.new(
                id: "GREEN",
                remarks: ["Primary color"],
              ),
              Expressir::Model::DataTypes::EnumerationItem.new(
                id: "BLUE",
                remarks: ["Primary color"],
              ),
            ],
          ),
        )
      end

      it "provides access to enumeration items" do
        expect(enumeration_type.enumeration_items.length).to eq 3
        expect(enumeration_type.enumeration_items.map(&:id)).to eq ["RED", "GREEN", "BLUE"]
      end

      it "maintains enumeration item remarks" do
        expect(enumeration_type.enumeration_items.map(&:remarks)).to all(eq ["Primary color"])
      end
    end
  end

  describe "#children" do
    let(:type) do
      described_class.new(
        id: "test_type",
        underlying_type: Expressir::Model::DataTypes::Integer.new,
        where_rules: [
          Expressir::Model::Declarations::WhereRule.new(id: "WR1"),
          Expressir::Model::Declarations::WhereRule.new(id: "WR2"),
        ],
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all child elements" do
      children_ids = type.children.map(&:id)
      expect(children_ids).to contain_exactly("WR1", "WR2", "remark1", "remark2")
    end

    context "with enumeration type" do
      let(:enum_type) do
        described_class.new(
          id: "enum_type",
          underlying_type: Expressir::Model::DataTypes::Enumeration.new(
            items: [
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM1"),
              Expressir::Model::DataTypes::EnumerationItem.new(id: "ITEM2"),
            ],
          ),
        )
      end

      it "includes enumeration items in children" do
        enum_items = enum_type.enumeration_items
        expect(enum_items.map(&:id)).to eq ["ITEM1", "ITEM2"]
      end
    end

    context "without children" do
      let(:simple_type) do
        described_class.new(
          id: "simple_type",
          underlying_type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "returns empty array" do
        expect(simple_type.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/type_spec.rb ---
--- START FILE: spec/expressir/model/declarations/unique_rule_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::UniqueRule do
  describe ".new" do
    subject(:unique_rule) do
      described_class.new(
        id: id,
        attributes: attributes,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_unique_rule" }
    let(:attributes) do
      [
        Expressir::Model::References::SimpleReference.new(id: "attr1"),
        Expressir::Model::References::SimpleReference.new(id: "attr2"),
      ]
    end
    let(:remarks) { ["Test unique rule remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a unique rule" do
      expect(unique_rule).to be_a described_class
      expect(unique_rule.id).to eq "test_unique_rule"
      expect(unique_rule.attributes.map(&:id)).to eq ["attr1", "attr2"]
      expect(unique_rule.remarks).to eq ["Test unique rule remark"]
      expect(unique_rule.remark_items.first.id).to eq "remark1"
    end
  end

  describe "attribute handling" do
    context "with different attribute configurations" do
      let(:single_attribute_rule) do
        described_class.new(
          id: "single_attr",
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      let(:multiple_attributes_rule) do
        described_class.new(
          id: "multi_attr",
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
            Expressir::Model::References::SimpleReference.new(id: "attr2"),
            Expressir::Model::References::SimpleReference.new(id: "attr3"),
          ],
        )
      end

      let(:complex_attribute_references) do
        described_class.new(
          id: "complex_attr",
          attributes: [
            Expressir::Model::References::AttributeReference.new(
              ref: Expressir::Model::References::SimpleReference.new(id: "entity1"),
              attribute: Expressir::Model::References::SimpleReference.new(id: "attr1"),
            ),
            Expressir::Model::References::AttributeReference.new(
              ref: Expressir::Model::References::SimpleReference.new(id: "entity2"),
              attribute: Expressir::Model::References::SimpleReference.new(id: "attr2"),
            ),
          ],
        )
      end

      it "handles single attribute" do
        expect(single_attribute_rule.attributes.length).to eq 1
        expect(single_attribute_rule.attributes.first.id).to eq "attr1"
      end

      it "handles multiple attributes" do
        expect(multiple_attributes_rule.attributes.length).to eq 3
        expect(multiple_attributes_rule.attributes.map(&:id)).to eq ["attr1", "attr2", "attr3"]
      end

      it "handles complex attribute references" do
        expect(complex_attribute_references.attributes[0]).to be_a Expressir::Model::References::AttributeReference
        expect(complex_attribute_references.attributes[0].ref.id).to eq "entity1"
        expect(complex_attribute_references.attributes[0].attribute.id).to eq "attr1"
        expect(complex_attribute_references.attributes[1].ref.id).to eq "entity2"
        expect(complex_attribute_references.attributes[1].attribute.id).to eq "attr2"
      end
    end
  end

  describe "entity context" do
    context "with parent entity" do
      let(:parent_entity) do
        Expressir::Model::Declarations::Entity.new(
          id: "test_entity",
          attributes: [
            Expressir::Model::Declarations::Attribute.new(
              id: "attr1",
              type: Expressir::Model::DataTypes::String.new,
            ),
            Expressir::Model::Declarations::Attribute.new(
              id: "attr2",
              type: Expressir::Model::DataTypes::String.new,
            ),
          ],
          unique_rules: [
            described_class.new(
              id: "UR1",
              attributes: [
                Expressir::Model::References::SimpleReference.new(id: "attr1"),
                Expressir::Model::References::SimpleReference.new(id: "attr2"),
              ],
            ),
          ],
        )
      end

      it "establishes correct parent relationship" do
        unique_rule = parent_entity.unique_rules.first
        expect(unique_rule.parent).to eq parent_entity
      end

      it "references existing entity attributes" do
        unique_rule = parent_entity.unique_rules.first
        attribute_ids = unique_rule.attributes.map(&:id)
        entity_attribute_ids = parent_entity.attributes.map(&:id)
        expect(attribute_ids - entity_attribute_ids).to be_empty
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_rule) do
        described_class.new(
          id: "empty_rule",
        )
      end

      let(:no_id_rule) do
        described_class.new(
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      let(:empty_attributes_rule) do
        described_class.new(
          id: "no_attrs",
          attributes: [],
        )
      end

      let(:duplicate_attributes_rule) do
        described_class.new(
          id: "duplicate_attrs",
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      it "handles empty rule" do
        expect(empty_rule.attributes).to be_empty
      end

      it "handles missing id" do
        expect(no_id_rule.id).to be_nil
        expect(no_id_rule.attributes.first.id).to eq "attr1"
      end

      it "handles empty attributes array" do
        expect(empty_attributes_rule.attributes).to be_empty
      end

      it "handles duplicate attributes" do
        expect(duplicate_attributes_rule.attributes.map(&:id)).to eq ["attr1", "attr1"]
      end
    end

    context "with special naming patterns" do
      let(:long_name_rule) do
        described_class.new(
          id: "a" * 100,
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      let(:special_chars_rule) do
        described_class.new(
          id: "rule_with_$pecial_chars",
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      let(:numeric_name_rule) do
        described_class.new(
          id: "rule123",
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      it "handles long identifiers" do
        expect(long_name_rule.id.length).to eq 100
      end

      it "handles special characters in identifier" do
        expect(special_chars_rule.id).to eq "rule_with_$pecial_chars"
      end

      it "handles numeric characters in identifier" do
        expect(numeric_name_rule.id).to eq "rule123"
      end
    end
  end

  describe "#children" do
    let(:unique_rule) do
      described_class.new(
        id: "test_rule",
        attributes: [
          Expressir::Model::References::SimpleReference.new(id: "attr1"),
          Expressir::Model::References::SimpleReference.new(id: "attr2"),
        ],
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(unique_rule.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_rule) do
        described_class.new(
          id: "simple_rule",
          attributes: [
            Expressir::Model::References::SimpleReference.new(id: "attr1"),
          ],
        )
      end

      it "returns empty array" do
        expect(simple_rule.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/unique_rule_spec.rb ---
--- START FILE: spec/expressir/model/declarations/variable_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::Variable do
  describe ".new" do
    subject(:variable) do
      described_class.new(
        id: id,
        type: type,
        expression: expression,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_var" }
    let(:type) { Expressir::Model::DataTypes::Integer.new }
    let(:expression) { Expressir::Model::Literals::Integer.new(value: "42") }
    let(:remarks) { ["Test variable remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a variable" do
      expect(variable).to be_a described_class
      expect(variable.id).to eq "test_var"
      expect(variable.type).to be_a Expressir::Model::DataTypes::Integer
      expect(variable.expression.value).to eq "42"
      expect(variable.remarks).to eq ["Test variable remark"]
      expect(variable.remark_items.first.id).to eq "remark1"
    end
  end

  describe "type handling" do
    context "with different type definitions" do
      let(:simple_type_var) do
        described_class.new(
          id: "simple_var",
          type: Expressir::Model::DataTypes::String.new,
        )
      end

      let(:array_type_var) do
        described_class.new(
          id: "array_var",
          type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Integer.new,
            bound1: Expressir::Model::Literals::Integer.new(value: "1"),
            bound2: Expressir::Model::Literals::Integer.new(value: "10"),
          ),
        )
      end

      let(:entity_ref_var) do
        described_class.new(
          id: "entity_var",
          type: Expressir::Model::References::SimpleReference.new(id: "SomeEntity"),
        )
      end

      let(:select_type_var) do
        described_class.new(
          id: "select_var",
          type: Expressir::Model::DataTypes::Select.new(
            items: [
              Expressir::Model::References::SimpleReference.new(id: "type1"),
              Expressir::Model::References::SimpleReference.new(id: "type2"),
            ],
          ),
        )
      end

      it "handles simple types" do
        expect(simple_type_var.type).to be_a Expressir::Model::DataTypes::String
      end

      it "handles array types" do
        expect(array_type_var.type).to be_a Expressir::Model::DataTypes::Array
        expect(array_type_var.type.base_type).to be_a Expressir::Model::DataTypes::Integer
        expect(array_type_var.type.bound1.value).to eq "1"
        expect(array_type_var.type.bound2.value).to eq "10"
      end

      it "handles entity references" do
        expect(entity_ref_var.type).to be_a Expressir::Model::References::SimpleReference
        expect(entity_ref_var.type.id).to eq "SomeEntity"
      end

      it "handles select types" do
        expect(select_type_var.type).to be_a Expressir::Model::DataTypes::Select
        expect(select_type_var.type.items.map(&:id)).to eq ["type1", "type2"]
      end
    end
  end

  describe "expression handling" do
    context "with different expression types" do
      let(:literal_expr_var) do
        described_class.new(
          id: "literal_var",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      let(:binary_expr_var) do
        described_class.new(
          id: "binary_var",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :ADDITION,
            operand1: Expressir::Model::Literals::Integer.new(value: "1"),
            operand2: Expressir::Model::Literals::Integer.new(value: "2"),
          ),
        )
      end

      let(:function_call_var) do
        described_class.new(
          id: "func_var",
          type: Expressir::Model::DataTypes::Integer.new,
          expression: Expressir::Model::Expressions::FunctionCall.new(
            function: Expressir::Model::References::SimpleReference.new(id: "ABS"),
            parameters: [Expressir::Model::Literals::Integer.new(value: "-10")],
          ),
        )
      end

      it "handles literal expressions" do
        expect(literal_expr_var.expression).to be_a Expressir::Model::Literals::Integer
        expect(literal_expr_var.expression.value).to eq "42"
      end

      it "handles binary expressions" do
        expect(binary_expr_var.expression).to be_a Expressir::Model::Expressions::BinaryExpression
        expect(binary_expr_var.expression.operator).to eq :ADDITION
        expect(binary_expr_var.expression.operand1.value).to eq "1"
        expect(binary_expr_var.expression.operand2.value).to eq "2"
      end

      it "handles function calls" do
        expect(function_call_var.expression).to be_a Expressir::Model::Expressions::FunctionCall
        expect(function_call_var.expression.function.id).to eq "ABS"
        expect(function_call_var.expression.parameters.first.value).to eq "-10"
      end
    end
  end

  describe "scope handling" do
    context "with different parent scopes" do
      let(:function_scope) do
        Expressir::Model::Declarations::Function.new(
          id: "test_function",
          variables: [
            described_class.new(
              id: "func_var",
              type: Expressir::Model::DataTypes::Integer.new,
            ),
          ],
        )
      end

      let(:procedure_scope) do
        Expressir::Model::Declarations::Procedure.new(
          id: "test_procedure",
          variables: [
            described_class.new(
              id: "proc_var",
              type: Expressir::Model::DataTypes::Integer.new,
            ),
          ],
        )
      end

      let(:rule_scope) do
        Expressir::Model::Declarations::Rule.new(
          id: "test_rule",
          algorithm: Expressir::Model::Declarations::Algorithm.new(
            variables: [
              described_class.new(
                id: "rule_var",
                type: Expressir::Model::DataTypes::Integer.new,
              ),
            ],
          ),
        )
      end

      it "handles function scope" do
        variable = function_scope.variables.first
        expect(variable.parent).to eq function_scope
        expect(variable.id).to eq "func_var"
      end

      it "handles procedure scope" do
        variable = procedure_scope.variables.first
        expect(variable.parent).to eq procedure_scope
        expect(variable.id).to eq "proc_var"
      end

      it "handles rule scope" do
        variable = rule_scope.algorithm.variables.first
        expect(variable.parent).to eq rule_scope.algorithm
        expect(variable.id).to eq "rule_var"
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:minimal_variable) do
        described_class.new(
          id: "min_var",
        )
      end

      let(:type_only_variable) do
        described_class.new(
          id: "type_var",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:expression_only_variable) do
        described_class.new(
          id: "expr_var",
          expression: Expressir::Model::Literals::Integer.new(value: "42"),
        )
      end

      let(:complex_nested_type) do
        described_class.new(
          id: "complex_var",
          type: Expressir::Model::DataTypes::Array.new(
            base_type: Expressir::Model::DataTypes::Set.new(
              base_type: Expressir::Model::DataTypes::String.new,
            ),
          ),
        )
      end

      it "handles minimal variable declaration" do
        expect(minimal_variable.type).to be_nil
        expect(minimal_variable.expression).to be_nil
      end

      it "handles type-only variables" do
        expect(type_only_variable.type).to be_a Expressir::Model::DataTypes::Integer
        expect(type_only_variable.expression).to be_nil
      end

      it "handles expression-only variables" do
        expect(expression_only_variable.type).to be_nil
        expect(expression_only_variable.expression.value).to eq "42"
      end

      it "handles complex nested types" do
        expect(complex_nested_type.type).to be_a Expressir::Model::DataTypes::Array
        expect(complex_nested_type.type.base_type).to be_a Expressir::Model::DataTypes::Set
        expect(complex_nested_type.type.base_type.base_type).to be_a Expressir::Model::DataTypes::String
      end
    end

    context "with naming patterns" do
      let(:empty_id_variable) do
        described_class.new(
          id: "",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:long_id_variable) do
        described_class.new(
          id: "a" * 100,
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      let(:special_chars_variable) do
        described_class.new(
          id: "var_with_$pecial_chars",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "handles empty identifier" do
        expect(empty_id_variable.id).to eq ""
      end

      it "handles long identifier" do
        expect(long_id_variable.id.length).to eq 100
      end

      it "handles special characters in identifier" do
        expect(special_chars_variable.id).to eq "var_with_$pecial_chars"
      end
    end
  end

  describe "#children" do
    let(:variable) do
      described_class.new(
        id: "test_var",
        type: Expressir::Model::DataTypes::Integer.new,
        expression: Expressir::Model::Literals::Integer.new(value: "42"),
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(variable.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_variable) do
        described_class.new(
          id: "simple_var",
          type: Expressir::Model::DataTypes::Integer.new,
        )
      end

      it "returns empty array" do
        expect(simple_variable.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/variable_spec.rb ---
--- START FILE: spec/expressir/model/declarations/where_rule_spec.rb ---
require "spec_helper"

RSpec.describe Expressir::Model::Declarations::WhereRule do
  describe ".new" do
    subject(:where_rule) do
      described_class.new(
        id: id,
        expression: expression,
        remarks: remarks,
        remark_items: remark_items,
      )
    end

    let(:id) { "test_where_rule" }
    let(:expression) do
      Expressir::Model::Expressions::BinaryExpression.new(
        operator: :GREATER_THAN,
        operand1: Expressir::Model::References::SimpleReference.new(id: "SELF"),
        operand2: Expressir::Model::Literals::Integer.new(value: "0"),
      )
    end
    let(:remarks) { ["Test where rule remark"] }
    let(:remark_items) do
      [
        Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
      ]
    end

    it "creates a where rule" do
      expect(where_rule).to be_a described_class
      expect(where_rule.id).to eq "test_where_rule"
      expect(where_rule.expression).to be_a Expressir::Model::Expressions::BinaryExpression
      expect(where_rule.remarks).to eq ["Test where rule remark"]
      expect(where_rule.remark_items.first.id).to eq "remark1"
    end
  end

  describe "expression handling" do
    context "with different expression types" do
      let(:simple_comparison_rule) do
        described_class.new(
          id: "simple_rule",
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :EQUAL,
            operand1: Expressir::Model::References::SimpleReference.new(id: "x"),
            operand2: Expressir::Model::Literals::Integer.new(value: "42"),
          ),
        )
      end

      let(:logical_expression_rule) do
        described_class.new(
          id: "logical_rule",
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :AND,
            operand1: Expressir::Model::Literals::Logical.new(value: :TRUE),
            operand2: Expressir::Model::Literals::Logical.new(value: :TRUE),
          ),
        )
      end

      let(:function_call_rule) do
        described_class.new(
          id: "function_rule",
          expression: Expressir::Model::Expressions::FunctionCall.new(
            function: Expressir::Model::References::SimpleReference.new(id: "SIZEOF"),
            parameters: [
              Expressir::Model::References::SimpleReference.new(id: "items"),
            ],
          ),
        )
      end

      let(:complex_expression_rule) do
        described_class.new(
          id: "complex_rule",
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :AND,
            operand1: Expressir::Model::Expressions::BinaryExpression.new(
              operator: :GREATER_THAN,
              operand1: Expressir::Model::References::SimpleReference.new(id: "x"),
              operand2: Expressir::Model::Literals::Integer.new(value: "0"),
            ),
            operand2: Expressir::Model::Expressions::BinaryExpression.new(
              operator: :LESS_THAN,
              operand1: Expressir::Model::References::SimpleReference.new(id: "x"),
              operand2: Expressir::Model::Literals::Integer.new(value: "100"),
            ),
          ),
        )
      end

      it "handles simple comparison expressions" do
        expect(simple_comparison_rule.expression.operator).to eq :EQUAL
        expect(simple_comparison_rule.expression.operand1.id).to eq "x"
        expect(simple_comparison_rule.expression.operand2.value).to eq "42"
      end

      it "handles logical expressions" do
        expect(logical_expression_rule.expression.operator).to eq :AND
        expect(logical_expression_rule.expression.operand1.value).to eq :TRUE
        expect(logical_expression_rule.expression.operand2.value).to eq :TRUE
      end

      it "handles function calls" do
        expect(function_call_rule.expression).to be_a Expressir::Model::Expressions::FunctionCall
        expect(function_call_rule.expression.function.id).to eq "SIZEOF"
        expect(function_call_rule.expression.parameters.first.id).to eq "items"
      end

      it "handles complex nested expressions" do
        expr = complex_expression_rule.expression
        expect(expr.operator).to eq :AND
        expect(expr.operand1.operator).to eq :GREATER_THAN
        expect(expr.operand2.operator).to eq :LESS_THAN
      end
    end
  end

  describe "parent context" do
    context "with different parent types" do
      let(:entity_parent) do
        Expressir::Model::Declarations::Entity.new(
          id: "test_entity",
          where_rules: [
            described_class.new(
              id: "WR1",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
          ],
        )
      end

      let(:type_parent) do
        Expressir::Model::Declarations::Type.new(
          id: "test_type",
          where_rules: [
            described_class.new(
              id: "WR1",
              expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
            ),
          ],
        )
      end

      it "handles entity parent" do
        rule = entity_parent.where_rules.first
        expect(rule.parent).to eq entity_parent
        expect(rule.id).to eq "WR1"
      end

      it "handles type parent" do
        rule = type_parent.where_rules.first
        expect(rule.parent).to eq type_parent
        expect(rule.id).to eq "WR1"
      end
    end
  end

  describe "edge cases" do
    context "with unusual configurations" do
      let(:empty_rule) do
        described_class.new(
          id: "empty_rule",
        )
      end

      let(:no_id_rule) do
        described_class.new(
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      let(:complex_nested_expressions) do
        described_class.new(
          id: "nested_rule",
          expression: Expressir::Model::Expressions::BinaryExpression.new(
            operator: :AND,
            operand1: Expressir::Model::Expressions::BinaryExpression.new(
              operator: :OR,
              operand1: Expressir::Model::Literals::Logical.new(value: :TRUE),
              operand2: Expressir::Model::Literals::Logical.new(value: :FALSE),
            ),
            operand2: Expressir::Model::Expressions::UnaryExpression.new(
              operator: :NOT,
              operand: Expressir::Model::Literals::Logical.new(value: :FALSE),
            ),
          ),
        )
      end

      it "handles empty rules" do
        expect(empty_rule.expression).to be_nil
      end

      it "handles missing id" do
        expect(no_id_rule.id).to be_nil
        expect(no_id_rule.expression.value).to eq :TRUE
      end

      it "handles deeply nested expressions" do
        expr = complex_nested_expressions.expression
        expect(expr.operator).to eq :AND
        expect(expr.operand1.operator).to eq :OR
        expect(expr.operand2.operator).to eq :NOT
      end
    end

    context "with naming patterns" do
      let(:empty_id_rule) do
        described_class.new(
          id: "",
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      let(:long_id_rule) do
        described_class.new(
          id: "a" * 100,
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      let(:special_chars_rule) do
        described_class.new(
          id: "rule_with_$pecial_chars",
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      it "handles empty identifier" do
        expect(empty_id_rule.id).to eq ""
      end

      it "handles long identifier" do
        expect(long_id_rule.id.length).to eq 100
      end

      it "handles special characters in identifier" do
        expect(special_chars_rule.id).to eq "rule_with_$pecial_chars"
      end
    end
  end

  describe "#children" do
    let(:where_rule) do
      described_class.new(
        id: "test_rule",
        expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        remark_items: [
          Expressir::Model::Declarations::RemarkItem.new(id: "remark1"),
          Expressir::Model::Declarations::RemarkItem.new(id: "remark2"),
        ],
      )
    end

    it "returns all remark items" do
      expect(where_rule.children).to contain_exactly(
        have_attributes(id: "remark1"),
        have_attributes(id: "remark2")
      )
    end

    context "without remark items" do
      let(:simple_rule) do
        described_class.new(
          id: "simple_rule",
          expression: Expressir::Model::Literals::Logical.new(value: :TRUE),
        )
      end

      it "returns empty array" do
        expect(simple_rule.children).to be_empty
      end
    end
  end
end
--- END FILE: spec/expressir/model/declarations/where_rule_spec.rb ---
--- START FILE: spec/expressir/model/model_element_spec.rb ---
require "yaml"
require "spec_helper"
require "expressir/express/parser"
require "expressir/express/formatter"

RSpec.describe Expressir::Model::ModelElement do
  describe ".to_hash" do
    it "exports an object with a formatter (single.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "single.exp")
      yaml_file = Expressir.root_path.join("spec", "syntax", "single_formatted.yaml")

      repo = Expressir::Express::Parser.from_file(exp_file)

      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path, formatter: Expressir::Express::Formatter))
      # File.write(yaml_file, result)
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "exports objects filtered by select_proc (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      filtered_schemas = ["multiple_schema2", "multiple_schema3"]
      select_proc = Proc.new do |value|
        if value.is_a?(Expressir::Model::Declarations::Schema)
          filtered_schemas.include?(value.id)
        else
          true
        end
      end

      result = repo.to_hash(select_proc: select_proc)

      expect(result["schemas"].map { |s| s["id"] }.sort).to eq(filtered_schemas)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end

  describe ".from_hash" do
    it "parses an object (single.yaml)" do |example|
      print "\n[#{example.description}] "
      yaml_file = Expressir.root_path.join("spec", "syntax", "single.yaml")

      input = YAML.safe_load(File.read(yaml_file))
      repo = Expressir::Model::ModelElement.from_hash(input, root_path: Expressir.root_path)

      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses an object (multiple.yaml)" do |example|
      print "\n[#{example.description}] "
      yaml_file = Expressir.root_path.join("spec", "syntax", "multiple.yaml")

      input = YAML.safe_load(File.read(yaml_file), permitted_classes: [Symbol]) # For UTF8 symbols
      repo = Expressir::Model::ModelElement.from_hash(input, root_path: Expressir.root_path)

      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses an object (syntax.yaml)" do |example|
      print "\n[#{example.description}] "
      yaml_file = Expressir.root_path.join("spec", "syntax", "syntax.yaml")

      input = YAML.safe_load(File.read(yaml_file), permitted_classes: [Symbol]) # For UTF8 symbols
      repo = Expressir::Model::ModelElement.from_hash(input, root_path: Expressir.root_path)

      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "parses an object (remark.yaml)" do |example|
      print "\n[#{example.description}] "
      yaml_file = Expressir.root_path.join("spec", "syntax", "remark.yaml")

      input = YAML.safe_load(File.read(yaml_file), permitted_classes: [Symbol]) # For UTF8 symbols
      repo = Expressir::Model::ModelElement.from_hash(input, root_path: Expressir.root_path)

      result = YAML.dump(repo.to_hash(root_path: Expressir.root_path))
      expected_result = File.read(yaml_file)

      expect(result).to eq(expected_result)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end

  describe ".find" do
    it "finds an object (single.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "single.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      # universal scope
      expect(repo.find("single_schema")).to be_instance_of(Expressir::Model::Declarations::Schema)
      expect(repo.find("single_schema.empty_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)

      # schema scope
      schema = repo.schemas.first
      expect(schema.find("empty_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "finds an object (multiple.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "multiple.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      # universal scope
      expect(repo.find("multiple_schema")).to be_instance_of(Expressir::Model::Declarations::Schema)
      expect(repo.find("multiple_schema.empty_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(repo.find("multiple_schema.attribute_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(repo.find("multiple_schema.attribute_entity2")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(repo.find("multiple_schema.attribute_entity3")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(repo.find("multiple_schema.attribute_entity4")).to be_instance_of(Expressir::Model::Declarations::Entity)

      # schema scope
      schema = repo.schemas.first
      expect(schema.find("empty_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(schema.find("attribute_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(schema.find("attribute_entity2")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(schema.find("attribute_entity3")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(schema.find("attribute_entity4")).to be_instance_of(Expressir::Model::Declarations::Entity)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "finds an object (syntax.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "syntax.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      # universal scope
      expect(repo.find("syntax_schema")).to be_instance_of(Expressir::Model::Declarations::Schema)
      expect(repo.find("syntax_schema.empty_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)

      # schema scope
      schema = repo.schemas.first
      expect(schema.find("empty_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end

    it "finds an object (remark.exp)" do |example|
      print "\n[#{example.description}] "
      exp_file = Expressir.root_path.join("spec", "syntax", "remark.exp")

      repo = Expressir::Express::Parser.from_file(exp_file)

      # universal scope
      expect(repo.find("remark_schema")).to be_instance_of(Expressir::Model::Declarations::Schema)
      expect(repo.find("remark_schema.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(repo.find("remark_schema.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(repo.find("remark_schema.remark_type.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(repo.find("remark_schema.remark_type.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(repo.find("remark_schema.remark_type.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(repo.find("remark_schema.remark_type.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(repo.find("remark_schema.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(repo.find("remark_schema.remark_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(repo.find("remark_schema.remark_entity.remark_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(repo.find("remark_schema.remark_entity.remark_derived_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(repo.find("remark_schema.remark_entity.remark_inverse_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(repo.find("remark_schema.remark_entity.UR1")).to be_instance_of(Expressir::Model::Declarations::UniqueRule)
      expect(repo.find("remark_schema.remark_entity.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(repo.find("remark_schema.remark_entity.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(repo.find("remark_schema.remark_entity.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(repo.find("remark_schema.remark_entity.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(repo.find("remark_schema.remark_subtype_constraint")).to be_instance_of(Expressir::Model::Declarations::SubtypeConstraint)
      expect(repo.find("remark_schema.remark_function")).to be_instance_of(Expressir::Model::Declarations::Function)
      expect(repo.find("remark_schema.remark_function.remark_parameter")).to be_instance_of(Expressir::Model::Declarations::Parameter)
      expect(repo.find("remark_schema.remark_function.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(repo.find("remark_schema.remark_function.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(repo.find("remark_schema.remark_function.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(repo.find("remark_schema.remark_function.remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(repo.find("remark_schema.remark_procedure")).to be_instance_of(Expressir::Model::Declarations::Procedure)
      expect(repo.find("remark_schema.remark_procedure.remark_parameter")).to be_instance_of(Expressir::Model::Declarations::Parameter)
      expect(repo.find("remark_schema.remark_procedure.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(repo.find("remark_schema.remark_procedure.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(repo.find("remark_schema.remark_procedure.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(repo.find("remark_schema.remark_procedure.remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(repo.find("remark_schema.remark_rule")).to be_instance_of(Expressir::Model::Declarations::Rule)
      expect(repo.find("remark_schema.remark_rule.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(repo.find("remark_schema.remark_rule.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(repo.find("remark_schema.remark_rule.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(repo.find("remark_schema.remark_rule.remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(repo.find("remark_schema.remark_rule.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(repo.find("remark_schema.remark_rule.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(repo.find("remark_schema.remark_rule.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(repo.find("remark_schema.remark_rule.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(repo.find("remark_schema.remark_item")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)

      # schema scope
      schema = repo.schemas.first
      expect(schema.find("remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(schema.find("remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(schema.find("remark_type.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(schema.find("remark_type.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(schema.find("remark_type.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(schema.find("remark_type.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(schema.find("remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(schema.find("remark_entity")).to be_instance_of(Expressir::Model::Declarations::Entity)
      expect(schema.find("remark_entity.remark_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(schema.find("remark_entity.remark_derived_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(schema.find("remark_entity.remark_inverse_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(schema.find("remark_entity.UR1")).to be_instance_of(Expressir::Model::Declarations::UniqueRule)
      expect(schema.find("remark_entity.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(schema.find("remark_entity.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(schema.find("remark_entity.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(schema.find("remark_entity.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(schema.find("remark_subtype_constraint")).to be_instance_of(Expressir::Model::Declarations::SubtypeConstraint)
      expect(schema.find("remark_function")).to be_instance_of(Expressir::Model::Declarations::Function)
      expect(schema.find("remark_function.remark_parameter")).to be_instance_of(Expressir::Model::Declarations::Parameter)
      expect(schema.find("remark_function.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(schema.find("remark_function.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(schema.find("remark_function.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(schema.find("remark_function.remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(schema.find("remark_procedure")).to be_instance_of(Expressir::Model::Declarations::Procedure)
      expect(schema.find("remark_procedure.remark_parameter")).to be_instance_of(Expressir::Model::Declarations::Parameter)
      expect(schema.find("remark_procedure.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(schema.find("remark_procedure.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(schema.find("remark_procedure.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(schema.find("remark_procedure.remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(schema.find("remark_rule")).to be_instance_of(Expressir::Model::Declarations::Rule)
      expect(schema.find("remark_rule.remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(schema.find("remark_rule.remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(schema.find("remark_rule.remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(schema.find("remark_rule.remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(schema.find("remark_rule.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(schema.find("remark_rule.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(schema.find("remark_rule.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(schema.find("remark_rule.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(schema.find("remark_item")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)

      # type scope
      type = schema.types.first
      expect(type.find("WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(type.find("wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(type.find("IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(type.find("ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)

      # entity scope
      entity = schema.entities.first
      expect(entity.find("remark_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(entity.find("remark_derived_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(entity.find("remark_inverse_attribute")).to be_instance_of(Expressir::Model::Declarations::Attribute)
      expect(entity.find("UR1")).to be_instance_of(Expressir::Model::Declarations::UniqueRule)
      expect(entity.find("WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(entity.find("wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(entity.find("IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(entity.find("ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)

      # function scope
      function = schema.functions.first
      expect(function.find("remark_parameter")).to be_instance_of(Expressir::Model::Declarations::Parameter)
      expect(function.find("remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(function.find("remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(function.find("remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(function.find("remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)

      # procedure scope
      procedure = schema.procedures.first
      expect(procedure.find("remark_parameter")).to be_instance_of(Expressir::Model::Declarations::Parameter)
      expect(procedure.find("remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(procedure.find("remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(procedure.find("remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(procedure.find("remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)

      # rule scope
      rule = schema.rules.first
      expect(rule.find("remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(rule.find("remark_enumeration_item")).to be_instance_of(Expressir::Model::DataTypes::EnumerationItem)
      expect(rule.find("remark_constant")).to be_instance_of(Expressir::Model::Declarations::Constant)
      expect(rule.find("remark_variable")).to be_instance_of(Expressir::Model::Declarations::Variable)
      expect(rule.find("WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(rule.find("wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(rule.find("IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(rule.find("ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)

      # retry search in parent scope
      expect(entity.find("remark_type")).to be_instance_of(Expressir::Model::Declarations::Type)
      expect(entity.find("remark_type.WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(entity.find("remark_type.wr:WR1")).to be_instance_of(Expressir::Model::Declarations::WhereRule)
      expect(entity.find("remark_type.IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)
      expect(entity.find("remark_type.ip:IP1")).to be_instance_of(Expressir::Model::Declarations::RemarkItem)

      # Validate Object Space
      GC.start
      GC.verify_compaction_references
      GC.verify_internal_consistency
    end
  end
end
--- END FILE: spec/expressir/model/model_element_spec.rb ---
--- START FILE: spec/expressir_spec.rb ---
require "spec_helper"

RSpec.describe Expressir do
  it "has a version number" do
    expect(Expressir::VERSION).not_to be nil
  end

  describe ".parse" do
    context "with valid EXPRESS input" do
      let(:simple_schema) do
        <<~EXPRESS
          SCHEMA test_schema;
          END_SCHEMA;
        EXPRESS
      end

      let(:complex_schema) do
        <<~EXPRESS
          SCHEMA test_schema;
            TYPE string_type = STRING;
            END_TYPE;

            ENTITY test_entity;
              name : string_type;
              value : INTEGER;
              UNIQUE
                UR1 : name;
              WHERE
                WR1 : value >= 0;
            END_ENTITY;

            FUNCTION test_function(input : INTEGER) : BOOLEAN;
              RETURN (input > 0);
            END_FUNCTION;
          END_SCHEMA;
        EXPRESS
      end

      it "successfully parses simple schema" do
        result = Expressir.parse(simple_schema)
        expect(result).to be_a Expressir::Model::Repository
        expect(result.schemas.first.id).to eq "test_schema"
      end

      it "successfully parses complex schema" do
        result = Expressir.parse(complex_schema)
        expect(result).to be_a Expressir::Model::Repository
        schema = result.schemas.first

        expect(schema.types.first.id).to eq "string_type"
        expect(schema.entities.first.id).to eq "test_entity"
        expect(schema.functions.first.id).to eq "test_function"
      end
    end

    context "with invalid EXPRESS input" do
      let(:invalid_schema) do
        <<~EXPRESS
          SCHEMA missing_semicolon
          END_SCHEMA;
        EXPRESS
      end

      let(:syntax_error_schema) do
        <<~EXPRESS
          SCHEMA invalid_schema;
            ENTITY test_entity
              invalid syntax here
            END_ENTITY;
          END_SCHEMA;
        EXPRESS
      end

      it "raises a parsing error for missing semicolon" do
        expect { Expressir.parse(invalid_schema) }.to raise_error(Expressir::ParserError)
      end

      it "raises a parsing error for syntax errors" do
        expect { Expressir.parse(syntax_error_schema) }.to raise_error(Expressir::ParserError)
      end
    end
  end

  describe ".parse_file" do
    let(:temp_file) { Tempfile.new(["test_schema", ".exp"]) }

    before do
      temp_file.write(schema_content)
      temp_file.close
    end

    after do
      temp_file.unlink
    end

    context "with valid file" do
      let(:schema_content) do
        <<~EXPRESS
          SCHEMA test_schema;
            TYPE test_type = STRING;
            END_TYPE;
          END_SCHEMA;
        EXPRESS
      end

      it "successfully parses file" do
        result = Expressir.parse_file(temp_file.path)
        expect(result).to be_a Expressir::Model::Repository
        expect(result.schemas.first.types.first.id).to eq "test_type"
      end
    end

    context "with invalid file path" do
      it "raises error for non-existent file" do
        expect { Expressir.parse_file("nonexistent.exp") }.to raise_error(Errno::ENOENT)
      end
    end
  end

  describe ".parse_files" do
    let(:temp_files) do
      [
        Tempfile.new(["schema1", ".exp"]),
        Tempfile.new(["schema2", ".exp"]),
      ]
    end

    before do
      temp_files[0].write(schema1_content)
      temp_files[1].write(schema2_content)
      temp_files.each(&:close)
    end

    after do
      temp_files.each(&:unlink)
    end

    context "with valid files" do
      let(:schema1_content) do
        <<~EXPRESS
          SCHEMA schema1;
            TYPE type1 = STRING;
            END_TYPE;
          END_SCHEMA;
        EXPRESS
      end

      let(:schema2_content) do
        <<~EXPRESS
          SCHEMA schema2;
            TYPE type2 = INTEGER;
            END_TYPE;
          END_SCHEMA;
        EXPRESS
      end

      it "successfully parses multiple files" do
        result = Expressir.parse_files(temp_files.map(&:path))
        expect(result).to be_a Expressir::Model::Repository
        expect(result.schemas.map(&:id)).to eq ["schema1", "schema2"]
      end
    end

    context "with mixed valid and invalid files" do
      let(:schema1_content) do
        <<~EXPRESS
          SCHEMA schema1;
            TYPE type1 = STRING;
            END_TYPE;
          END_SCHEMA;
        EXPRESS
      end

      let(:schema2_content) do
        <<~EXPRESS
          SCHEMA schema2
            invalid syntax
          END_SCHEMA;
        EXPRESS
      end

      it "raises error for invalid file" do
        expect { Expressir.parse_files(temp_files.map(&:path)) }.to raise_error(Expressir::ParserError)
      end
    end
  end

  describe ".format" do
    context "with valid repository" do
      let(:repository) do
        Expressir.parse(<<~EXPRESS)
          SCHEMA test_schema;
            TYPE string_type = STRING;
            END_TYPE;
            ENTITY test_entity;
              name : STRING;
            END_ENTITY;
          END_SCHEMA;
        EXPRESS
      end

      it "formats repository to EXPRESS" do
        result = Expressir.format(repository)
        expect(result).to be_a String
        expect(result).to include("SCHEMA test_schema;")
        expect(result).to include("TYPE string_type = STRING;")
        expect(result).to include("ENTITY test_entity;")
      end
    end

    context "with invalid input" do
      it "raises error for non-repository input" do
        expect { Expressir.format("not a repository") }.to raise_error(ArgumentError)
      end
    end
  end

  describe ".reformat" do
    context "with valid EXPRESS input" do
      let(:unformatted_express) do
        <<~EXPRESS
          SCHEMA test_schema;TYPE test_type=STRING;END_TYPE;ENTITY test_entity;name:STRING;END_ENTITY;END_SCHEMA;
        EXPRESS
      end

      it "reformats EXPRESS code" do
        result = Expressir.reformat(unformatted_express)
        expect(result).to include("SCHEMA test_schema;")
        expect(result).to include("  TYPE test_type = STRING;")
        expect(result).to include("  ENTITY test_entity;")
        expect(result).to include("    name : STRING;")
      end
    end

    context "with invalid EXPRESS input" do
      let(:invalid_express) do
        "SCHEMA invalid syntax END_SCHEMA;"
      end

      it "raises error for invalid input" do
        expect { Expressir.reformat(invalid_express) }.to raise_error(Expressir::ParserError)
      end
    end
  end

  describe ".validate" do
    context "with valid repository" do
      let(:repository) do
        Expressir.parse(<<~EXPRESS)
          SCHEMA test_schema;
            TYPE positive_number = INTEGER;
              WHERE
                WR1: SELF > 0;
            END_TYPE;
          END_SCHEMA;
        EXPRESS
      end

      it "returns empty array for valid repository" do
        result = Expressir.validate(repository)
        expect(result).to be_empty
      end
    end

    context "with invalid repository" do
      let(:repository) do
        Expressir.parse(<<~EXPRESS)
          SCHEMA test_schema;
            TYPE invalid_type = NONEXISTENT_TYPE;
            END_TYPE;
          END_SCHEMA;
        EXPRESS
      end

      it "returns array of validation errors" do
        result = Expressir.validate(repository)
        expect(result).not_to be_empty
        expect(result.first).to be_a Expressir::Error
      end
    end
  end
end
--- END FILE: spec/expressir_spec.rb ---
--- START FILE: spec/spec_helper.rb ---
require "bundler/setup"
require "expressir"

Dir["./spec/support/**/*.rb"].sort.each { |file| require file }

RSpec.configure do |config|
  # Enable flags like --only-failures and --next-failure
  config.example_status_persistence_file_path = ".rspec_status"
  config.include Expressir::ConsoleHelper

  # Disable RSpec exposing methods globally on `Module` and `main`
  config.disable_monkey_patching!

  config.expect_with :rspec do |c|
    c.syntax = :expect
  end

  config.around(:example) do |ex|
    ex.run
  rescue SystemExit => e
    puts "Got SystemExit: #{e.inspect}."
    raise
  end
end
--- END FILE: spec/spec_helper.rb ---
--- START FILE: spec/support/console_helper.rb ---
module Expressir
  module ConsoleHelper
    def capture_stdout(&_block)
      original_stdout = $stdout
      $stdout = fake = StringIO.new

      begin
        yield
      ensure
        $stdout = original_stdout
      end

      fake.string
    end

    def capture_stderr(&_block)
      original_stderr = $stderr
      $stderr = fake = StringIO.new

      begin
        yield
      ensure
        $stderr = original_stderr
      end

      fake.string
    end
  end
end
--- END FILE: spec/support/console_helper.rb ---
--- START FILE: spec/syntax/multiple.exp ---
SCHEMA multiple_schema;
REFERENCE FROM multiple_schema2;
REFERENCE FROM multiple_schema3 (attribute_entity3);
REFERENCE FROM multiple_schema4 (attribute_entity AS attribute_entity4);
ENTITY test; END_ENTITY;
ENTITY empty_entity; END_ENTITY;
ENTITY attribute_entity; test : BOOLEAN; END_ENTITY;
ENTITY subtype_empty_entity SUBTYPE OF (empty_entity); END_ENTITY;
ENTITY subtype_attribute_entity SUBTYPE OF (attribute_entity); SELF\attribute_entity.test : BOOLEAN; END_ENTITY;
ENTITY subtype_attribute_entity2 SUBTYPE OF (attribute_entity2); SELF\attribute_entity2.test : BOOLEAN; END_ENTITY;
ENTITY subtype_attribute_entity3 SUBTYPE OF (attribute_entity3); SELF\attribute_entity3.test : BOOLEAN; END_ENTITY;
ENTITY subtype_attribute_entity4 SUBTYPE OF (attribute_entity4); SELF\attribute_entity4.test : BOOLEAN; END_ENTITY;
ENTITY subtype_missing_entity SUBTYPE OF (missing_entity); END_ENTITY;
END_SCHEMA;
SCHEMA multiple_schema2;
ENTITY attribute_entity2; test : BOOLEAN; END_ENTITY;
END_SCHEMA;
SCHEMA multiple_schema3;
ENTITY attribute_entity3; test : BOOLEAN; END_ENTITY;
END_SCHEMA;
SCHEMA multiple_schema4;
ENTITY attribute_entity; test : BOOLEAN; END_ENTITY;
END_SCHEMA;
--- END FILE: spec/syntax/multiple.exp ---
--- START FILE: spec/syntax/multiple.yaml ---
---
_class: Expressir::Model::Repository
schemas:
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/multiple.exp
  id: multiple_schema
  interfaces:
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: multiple_schema2
      base_path: multiple_schema2
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: multiple_schema3
      base_path: multiple_schema3
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: attribute_entity3
        base_path: multiple_schema3.attribute_entity3
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: multiple_schema4
      base_path: multiple_schema4
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: attribute_entity
        base_path: multiple_schema4.attribute_entity
      id: attribute_entity4
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: test
  - _class: Expressir::Model::Declarations::Entity
    id: empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_empty_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: multiple_schema.empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_attribute_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: multiple_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :EXPLICIT
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: multiple_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_attribute_entity2
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity2
      base_path: multiple_schema2.attribute_entity2
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :EXPLICIT
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity2
            base_path: multiple_schema2.attribute_entity2
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_attribute_entity3
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity3
      base_path: multiple_schema3.attribute_entity3
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :EXPLICIT
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity3
            base_path: multiple_schema3.attribute_entity3
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_attribute_entity4
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity4
      base_path: multiple_schema4.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :EXPLICIT
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity4
            base_path: multiple_schema4.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_missing_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: missing_entity
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/multiple.exp
  id: multiple_schema2
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_entity2
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/multiple.exp
  id: multiple_schema3
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_entity3
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/multiple.exp
  id: multiple_schema4
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
--- END FILE: spec/syntax/multiple.yaml ---
--- START FILE: spec/syntax/multiple_formatted.exp ---
SCHEMA multiple_schema;

REFERENCE FROM multiple_schema2;
REFERENCE FROM multiple_schema3
  (attribute_entity3);
REFERENCE FROM multiple_schema4
  (attribute_entity AS attribute_entity4);

ENTITY test;
END_ENTITY;

ENTITY empty_entity;
END_ENTITY;

ENTITY attribute_entity;
  test : BOOLEAN;
END_ENTITY;

ENTITY subtype_empty_entity
  SUBTYPE OF (empty_entity);
END_ENTITY;

ENTITY subtype_attribute_entity
  SUBTYPE OF (attribute_entity);
  SELF\attribute_entity.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_attribute_entity2
  SUBTYPE OF (attribute_entity2);
  SELF\attribute_entity2.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_attribute_entity3
  SUBTYPE OF (attribute_entity3);
  SELF\attribute_entity3.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_attribute_entity4
  SUBTYPE OF (attribute_entity4);
  SELF\attribute_entity4.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_missing_entity
  SUBTYPE OF (missing_entity);
END_ENTITY;

END_SCHEMA;

SCHEMA multiple_schema2;

ENTITY attribute_entity2;
  test : BOOLEAN;
END_ENTITY;

END_SCHEMA;

SCHEMA multiple_schema3;

ENTITY attribute_entity3;
  test : BOOLEAN;
END_ENTITY;

END_SCHEMA;

SCHEMA multiple_schema4;

ENTITY attribute_entity;
  test : BOOLEAN;
END_ENTITY;

END_SCHEMA;
--- END FILE: spec/syntax/multiple_formatted.exp ---
--- START FILE: spec/syntax/multiple_hyperlink_formatted.exp ---
SCHEMA multiple_schema;

REFERENCE FROM {{{<<express:multiple_schema2,multiple_schema2>>}}};
REFERENCE FROM {{{<<express:multiple_schema3,multiple_schema3>>}}}
  ({{{<<express:multiple_schema3.attribute_entity3,attribute_entity3>>}}});
REFERENCE FROM {{{<<express:multiple_schema4,multiple_schema4>>}}}
  ({{{<<express:multiple_schema4.attribute_entity,attribute_entity>>}}} AS attribute_entity4);

ENTITY test;
END_ENTITY;

ENTITY empty_entity;
END_ENTITY;

ENTITY attribute_entity;
  test : BOOLEAN;
END_ENTITY;

ENTITY subtype_empty_entity
  SUBTYPE OF ({{{<<express:multiple_schema.empty_entity,empty_entity>>}}});
END_ENTITY;

ENTITY subtype_attribute_entity
  SUBTYPE OF ({{{<<express:multiple_schema.attribute_entity,attribute_entity>>}}});
  SELF\{{{<<express:multiple_schema.attribute_entity,attribute_entity>>}}}.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_attribute_entity2
  SUBTYPE OF ({{{<<express:multiple_schema2.attribute_entity2,attribute_entity2>>}}});
  SELF\{{{<<express:multiple_schema2.attribute_entity2,attribute_entity2>>}}}.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_attribute_entity3
  SUBTYPE OF ({{{<<express:multiple_schema3.attribute_entity3,attribute_entity3>>}}});
  SELF\{{{<<express:multiple_schema3.attribute_entity3,attribute_entity3>>}}}.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_attribute_entity4
  SUBTYPE OF ({{{<<express:multiple_schema4.attribute_entity,attribute_entity4>>}}});
  SELF\{{{<<express:multiple_schema4.attribute_entity,attribute_entity4>>}}}.test : BOOLEAN;
END_ENTITY;

ENTITY subtype_missing_entity
  SUBTYPE OF (missing_entity);
END_ENTITY;

END_SCHEMA;

SCHEMA multiple_schema2;

ENTITY attribute_entity2;
  test : BOOLEAN;
END_ENTITY;

END_SCHEMA;

SCHEMA multiple_schema3;

ENTITY attribute_entity3;
  test : BOOLEAN;
END_ENTITY;

END_SCHEMA;

SCHEMA multiple_schema4;

ENTITY attribute_entity;
  test : BOOLEAN;
END_ENTITY;

END_SCHEMA;
--- END FILE: spec/syntax/multiple_hyperlink_formatted.exp ---
--- START FILE: spec/syntax/multiple_schema_head_hyperlink_formatted.exp ---
SCHEMA multiple_schema;

REFERENCE FROM {{{<<express:multiple_schema2,multiple_schema2>>}}};
REFERENCE FROM {{{<<express:multiple_schema3,multiple_schema3>>}}}
  ({{{<<express:multiple_schema3.attribute_entity3,attribute_entity3>>}}});
REFERENCE FROM {{{<<express:multiple_schema4,multiple_schema4>>}}}
  ({{{<<express:multiple_schema4.attribute_entity,attribute_entity>>}}} AS attribute_entity4);

SCHEMA multiple_schema2;

SCHEMA multiple_schema3;

SCHEMA multiple_schema4;
--- END FILE: spec/syntax/multiple_schema_head_hyperlink_formatted.exp ---
--- START FILE: spec/syntax/remark.exp ---
(*"remark_schema"
Any character within the EXPRESS character set may occur between the start and end of
an embedded remark including the newline character; therefore, embedded remarks can span
several physical lines.
*)
--"remark_schema" The tail remark is written at the end of a physical line.
--"remark_schema" UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.

--"remark_schema" universal scope - schema before

SCHEMA remark_schema;

CONSTANT remark_constant : STRING := 'xxx'; END_CONSTANT;
TYPE remark_type = ENUMERATION OF (remark_enumeration_item);
  WHERE WR1: TRUE;
  --"WR1" type scope - type where
  --"wr:WR1" type scope - type where, with prefix
  --"IP1" type scope - type informal proposition
  --"ip:IP1" type scope - type informal proposition, with prefix
END_TYPE;
ENTITY remark_entity;
  remark_attribute : STRING;
  DERIVE remark_derived_attribute : STRING := 'xxx';
  INVERSE remark_inverse_attribute : remark_entity FOR remark_attribute;
  UNIQUE UR1: remark_attribute;
  WHERE WR1:
  --"unusual_placement" placed inside WHERE clauses (or other enumerable context)
  TRUE;
  --"remark_attribute" entity scope - entity attribute
  --"remark_derived_attribute" entity scope - entity derived attribute
  --"remark_inverse_attribute" entity scope - entity inverse attribute
  --"UR1" entity scope - entity unique
  --"WR1" entity scope - entity where
  --"wr:WR1" entity scope - entity where, with prefix
  --"IP1" entity scope - entity informal proposition
  --"ip:IP1" entity scope - entity informal proposition, with prefix
END_ENTITY;
SUBTYPE_CONSTRAINT remark_subtype_constraint FOR remark_entity; END_SUBTYPE_CONSTRAINT;
FUNCTION remark_function(remark_parameter : STRING) : BOOLEAN;
  TYPE remark_type = ENUMERATION OF (remark_enumeration_item); END_TYPE;
  CONSTANT remark_constant : STRING := 'xxx'; END_CONSTANT;
  LOCAL remark_variable : STRING; END_LOCAL;
  ALIAS remark_alias FOR remark_variable; ;
    --"remark_alias" function alias scope - function alias
  END_ALIAS;
  REPEAT remark_repeat := 1 TO 9; ;
    --"remark_repeat" function repeat scope - function repeat
  END_REPEAT;
  remark_variable := QUERY(remark_query <* remark_variable | TRUE
    --"remark_query" function query scope - function query
  );
  --"remark_parameter" function scope - function parameter
  --"remark_type" function scope - function type
  --"remark_type.remark_enumeration_item" function scope - function enumeration item
  --"remark_enumeration_item" function scope - function enumeration item, on the same level as the type
  --"remark_constant" function scope - function constant
  --"remark_variable" function scope - function variable
END_FUNCTION;
RULE remark_rule FOR (remark_entity);
  TYPE remark_type = ENUMERATION OF (remark_enumeration_item); END_TYPE;
  CONSTANT remark_constant : STRING := 'xxx'; END_CONSTANT;
  LOCAL remark_variable : STRING; END_LOCAL;
  ALIAS remark_alias FOR remark_variable; ;
    --"remark_alias" rule alias scope - rule alias
  END_ALIAS;
  REPEAT remark_repeat := 1 TO 9; ;
    --"remark_repeat" rule repeat scope - rule repeat
  END_REPEAT;
  remark_variable := QUERY(remark_query <* remark_variable | TRUE
    --"remark_query" rule query scope - rule query
  );
  WHERE WR1: TRUE;
  --"remark_type" rule scope - rule type
  --"remark_type.remark_enumeration_item" rule scope - rule enumeration item
  --"remark_enumeration_item" rule scope - rule enumeration item, on the same level as the type
  --"remark_constant" rule scope - rule constant
  --"remark_variable" rule scope - rule variable
  --"WR1" rule scope - rule where
  --"wr:WR1" rule scope - rule where, with prefix
  --"IP1" rule scope - rule informal proposition
  --"ip:IP1" rule scope - rule informal proposition, with prefix
END_RULE;
PROCEDURE remark_procedure(remark_parameter : STRING);
  TYPE remark_type = ENUMERATION OF (remark_enumeration_item); END_TYPE;
  CONSTANT remark_constant : STRING := 'xxx'; END_CONSTANT;
  LOCAL remark_variable : STRING; END_LOCAL;
  ALIAS remark_alias FOR remark_variable; ;
    --"remark_alias" procedure alias scope - procedure alias
  END_ALIAS;
  REPEAT remark_repeat := 1 TO 9; ;
    --"remark_repeat" procedure repeat scope - procedure repeat
  END_REPEAT;
  remark_variable := QUERY(remark_query <* remark_variable | TRUE
    --"remark_query" procedure query scope - procedure query
  );
  --"remark_parameter" procedure scope - procedure parameter
  --"remark_type" procedure scope - procedure type
  --"remark_type.remark_enumeration_item" procedure scope - procedure enumeration item
  --"remark_enumeration_item" procedure scope - procedure enumeration item, on the same level as the type
  --"remark_constant" procedure scope - procedure constant
  --"remark_variable" procedure scope - procedure variable
END_PROCEDURE;

--"remark_constant" schema scope - constant
--"remark_type" schema scope - type
--"remark_type.WR1" schema scope - type where
--"remark_type.wr:WR1" schema scope - type where, with prefix
--"remark_type.IP1" schema scope - type informal proposition
--"remark_type.ip:IP1" schema scope - type informal proposition, with prefix
--"remark_type.remark_enumeration_item" schema scope - enumeration item
--"remark_enumeration_item" schema scope - enumeration item, on the same level as the type
--"remark_entity" schema scope - entity
--"remark_entity.remark_attribute" schema scope - entity attribute
--"remark_entity.remark_derived_attribute" schema scope - entity derived attribute
--"remark_entity.remark_inverse_attribute" schema scope - entity inverse attribute
--"remark_entity.UR1" schema scope - entity unique
--"remark_entity.WR1" schema scope - entity where
--"remark_entity.wr:WR1" schema scope - entity where, with prefix
--"remark_entity.IP1" schema scope - entity informal proposition
--"remark_entity.ip:IP1" schema scope - entity informal proposition, with prefix
--"remark_subtype_constraint" schema scope - subtype constraint
--"remark_function" schema scope - function
--"remark_function.remark_parameter" schema scope - function parameter
--"remark_function.remark_type" schema scope - function type
--"remark_function.remark_type.remark_enumeration_item" schema scope - function enumeration item
--"remark_function.remark_enumeration_item" schema scope - function enumeration item, on the same level as the type
--"remark_function.remark_constant" schema scope - function constant
--"remark_function.remark_variable" schema scope - function variable
--"remark_rule" schema scope - rule
--"remark_rule.remark_type" schema scope - rule type
--"remark_rule.remark_type.remark_enumeration_item" schema scope - rule enumeration item
--"remark_rule.remark_enumeration_item" schema scope - rule enumeration item, on the same level as the type
--"remark_rule.remark_constant" schema scope - rule constant
--"remark_rule.remark_variable" schema scope - rule variable
--"remark_rule.WR1" schema scope - rule where
--"remark_rule.wr:WR1" schema scope - rule where, with prefix
--"remark_rule.IP1" schema scope - rule informal proposition
--"remark_rule.ip:IP1" schema scope - rule informal proposition, with prefix
--"remark_procedure" schema scope - procedure
--"remark_procedure.remark_parameter" schema scope - procedure parameter
--"remark_procedure.remark_type" schema scope - procedure type
--"remark_procedure.remark_type.remark_enumeration_item" schema scope - procedure enumeration item
--"remark_procedure.remark_enumeration_item" schema scope - procedure enumeration item, on the same level as the type
--"remark_procedure.remark_constant" schema scope - procedure constant
--"remark_procedure.remark_variable" schema scope - procedure variable
--"remark_item" schema scope - schema remark item

END_SCHEMA;

--"remark_schema" universal scope - schema
--"remark_schema.remark_constant" universal scope - constant
--"remark_schema.remark_type" universal scope - type
--"remark_schema.remark_type.WR1" universal scope - type where
--"remark_schema.remark_type.wr:WR1" universal scope - type where, with prefix
--"remark_schema.remark_type.IP1" universal scope - type informal proposition
--"remark_schema.remark_type.ip:IP1" universal scope - type informal proposition, with prefix
--"remark_schema.remark_type.remark_enumeration_item" universal scope - enumeration item
--"remark_schema.remark_enumeration_item" universal scope - enumeration item, on the same level as the type
--"remark_schema.remark_entity" universal scope - entity
--"remark_schema.remark_entity.remark_attribute" universal scope - entity attribute
--"remark_schema.remark_entity.remark_derived_attribute" universal scope - entity derived attribute
--"remark_schema.remark_entity.remark_inverse_attribute" universal scope - entity inverse attribute
--"remark_schema.remark_entity.UR1" universal scope - entity unique
--"remark_schema.remark_entity.WR1" universal scope - entity where
--"remark_schema.remark_entity.wr:WR1" universal scope - entity where, with prefix
--"remark_schema.remark_entity.IP1" universal scope - entity informal proposition
--"remark_schema.remark_entity.ip:IP1" universal scope - entity informal proposition, with prefix
--"remark_schema.remark_subtype_constraint" universal scope - subtype constraint
--"remark_schema.remark_function" universal scope - function
--"remark_schema.remark_function.remark_parameter" universal scope - function parameter
--"remark_schema.remark_function.remark_type" universal scope - function type
--"remark_schema.remark_function.remark_type.remark_enumeration_item" universal scope - function enumeration item
--"remark_schema.remark_function.remark_enumeration_item" universal scope - function enumeration item, on the same level as the type
--"remark_schema.remark_function.remark_constant" universal scope - function constant
--"remark_schema.remark_function.remark_variable" universal scope - function variable
--"remark_schema.remark_rule" universal scope - rule
--"remark_schema.remark_rule.remark_type" universal scope - rule type
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" universal scope - rule enumeration item
--"remark_schema.remark_rule.remark_enumeration_item" universal scope - rule enumeration item, on the same level as the type
--"remark_schema.remark_rule.remark_constant" universal scope - rule constant
--"remark_schema.remark_rule.remark_variable" universal scope - rule variable
--"remark_schema.remark_rule.WR1" universal scope - rule where
--"remark_schema.remark_rule.wr:WR1" universal scope - rule where, with prefix
--"remark_schema.remark_rule.IP1" universal scope - rule informal proposition
--"remark_schema.remark_rule.ip:IP1" universal scope - rule informal proposition, with prefix
--"remark_schema.remark_procedure" universal scope - procedure
--"remark_schema.remark_procedure.remark_parameter" universal scope - procedure parameter
--"remark_schema.remark_procedure.remark_type" universal scope - procedure type
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" universal scope - procedure enumeration item
--"remark_schema.remark_procedure.remark_enumeration_item" universal scope - procedure enumeration item, on the same level as the type
--"remark_schema.remark_procedure.remark_constant" universal scope - procedure constant
--"remark_schema.remark_procedure.remark_variable" universal scope - procedure variable
--"remark_schema.remark_item" universal scope - schema remark item
--- END FILE: spec/syntax/remark.exp ---
--- START FILE: spec/syntax/remark.yaml ---
---
_class: Expressir::Model::Repository
schemas:
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/remark.exp
  id: remark_schema
  remarks:
  - |-
    Any character within the EXPRESS character set may occur between the start and end of
    an embedded remark including the newline character; therefore, embedded remarks can span
    several physical lines.
  - The tail remark is written at the end of a physical line.
  - 'UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.'
  - universal scope - schema before
  - universal scope - schema
  remark_items:
  - _class: Expressir::Model::Declarations::RemarkItem
    id: remark_item
    remarks:
    - schema scope - schema remark item
    - universal scope - schema remark item
  constants:
  - _class: Expressir::Model::Declarations::Constant
    id: remark_constant
    remarks:
    - schema scope - constant
    - universal scope - constant
    type:
      _class: Expressir::Model::DataTypes::String
    expression:
      _class: Expressir::Model::Literals::String
      value: xxx
  types:
  - _class: Expressir::Model::Declarations::Type
    id: remark_type
    remarks:
    - schema scope - type
    - universal scope - type
    underlying_type:
      _class: Expressir::Model::DataTypes::Enumeration
      items:
      - _class: Expressir::Model::DataTypes::EnumerationItem
        id: remark_enumeration_item
        remarks:
        - schema scope - enumeration item
        - schema scope - enumeration item, on the same level as the type
        - universal scope - enumeration item
        - universal scope - enumeration item, on the same level as the type
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      id: WR1
      remarks:
      - type scope - type where
      - type scope - type where, with prefix
      - schema scope - type where
      - schema scope - type where, with prefix
      - universal scope - type where
      - universal scope - type where, with prefix
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    informal_propositions:
    - _class: Expressir::Model::Declarations::RemarkItem
      id: IP1
      remarks:
      - type scope - type informal proposition
      - type scope - type informal proposition, with prefix
      - schema scope - type informal proposition
      - schema scope - type informal proposition, with prefix
      - universal scope - type informal proposition
      - universal scope - type informal proposition, with prefix
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: remark_entity
    remarks:
    - schema scope - entity
    - universal scope - entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: remark_attribute
      remarks:
      - entity scope - entity attribute
      - schema scope - entity attribute
      - universal scope - entity attribute
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Attribute
      id: remark_derived_attribute
      remarks:
      - entity scope - entity derived attribute
      - schema scope - entity derived attribute
      - universal scope - entity derived attribute
      kind: :DERIVED
      type:
        _class: Expressir::Model::DataTypes::String
      expression:
        _class: Expressir::Model::Literals::String
        value: xxx
    - _class: Expressir::Model::Declarations::Attribute
      id: remark_inverse_attribute
      remarks:
      - entity scope - entity inverse attribute
      - schema scope - entity inverse attribute
      - universal scope - entity inverse attribute
      kind: :INVERSE
      type:
        _class: Expressir::Model::References::SimpleReference
        id: remark_entity
        base_path: remark_schema.remark_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: remark_attribute
        base_path: remark_schema.remark_entity.remark_attribute
    unique_rules:
    - _class: Expressir::Model::Declarations::UniqueRule
      id: UR1
      remarks:
      - entity scope - entity unique
      - schema scope - entity unique
      - universal scope - entity unique
      attributes:
      - _class: Expressir::Model::References::SimpleReference
        id: remark_attribute
        base_path: remark_schema.remark_entity.remark_attribute
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      id: WR1
      remarks:
      - entity scope - entity where
      - entity scope - entity where, with prefix
      - schema scope - entity where
      - schema scope - entity where, with prefix
      - universal scope - entity where
      - universal scope - entity where, with prefix
      remark_items:
      - _class: Expressir::Model::Declarations::RemarkItem
        id: unusual_placement
        remarks:
        - placed inside WHERE clauses (or other enumerable context)
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    informal_propositions:
    - _class: Expressir::Model::Declarations::RemarkItem
      id: IP1
      remarks:
      - entity scope - entity informal proposition
      - entity scope - entity informal proposition, with prefix
      - schema scope - entity informal proposition
      - schema scope - entity informal proposition, with prefix
      - universal scope - entity informal proposition
      - universal scope - entity informal proposition, with prefix
  subtype_constraints:
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: remark_subtype_constraint
    remarks:
    - schema scope - subtype constraint
    - universal scope - subtype constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: remark_entity
      base_path: remark_schema.remark_entity
  functions:
  - _class: Expressir::Model::Declarations::Function
    id: remark_function
    remarks:
    - schema scope - function
    - universal scope - function
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: remark_parameter
      remarks:
      - function scope - function parameter
      - schema scope - function parameter
      - universal scope - function parameter
      type:
        _class: Expressir::Model::DataTypes::String
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    types:
    - _class: Expressir::Model::Declarations::Type
      id: remark_type
      remarks:
      - function scope - function type
      - schema scope - function type
      - universal scope - function type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: remark_enumeration_item
          remarks:
          - function scope - function enumeration item
          - function scope - function enumeration item, on the same level as the type
          - schema scope - function enumeration item
          - schema scope - function enumeration item, on the same level as the type
          - universal scope - function enumeration item
          - universal scope - function enumeration item, on the same level as the
            type
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: remark_constant
      remarks:
      - function scope - function constant
      - schema scope - function constant
      - universal scope - function constant
      type:
        _class: Expressir::Model::DataTypes::String
      expression:
        _class: Expressir::Model::Literals::String
        value: xxx
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: remark_variable
      remarks:
      - function scope - function variable
      - schema scope - function variable
      - universal scope - function variable
      type:
        _class: Expressir::Model::DataTypes::String
    statements:
    - _class: Expressir::Model::Statements::Alias
      id: remark_alias
      remarks:
      - function alias scope - function alias
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: remark_variable
        base_path: remark_schema.remark_function.remark_variable
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Statements::Repeat
      id: remark_repeat
      remarks:
      - function repeat scope - function repeat
      bound1:
        _class: Expressir::Model::Literals::Integer
        value: '1'
      bound2:
        _class: Expressir::Model::Literals::Integer
        value: '9'
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Statements::Assignment
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: remark_variable
        base_path: remark_schema.remark_function.remark_variable
      expression:
        _class: Expressir::Model::Expressions::QueryExpression
        id: remark_query
        remarks:
        - function query scope - function query
        aggregate_source:
          _class: Expressir::Model::References::SimpleReference
          id: remark_variable
          base_path: remark_schema.remark_function.remark_variable
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
  rules:
  - _class: Expressir::Model::Declarations::Rule
    id: remark_rule
    remarks:
    - schema scope - rule
    - universal scope - rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: remark_entity
      base_path: remark_schema.remark_entity
    types:
    - _class: Expressir::Model::Declarations::Type
      id: remark_type
      remarks:
      - rule scope - rule type
      - schema scope - rule type
      - universal scope - rule type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: remark_enumeration_item
          remarks:
          - rule scope - rule enumeration item
          - rule scope - rule enumeration item, on the same level as the type
          - schema scope - rule enumeration item
          - schema scope - rule enumeration item, on the same level as the type
          - universal scope - rule enumeration item
          - universal scope - rule enumeration item, on the same level as the type
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: remark_constant
      remarks:
      - rule scope - rule constant
      - schema scope - rule constant
      - universal scope - rule constant
      type:
        _class: Expressir::Model::DataTypes::String
      expression:
        _class: Expressir::Model::Literals::String
        value: xxx
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: remark_variable
      remarks:
      - rule scope - rule variable
      - schema scope - rule variable
      - universal scope - rule variable
      type:
        _class: Expressir::Model::DataTypes::String
    statements:
    - _class: Expressir::Model::Statements::Alias
      id: remark_alias
      remarks:
      - rule alias scope - rule alias
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: remark_variable
        base_path: remark_schema.remark_rule.remark_variable
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Statements::Repeat
      id: remark_repeat
      remarks:
      - rule repeat scope - rule repeat
      bound1:
        _class: Expressir::Model::Literals::Integer
        value: '1'
      bound2:
        _class: Expressir::Model::Literals::Integer
        value: '9'
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Statements::Assignment
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: remark_variable
        base_path: remark_schema.remark_rule.remark_variable
      expression:
        _class: Expressir::Model::Expressions::QueryExpression
        id: remark_query
        remarks:
        - rule query scope - rule query
        aggregate_source:
          _class: Expressir::Model::References::SimpleReference
          id: remark_variable
          base_path: remark_schema.remark_rule.remark_variable
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      id: WR1
      remarks:
      - rule scope - rule where
      - rule scope - rule where, with prefix
      - schema scope - rule where
      - schema scope - rule where, with prefix
      - universal scope - rule where
      - universal scope - rule where, with prefix
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    informal_propositions:
    - _class: Expressir::Model::Declarations::RemarkItem
      id: IP1
      remarks:
      - rule scope - rule informal proposition
      - rule scope - rule informal proposition, with prefix
      - schema scope - rule informal proposition
      - schema scope - rule informal proposition, with prefix
      - universal scope - rule informal proposition
      - universal scope - rule informal proposition, with prefix
  procedures:
  - _class: Expressir::Model::Declarations::Procedure
    id: remark_procedure
    remarks:
    - schema scope - procedure
    - universal scope - procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: remark_parameter
      remarks:
      - procedure scope - procedure parameter
      - schema scope - procedure parameter
      - universal scope - procedure parameter
      type:
        _class: Expressir::Model::DataTypes::String
    types:
    - _class: Expressir::Model::Declarations::Type
      id: remark_type
      remarks:
      - procedure scope - procedure type
      - schema scope - procedure type
      - universal scope - procedure type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: remark_enumeration_item
          remarks:
          - procedure scope - procedure enumeration item
          - procedure scope - procedure enumeration item, on the same level as the
            type
          - schema scope - procedure enumeration item
          - schema scope - procedure enumeration item, on the same level as the type
          - universal scope - procedure enumeration item
          - universal scope - procedure enumeration item, on the same level as the
            type
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: remark_constant
      remarks:
      - procedure scope - procedure constant
      - schema scope - procedure constant
      - universal scope - procedure constant
      type:
        _class: Expressir::Model::DataTypes::String
      expression:
        _class: Expressir::Model::Literals::String
        value: xxx
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: remark_variable
      remarks:
      - procedure scope - procedure variable
      - schema scope - procedure variable
      - universal scope - procedure variable
      type:
        _class: Expressir::Model::DataTypes::String
    statements:
    - _class: Expressir::Model::Statements::Alias
      id: remark_alias
      remarks:
      - procedure alias scope - procedure alias
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: remark_variable
        base_path: remark_schema.remark_procedure.remark_variable
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Statements::Repeat
      id: remark_repeat
      remarks:
      - procedure repeat scope - procedure repeat
      bound1:
        _class: Expressir::Model::Literals::Integer
        value: '1'
      bound2:
        _class: Expressir::Model::Literals::Integer
        value: '9'
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Statements::Assignment
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: remark_variable
        base_path: remark_schema.remark_procedure.remark_variable
      expression:
        _class: Expressir::Model::Expressions::QueryExpression
        id: remark_query
        remarks:
        - procedure query scope - procedure query
        aggregate_source:
          _class: Expressir::Model::References::SimpleReference
          id: remark_variable
          base_path: remark_schema.remark_procedure.remark_variable
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
--- END FILE: spec/syntax/remark.yaml ---
--- START FILE: spec/syntax/remark_formatted.exp ---
SCHEMA remark_schema;

CONSTANT
  remark_constant : STRING := 'xxx';
END_CONSTANT;

TYPE remark_type = ENUMERATION OF
  (remark_enumeration_item);
WHERE
  WR1: TRUE;
END_TYPE;

ENTITY remark_entity;
  remark_attribute : STRING;
DERIVE
  remark_derived_attribute : STRING := 'xxx';
INVERSE
  remark_inverse_attribute : remark_entity FOR remark_attribute;
UNIQUE
  UR1: remark_attribute;
WHERE
  WR1: TRUE;
END_ENTITY;

SUBTYPE_CONSTRAINT remark_subtype_constraint FOR remark_entity;
END_SUBTYPE_CONSTRAINT;

FUNCTION remark_function(remark_parameter : STRING) : BOOLEAN;
  TYPE remark_type = ENUMERATION OF
    (remark_enumeration_item);
  END_TYPE;
  CONSTANT
    remark_constant : STRING := 'xxx';
  END_CONSTANT;
  LOCAL
    remark_variable : STRING;
  END_LOCAL;
  ALIAS remark_alias FOR remark_variable;
    ;
  --"remark_alias" function alias scope - function alias
  END_ALIAS;
  REPEAT remark_repeat := 1 TO 9;
    ;
  --"remark_repeat" function repeat scope - function repeat
  END_REPEAT;
  remark_variable := QUERY(remark_query <* remark_variable | TRUE
  --"remark_query" function query scope - function query
  );
END_FUNCTION;

RULE remark_rule FOR (remark_entity);
  TYPE remark_type = ENUMERATION OF
    (remark_enumeration_item);
  END_TYPE;
  CONSTANT
    remark_constant : STRING := 'xxx';
  END_CONSTANT;
  LOCAL
    remark_variable : STRING;
  END_LOCAL;
  ALIAS remark_alias FOR remark_variable;
    ;
  --"remark_alias" rule alias scope - rule alias
  END_ALIAS;
  REPEAT remark_repeat := 1 TO 9;
    ;
  --"remark_repeat" rule repeat scope - rule repeat
  END_REPEAT;
  remark_variable := QUERY(remark_query <* remark_variable | TRUE
  --"remark_query" rule query scope - rule query
  );
WHERE
  WR1: TRUE;
END_RULE;

PROCEDURE remark_procedure(remark_parameter : STRING);
  TYPE remark_type = ENUMERATION OF
    (remark_enumeration_item);
  END_TYPE;
  CONSTANT
    remark_constant : STRING := 'xxx';
  END_CONSTANT;
  LOCAL
    remark_variable : STRING;
  END_LOCAL;
  ALIAS remark_alias FOR remark_variable;
    ;
  --"remark_alias" procedure alias scope - procedure alias
  END_ALIAS;
  REPEAT remark_repeat := 1 TO 9;
    ;
  --"remark_repeat" procedure repeat scope - procedure repeat
  END_REPEAT;
  remark_variable := QUERY(remark_query <* remark_variable | TRUE
  --"remark_query" procedure query scope - procedure query
  );
END_PROCEDURE;

END_SCHEMA;
(*"remark_schema"
Any character within the EXPRESS character set may occur between the start and end of
an embedded remark including the newline character; therefore, embedded remarks can span
several physical lines.
*)
--"remark_schema" The tail remark is written at the end of a physical line.
--"remark_schema" UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.
--"remark_schema" universal scope - schema before
--"remark_schema" universal scope - schema
--"remark_schema.remark_constant" schema scope - constant
--"remark_schema.remark_constant" universal scope - constant
--"remark_schema.remark_type" schema scope - type
--"remark_schema.remark_type" universal scope - type
--"remark_schema.remark_type.remark_enumeration_item" schema scope - enumeration item
--"remark_schema.remark_type.remark_enumeration_item" schema scope - enumeration item, on the same level as the type
--"remark_schema.remark_type.remark_enumeration_item" universal scope - enumeration item
--"remark_schema.remark_type.remark_enumeration_item" universal scope - enumeration item, on the same level as the type
--"remark_schema.remark_type.WR1" type scope - type where
--"remark_schema.remark_type.WR1" type scope - type where, with prefix
--"remark_schema.remark_type.WR1" schema scope - type where
--"remark_schema.remark_type.WR1" schema scope - type where, with prefix
--"remark_schema.remark_type.WR1" universal scope - type where
--"remark_schema.remark_type.WR1" universal scope - type where, with prefix
--"remark_schema.remark_type.IP1" type scope - type informal proposition
--"remark_schema.remark_type.IP1" type scope - type informal proposition, with prefix
--"remark_schema.remark_type.IP1" schema scope - type informal proposition
--"remark_schema.remark_type.IP1" schema scope - type informal proposition, with prefix
--"remark_schema.remark_type.IP1" universal scope - type informal proposition
--"remark_schema.remark_type.IP1" universal scope - type informal proposition, with prefix
--"remark_schema.remark_entity" schema scope - entity
--"remark_schema.remark_entity" universal scope - entity
--"remark_schema.remark_entity.remark_attribute" entity scope - entity attribute
--"remark_schema.remark_entity.remark_attribute" schema scope - entity attribute
--"remark_schema.remark_entity.remark_attribute" universal scope - entity attribute
--"remark_schema.remark_entity.remark_derived_attribute" entity scope - entity derived attribute
--"remark_schema.remark_entity.remark_derived_attribute" schema scope - entity derived attribute
--"remark_schema.remark_entity.remark_derived_attribute" universal scope - entity derived attribute
--"remark_schema.remark_entity.remark_inverse_attribute" entity scope - entity inverse attribute
--"remark_schema.remark_entity.remark_inverse_attribute" schema scope - entity inverse attribute
--"remark_schema.remark_entity.remark_inverse_attribute" universal scope - entity inverse attribute
--"remark_schema.remark_entity.UR1" entity scope - entity unique
--"remark_schema.remark_entity.UR1" schema scope - entity unique
--"remark_schema.remark_entity.UR1" universal scope - entity unique
--"remark_schema.remark_entity.WR1" entity scope - entity where
--"remark_schema.remark_entity.WR1" entity scope - entity where, with prefix
--"remark_schema.remark_entity.WR1" schema scope - entity where
--"remark_schema.remark_entity.WR1" schema scope - entity where, with prefix
--"remark_schema.remark_entity.WR1" universal scope - entity where
--"remark_schema.remark_entity.WR1" universal scope - entity where, with prefix
--"remark_schema.remark_entity.WR1.unusual_placement" placed inside WHERE clauses (or other enumerable context)
--"remark_schema.remark_entity.IP1" entity scope - entity informal proposition
--"remark_schema.remark_entity.IP1" entity scope - entity informal proposition, with prefix
--"remark_schema.remark_entity.IP1" schema scope - entity informal proposition
--"remark_schema.remark_entity.IP1" schema scope - entity informal proposition, with prefix
--"remark_schema.remark_entity.IP1" universal scope - entity informal proposition
--"remark_schema.remark_entity.IP1" universal scope - entity informal proposition, with prefix
--"remark_schema.remark_subtype_constraint" schema scope - subtype constraint
--"remark_schema.remark_subtype_constraint" universal scope - subtype constraint
--"remark_schema.remark_function" schema scope - function
--"remark_schema.remark_function" universal scope - function
--"remark_schema.remark_function.remark_parameter" function scope - function parameter
--"remark_schema.remark_function.remark_parameter" schema scope - function parameter
--"remark_schema.remark_function.remark_parameter" universal scope - function parameter
--"remark_schema.remark_function.remark_type" function scope - function type
--"remark_schema.remark_function.remark_type" schema scope - function type
--"remark_schema.remark_function.remark_type" universal scope - function type
--"remark_schema.remark_function.remark_type.remark_enumeration_item" function scope - function enumeration item
--"remark_schema.remark_function.remark_type.remark_enumeration_item" function scope - function enumeration item, on the same level as the type
--"remark_schema.remark_function.remark_type.remark_enumeration_item" schema scope - function enumeration item
--"remark_schema.remark_function.remark_type.remark_enumeration_item" schema scope - function enumeration item, on the same level as the type
--"remark_schema.remark_function.remark_type.remark_enumeration_item" universal scope - function enumeration item
--"remark_schema.remark_function.remark_type.remark_enumeration_item" universal scope - function enumeration item, on the same level as the type
--"remark_schema.remark_function.remark_constant" function scope - function constant
--"remark_schema.remark_function.remark_constant" schema scope - function constant
--"remark_schema.remark_function.remark_constant" universal scope - function constant
--"remark_schema.remark_function.remark_variable" function scope - function variable
--"remark_schema.remark_function.remark_variable" schema scope - function variable
--"remark_schema.remark_function.remark_variable" universal scope - function variable
--"remark_schema.remark_rule" schema scope - rule
--"remark_schema.remark_rule" universal scope - rule
--"remark_schema.remark_rule.remark_type" rule scope - rule type
--"remark_schema.remark_rule.remark_type" schema scope - rule type
--"remark_schema.remark_rule.remark_type" universal scope - rule type
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" rule scope - rule enumeration item
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" rule scope - rule enumeration item, on the same level as the type
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" schema scope - rule enumeration item
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" schema scope - rule enumeration item, on the same level as the type
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" universal scope - rule enumeration item
--"remark_schema.remark_rule.remark_type.remark_enumeration_item" universal scope - rule enumeration item, on the same level as the type
--"remark_schema.remark_rule.remark_constant" rule scope - rule constant
--"remark_schema.remark_rule.remark_constant" schema scope - rule constant
--"remark_schema.remark_rule.remark_constant" universal scope - rule constant
--"remark_schema.remark_rule.remark_variable" rule scope - rule variable
--"remark_schema.remark_rule.remark_variable" schema scope - rule variable
--"remark_schema.remark_rule.remark_variable" universal scope - rule variable
--"remark_schema.remark_rule.WR1" rule scope - rule where
--"remark_schema.remark_rule.WR1" rule scope - rule where, with prefix
--"remark_schema.remark_rule.WR1" schema scope - rule where
--"remark_schema.remark_rule.WR1" schema scope - rule where, with prefix
--"remark_schema.remark_rule.WR1" universal scope - rule where
--"remark_schema.remark_rule.WR1" universal scope - rule where, with prefix
--"remark_schema.remark_rule.IP1" rule scope - rule informal proposition
--"remark_schema.remark_rule.IP1" rule scope - rule informal proposition, with prefix
--"remark_schema.remark_rule.IP1" schema scope - rule informal proposition
--"remark_schema.remark_rule.IP1" schema scope - rule informal proposition, with prefix
--"remark_schema.remark_rule.IP1" universal scope - rule informal proposition
--"remark_schema.remark_rule.IP1" universal scope - rule informal proposition, with prefix
--"remark_schema.remark_procedure" schema scope - procedure
--"remark_schema.remark_procedure" universal scope - procedure
--"remark_schema.remark_procedure.remark_parameter" procedure scope - procedure parameter
--"remark_schema.remark_procedure.remark_parameter" schema scope - procedure parameter
--"remark_schema.remark_procedure.remark_parameter" universal scope - procedure parameter
--"remark_schema.remark_procedure.remark_type" procedure scope - procedure type
--"remark_schema.remark_procedure.remark_type" schema scope - procedure type
--"remark_schema.remark_procedure.remark_type" universal scope - procedure type
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" procedure scope - procedure enumeration item
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" procedure scope - procedure enumeration item, on the same level as the type
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" schema scope - procedure enumeration item
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" schema scope - procedure enumeration item, on the same level as the type
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" universal scope - procedure enumeration item
--"remark_schema.remark_procedure.remark_type.remark_enumeration_item" universal scope - procedure enumeration item, on the same level as the type
--"remark_schema.remark_procedure.remark_constant" procedure scope - procedure constant
--"remark_schema.remark_procedure.remark_constant" schema scope - procedure constant
--"remark_schema.remark_procedure.remark_constant" universal scope - procedure constant
--"remark_schema.remark_procedure.remark_variable" procedure scope - procedure variable
--"remark_schema.remark_procedure.remark_variable" schema scope - procedure variable
--"remark_schema.remark_procedure.remark_variable" universal scope - procedure variable
--"remark_schema.remark_item" schema scope - schema remark item
--"remark_schema.remark_item" universal scope - schema remark item
--- END FILE: spec/syntax/remark_formatted.exp ---
--- START FILE: spec/syntax/single.exp ---
SCHEMA single_schema 'version';
ENTITY empty_entity; END_ENTITY;
ENTITY subtype_empty_entity SUBTYPE OF (empty_entity); END_ENTITY;
END_SCHEMA;
--- END FILE: spec/syntax/single.exp ---
--- START FILE: spec/syntax/single.yaml ---
---
_class: Expressir::Model::Repository
schemas:
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/single.exp
  id: single_schema
  version:
    _class: Expressir::Model::Declarations::SchemaVersion
    value: version
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_empty_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: single_schema.empty_entity
--- END FILE: spec/syntax/single.yaml ---
--- START FILE: spec/syntax/single_formatted.exp ---
SCHEMA single_schema 'version';

ENTITY empty_entity;
END_ENTITY;

ENTITY subtype_empty_entity
  SUBTYPE OF (empty_entity);
END_ENTITY;

END_SCHEMA;
--- END FILE: spec/syntax/single_formatted.exp ---
--- START FILE: spec/syntax/single_formatted.yaml ---
---
_class: Expressir::Model::Repository
schemas:
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/single.exp
  id: single_schema
  version:
    _class: Expressir::Model::Declarations::SchemaVersion
    value: version
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: empty_entity
    source: |-
      ENTITY empty_entity;
      END_ENTITY;
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_empty_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: single_schema.empty_entity
    source: |-
      ENTITY subtype_empty_entity
        SUBTYPE OF (empty_entity);
      END_ENTITY;
  source: |-
    SCHEMA single_schema 'version';

    ENTITY empty_entity;
    END_ENTITY;

    ENTITY subtype_empty_entity
      SUBTYPE OF (empty_entity);
    END_ENTITY;

    END_SCHEMA;
--- END FILE: spec/syntax/single_formatted.yaml ---
--- START FILE: spec/syntax/syntax.exp ---
-- schema
SCHEMA syntax_schema '{ISO standard 10303 part(41) object(1) version(8)}';

-- interfaces
USE FROM contract_schema;
USE FROM contract_schema (contract);
USE FROM contract_schema (contract, contract2);
USE FROM contract_schema (contract AS contract2);
REFERENCE FROM contract_schema;
REFERENCE FROM contract_schema (contract);
REFERENCE FROM contract_schema (contract, contract2);
REFERENCE FROM contract_schema (contract AS contract2);

-- constants
CONSTANT empty_constant : BOOLEAN := TRUE; END_CONSTANT;

-- types
TYPE empty_type = BOOLEAN; END_TYPE;
TYPE where_type = BOOLEAN; WHERE TRUE; END_TYPE;
TYPE where_label_type = BOOLEAN; WHERE WR1: TRUE; END_TYPE;

-- entities
ENTITY empty_entity; END_ENTITY;
ENTITY abstract_entity ABSTRACT; END_ENTITY;
ENTITY abstract_supertype_entity ABSTRACT SUPERTYPE; END_ENTITY;
ENTITY abstract_supertype_constraint_entity ABSTRACT SUPERTYPE OF (empty_entity); END_ENTITY;
ENTITY supertype_constraint_entity SUPERTYPE OF (empty_entity); END_ENTITY;
ENTITY subtype_entity SUBTYPE OF (empty_entity); END_ENTITY;
ENTITY supertype_constraint_subtype_entity SUPERTYPE OF (empty_entity) SUBTYPE OF (empty_entity); END_ENTITY;
ENTITY attribute_entity; test : BOOLEAN; END_ENTITY;
ENTITY attribute_optional_entity; test : OPTIONAL BOOLEAN; END_ENTITY;
ENTITY attribute_multiple_entity; test : BOOLEAN; test2 : BOOLEAN; END_ENTITY;
ENTITY attribute_multiple_shorthand_entity; test, test2 : BOOLEAN; END_ENTITY;
ENTITY attribute_redeclared_entity SUBTYPE OF (attribute_entity); SELF\attribute_entity.test : BOOLEAN; END_ENTITY;
ENTITY attribute_redeclared_renamed_entity SUBTYPE OF (attribute_entity); SELF\attribute_entity.test RENAMED test2 : BOOLEAN; END_ENTITY;
ENTITY derived_attribute_entity; DERIVE test : BOOLEAN := TRUE; END_ENTITY;
ENTITY derived_attribute_redeclared_entity SUBTYPE OF (attribute_entity); DERIVE SELF\attribute_entity.test : BOOLEAN := TRUE; END_ENTITY;
ENTITY derived_attribute_redeclared_renamed_entity SUBTYPE OF (attribute_entity); DERIVE SELF\attribute_entity.test RENAMED test2 : BOOLEAN := TRUE; END_ENTITY;
ENTITY inverse_attribute_entity; INVERSE test : attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_entity_entity; INVERSE test : attribute_entity FOR attribute_entity.test; END_ENTITY;
ENTITY inverse_attribute_set_entity; INVERSE test : SET OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_set_bound_entity; INVERSE test : SET [1:9] OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_bag_entity; INVERSE test : BAG OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_bag_bound_entity; INVERSE test : BAG [1:9] OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_redeclared_entity SUBTYPE OF (attribute_entity); INVERSE SELF\attribute_entity.test : attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_redeclared_renamed_entity SUBTYPE OF (attribute_entity); INVERSE SELF\attribute_entity.test RENAMED test2 : attribute_entity FOR test; END_ENTITY;
ENTITY unique_entity; test : BOOLEAN; UNIQUE test; END_ENTITY;
ENTITY unique_label_entity; test : BOOLEAN; UNIQUE UR1: test; END_ENTITY;
ENTITY unique_redeclared_entity SUBTYPE OF (attribute_entity); UNIQUE SELF\attribute_entity.test; END_ENTITY;
ENTITY unique_label_redeclared_entity SUBTYPE OF (attribute_entity); UNIQUE UR1: SELF\attribute_entity.test; END_ENTITY;
ENTITY where_entity; WHERE TRUE; END_ENTITY;
ENTITY where_label_entity; WHERE WR1: TRUE; END_ENTITY;

-- subtype constraints
SUBTYPE_CONSTRAINT empty_subtype_constraint FOR empty_entity; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT abstract_supertype_subtype_constraint FOR empty_entity; ABSTRACT SUPERTYPE; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT total_over_subtype_constraint FOR empty_entity; TOTAL_OVER(a); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_subtype_constraint FOR empty_entity; a; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_andor_subtype_constraint FOR empty_entity; a ANDOR b; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_subtype_constraint FOR empty_entity; a AND b; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_andor_and_subtype_constraint FOR empty_entity; a ANDOR b AND c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_andor_subtype_constraint FOR empty_entity; a AND b ANDOR c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_parenthesis_andor_and_subtype_constraint FOR empty_entity; (a ANDOR b) AND c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_parenthesis_andor_subtype_constraint FOR empty_entity; a AND (b ANDOR c); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_subtype_constraint FOR empty_entity; ONEOF(a, b); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_oneof_subtype_constraint FOR empty_entity; a AND ONEOF(b, c); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_andor_oneof_subtype_constraint FOR empty_entity; a ANDOR ONEOF(b, c); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_and_subtype_constraint FOR empty_entity; ONEOF(a, b) AND c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_subtype_constraint FOR empty_entity; ONEOF(a, b) ANDOR c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_and_oneof_subtype_constraint FOR empty_entity; ONEOF(a, b) AND ONEOF(c, d); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_oneof_subtype_constraint FOR empty_entity; ONEOF(a, b) ANDOR ONEOF(c, d); END_SUBTYPE_CONSTRAINT;

-- functions
FUNCTION empty_function : BOOLEAN; ; END_FUNCTION;
FUNCTION parameter_function(test : BOOLEAN) : BOOLEAN; ; END_FUNCTION;
FUNCTION multiple_parameter_function(test : BOOLEAN; test2 : BOOLEAN) : BOOLEAN; ; END_FUNCTION;
FUNCTION multiple_shorthand_parameter_function(test, test2 : BOOLEAN) : BOOLEAN; ; END_FUNCTION;
FUNCTION type_function : BOOLEAN; TYPE test = BOOLEAN; END_TYPE; ; END_FUNCTION;
FUNCTION constant_function : BOOLEAN; CONSTANT test : BOOLEAN := TRUE; END_CONSTANT; ; END_FUNCTION;
FUNCTION multiple_constant_function : BOOLEAN; CONSTANT test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_CONSTANT; ; END_FUNCTION;
FUNCTION variable_function : BOOLEAN; LOCAL test : BOOLEAN; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_variable_function : BOOLEAN; LOCAL test : BOOLEAN; test2 : BOOLEAN; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_shorthand_variable_function : BOOLEAN; LOCAL test, test2 : BOOLEAN; END_LOCAL; ; END_FUNCTION;
FUNCTION variable_expression_function : BOOLEAN; LOCAL test : BOOLEAN := TRUE; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_variable_expression_function : BOOLEAN; LOCAL test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_shorthand_variable_expression_function : BOOLEAN; LOCAL test, test2 : BOOLEAN := TRUE; END_LOCAL; ; END_FUNCTION;

-- rules
RULE empty_rule FOR (empty_entity); WHERE TRUE; END_RULE;
RULE type_rule FOR (empty_entity); TYPE test = BOOLEAN; END_TYPE; WHERE TRUE; END_RULE;
RULE constant_rule FOR (empty_entity); CONSTANT test : BOOLEAN := TRUE; END_CONSTANT; WHERE TRUE; END_RULE;
RULE multiple_constant_rule FOR (empty_entity); CONSTANT test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_CONSTANT; WHERE TRUE; END_RULE;
RULE variable_rule FOR (empty_entity); LOCAL test : BOOLEAN; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_variable_rule FOR (empty_entity); LOCAL test : BOOLEAN; test2 : BOOLEAN; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_shorthand_variable_rule FOR (empty_entity); LOCAL test, test2 : BOOLEAN; END_LOCAL; WHERE TRUE; END_RULE;
RULE variable_expression_rule FOR (empty_entity); LOCAL test : BOOLEAN := TRUE; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_variable_expression_rule FOR (empty_entity); LOCAL test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_shorthand_variable_expression_rule FOR (empty_entity); LOCAL test, test2 : BOOLEAN := TRUE; END_LOCAL; WHERE TRUE; END_RULE;
RULE statement_rule FOR (empty_entity); ; WHERE TRUE; END_RULE;
RULE where_label_rule FOR (empty_entity); WHERE WR1: TRUE; END_RULE;

-- procedures
PROCEDURE empty_procedure; END_PROCEDURE;
PROCEDURE parameter_procedure(test : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_parameter_procedure(test : BOOLEAN; test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_shorthand_parameter_procedure(test, test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE variable_parameter_procedure(VAR test : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_variable_parameter_procedure(VAR test : BOOLEAN; test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_variable_parameter2_procedure(test : BOOLEAN; VAR test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_shorthand_variable_parameter_procedure(VAR test, test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE type_procedure; TYPE test = BOOLEAN; END_TYPE; END_PROCEDURE;
PROCEDURE constant_procedure; CONSTANT test : BOOLEAN := TRUE; END_CONSTANT; END_PROCEDURE;
PROCEDURE multiple_constant_procedure; CONSTANT test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_CONSTANT; END_PROCEDURE;
PROCEDURE variable_procedure; LOCAL test : BOOLEAN; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_variable_procedure; LOCAL test : BOOLEAN; test2 : BOOLEAN; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_shorthand_variable_procedure; LOCAL test, test2 : BOOLEAN; END_LOCAL; END_PROCEDURE;
PROCEDURE variable_expression_procedure; LOCAL test : BOOLEAN := TRUE; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_variable_expression_procedure; LOCAL test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_shorthand_variable_expression_procedure; LOCAL test, test2 : BOOLEAN := TRUE; END_LOCAL; END_PROCEDURE;
PROCEDURE statement_procedure; ; END_PROCEDURE;

PROCEDURE statements;
  -- statements
  PROCEDURE alias_simple_reference_statement; ALIAS test FOR test; ; END_ALIAS; END_PROCEDURE;
  PROCEDURE alias_group_reference_statement; ALIAS test FOR test\test2; ; END_ALIAS; END_PROCEDURE;
  PROCEDURE alias_index_reference_statement; ALIAS test FOR test[1]; ; END_ALIAS; END_PROCEDURE;
  PROCEDURE alias_index2_reference_statement; ALIAS test FOR test[1:9]; ; END_ALIAS; END_PROCEDURE;
  PROCEDURE alias_attribute_reference_statement; ALIAS test FOR test.test2; ; END_ALIAS; END_PROCEDURE;
  PROCEDURE assignment_simple_reference_statement; test := TRUE; END_PROCEDURE;
  PROCEDURE assignment_group_reference_statement; test\test2 := TRUE; END_PROCEDURE;
  PROCEDURE assignment_index_reference_statement; test[1] := TRUE; END_PROCEDURE;
  PROCEDURE assignment_index2_reference_statement; test[1:9] := TRUE; END_PROCEDURE;
  PROCEDURE assignment_attribute_reference_statement; test.test2 := TRUE; END_PROCEDURE;
  PROCEDURE case_statement; CASE test OF TRUE : ; END_CASE; END_PROCEDURE;
  PROCEDURE case_multiple_statement; CASE test OF TRUE : ; TRUE : ; END_CASE; END_PROCEDURE;
  PROCEDURE case_multiple_shorthand_statement; CASE test OF TRUE, TRUE : ; END_CASE; END_PROCEDURE;
  PROCEDURE case_otherwise_statement; CASE test OF TRUE : ; OTHERWISE : ; END_CASE; END_PROCEDURE;
  PROCEDURE compound_statement; BEGIN ; END; END_PROCEDURE;
  PROCEDURE escape_statement; ESCAPE; END_PROCEDURE;
  PROCEDURE if_statement; IF TRUE THEN ; END_IF; END_PROCEDURE;
  PROCEDURE if2_statement; IF TRUE THEN ; ; END_IF; END_PROCEDURE;
  PROCEDURE if_else_statement; IF TRUE THEN ; ELSE ; END_IF; END_PROCEDURE;
  PROCEDURE if2_else_statement; IF TRUE THEN ; ; ELSE ; END_IF; END_PROCEDURE;
  PROCEDURE if_else2_statement; IF TRUE THEN ; ELSE ; ; END_IF; END_PROCEDURE;
  PROCEDURE if2_else2_statement; IF TRUE THEN ; ; ELSE ; ; END_IF; END_PROCEDURE;
  PROCEDURE null_statement; ; END_PROCEDURE;
  PROCEDURE call_statement; empty_procedure; END_PROCEDURE;
  PROCEDURE call_parameter_statement; empty_procedure(TRUE); END_PROCEDURE;
  PROCEDURE call_parameter2_statement; empty_procedure(TRUE, TRUE); END_PROCEDURE;
  PROCEDURE call_insert_statement; INSERT(TRUE); END_PROCEDURE;
  PROCEDURE call_remove_statement; REMOVE(TRUE); END_PROCEDURE;
  PROCEDURE repeat_statement; REPEAT; ; END_REPEAT; END_PROCEDURE;
  PROCEDURE repeat_variable_statement; REPEAT test := 1 TO 9; ; END_REPEAT; END_PROCEDURE;
  PROCEDURE repeat_variable_increment_statement; REPEAT test := 1 TO 9 BY 2; ; END_REPEAT; END_PROCEDURE;
  PROCEDURE repeat_while_statement; REPEAT WHILE TRUE; ; END_REPEAT; END_PROCEDURE;
  PROCEDURE repeat_until_statement; REPEAT UNTIL TRUE; ; END_REPEAT; END_PROCEDURE;
  PROCEDURE return_statement; RETURN; END_PROCEDURE;
  PROCEDURE return_expression_statement; RETURN (TRUE); END_PROCEDURE;
  PROCEDURE skip_statement; SKIP; END_PROCEDURE;
END_PROCEDURE;

PROCEDURE types;
  -- simple types
  TYPE binary_type = BINARY; END_TYPE;
  TYPE binary_width_type = BINARY (3); END_TYPE;
  TYPE binary_width_fixed_type = BINARY (3) FIXED; END_TYPE;
  TYPE boolean_type = BOOLEAN; END_TYPE;
  TYPE integer_type = INTEGER; END_TYPE;
  TYPE logical_type = LOGICAL; END_TYPE;
  TYPE number_type = NUMBER; END_TYPE;
  TYPE real_type = REAL; END_TYPE;
  TYPE real_precision_type = REAL (3); END_TYPE;
  TYPE string_type = STRING; END_TYPE;
  TYPE string_width_type = STRING (3); END_TYPE;
  TYPE string_width_fixed_type = STRING (3) FIXED; END_TYPE;

  -- aggregation types
  TYPE array_type = ARRAY [1:9] OF STRING; END_TYPE;
  TYPE array_optional_type = ARRAY [1:9] OF OPTIONAL STRING; END_TYPE;
  TYPE array_unique_type = ARRAY [1:9] OF UNIQUE STRING; END_TYPE;
  TYPE array_optional_unique_type = ARRAY [1:9] OF OPTIONAL UNIQUE STRING; END_TYPE;
  TYPE bag_type = BAG OF STRING; END_TYPE;
  TYPE bag_bound_type = BAG [1:9] OF STRING; END_TYPE;
  TYPE list_type = LIST OF STRING; END_TYPE;
  TYPE list_bound_type = LIST [1:9] OF STRING; END_TYPE;
  TYPE list_unique_type = LIST OF UNIQUE STRING; END_TYPE;
  TYPE list_bound_unique_type = LIST [1:9] OF UNIQUE STRING; END_TYPE;
  TYPE set_type = SET OF STRING; END_TYPE;
  TYPE set_bound_type = SET [1:9] OF STRING; END_TYPE;

  -- constructed types
  TYPE select_type = SELECT; END_TYPE;
  TYPE select_extensible_type = EXTENSIBLE SELECT; END_TYPE;
  TYPE select_extensible_generic_entity_type = EXTENSIBLE GENERIC_ENTITY SELECT; END_TYPE;
  TYPE select_item_type = SELECT (empty_type); END_TYPE;
  TYPE select_multiple_item_type = SELECT (empty_type, empty_type); END_TYPE;
  TYPE select_based_on_type = SELECT BASED_ON select_type; END_TYPE;
  TYPE select_based_on_item_type = SELECT BASED_ON select_type WITH (empty_type); END_TYPE;
  TYPE select_based_on_multiple_item_type = SELECT BASED_ON select_type WITH (empty_type, empty_type); END_TYPE;
  TYPE enumeration_type = ENUMERATION; END_TYPE;
  TYPE enumeration_extensible_type = EXTENSIBLE ENUMERATION; END_TYPE;
  TYPE enumeration_item_type = ENUMERATION OF (test); END_TYPE;
  TYPE enumeration_multiple_item_type = ENUMERATION OF (test, test2); END_TYPE;
  TYPE enumeration_based_on_type = ENUMERATION BASED_ON enumeration_type; END_TYPE;
  TYPE enumeration_based_on_item_type = ENUMERATION BASED_ON enumeration_type WITH (test); END_TYPE;
  TYPE enumeration_based_on_multiple_item_type = ENUMERATION BASED_ON enumeration_type WITH (test, test2); END_TYPE;

  -- generic types
  FUNCTION generic_type : GENERIC; ; END_FUNCTION;
  FUNCTION generic_label_type : GENERIC:label; ; END_FUNCTION;
  FUNCTION generic_entity_type : GENERIC_ENTITY; ; END_FUNCTION;
  FUNCTION generic_entity_label_type : GENERIC_ENTITY:label; ; END_FUNCTION;
END_PROCEDURE;

PROCEDURE expressions;
  LOCAL
    -- literal expressions
    binary_expression : BOOLEAN := %011110000111100001111000;
    integer_expression : BOOLEAN := 999;
    true_logical_expression : BOOLEAN := TRUE;
    false_logical_expression : BOOLEAN := FALSE;
    unknown_logical_expression : BOOLEAN := UNKNOWN;
    real_expression : BOOLEAN := 999.999;
    simple_string_expression : BOOLEAN := 'xxx';
    utf8_simple_string_expression : BOOLEAN := 'UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.';
    encoded_string_expression : BOOLEAN := "000000780000007800000078";

    -- constant expressions
    const_e_expression : BOOLEAN := CONST_E;
    indeterminate_expression : BOOLEAN := ?;
    pi_expression : BOOLEAN := PI;
    self_expression : BOOLEAN := SELF;

    -- function expressions
    abs_expression : BOOLEAN := ABS(TRUE);
    acos_expression : BOOLEAN := ACOS(TRUE);
    asin_expression : BOOLEAN := ASIN(TRUE);
    atan_expression : BOOLEAN := ATAN(TRUE);
    blength_expression : BOOLEAN := BLENGTH(TRUE);
    cos_expression : BOOLEAN := COS(TRUE);
    exists_expression : BOOLEAN := EXISTS(TRUE);
    exp_expression : BOOLEAN := EXP(TRUE);
    format_expression : BOOLEAN := FORMAT(TRUE);
    hibound_expression : BOOLEAN := HIBOUND(TRUE);
    hiindex_expression : BOOLEAN := HIINDEX(TRUE);
    length_expression : BOOLEAN := LENGTH(TRUE);
    lobound_expression : BOOLEAN := LOBOUND(TRUE);
    loindex_expression : BOOLEAN := LOINDEX(TRUE);
    log_expression : BOOLEAN := LOG(TRUE);
    log2_expression : BOOLEAN := LOG2(TRUE);
    log10_expression : BOOLEAN := LOG10(TRUE);
    nvl_expression : BOOLEAN := NVL(TRUE);
    odd_expression : BOOLEAN := ODD(TRUE);
    rolesof_expression : BOOLEAN := ROLESOF(TRUE);
    sin_expression : BOOLEAN := SIN(TRUE);
    sizeof_expression : BOOLEAN := SIZEOF(TRUE);
    sqrt_expression : BOOLEAN := SQRT(TRUE);
    tan_expression : BOOLEAN := TAN(TRUE);
    typeof_expression : BOOLEAN := TYPEOF(TRUE);
    usedin_expression : BOOLEAN := USEDIN(TRUE);
    value_expression : BOOLEAN := VALUE(TRUE);
    value_in_expression : BOOLEAN := VALUE_IN(TRUE);
    value_unique_expression : BOOLEAN := VALUE_UNIQUE(TRUE);

    -- operator expressions
    plus_expression : BOOLEAN := +4;
    plus_addition_expression : BOOLEAN := +(4 + 2);
    minus_expression : BOOLEAN := -4;
    minus_addition_expression : BOOLEAN := -(4 + 2);
    addition_expression : BOOLEAN := 4 + 2;
    subtraction_expression : BOOLEAN := 4 - 2;
    multiplication_expression : BOOLEAN := 4 * 2;
    real_division_expression : BOOLEAN := 4 / 2;
    integer_division_expression : BOOLEAN := 4 DIV 2;
    modulo_expression : BOOLEAN := 4 MOD 2;
    exponentiation_expression : BOOLEAN := 4 ** 2;
    addition_addition_expression : BOOLEAN := 4 + 2 + 1;
    subtraction_subtraction_expression : BOOLEAN := 4 - 2 - 1;
    addition_subtraction_expression : BOOLEAN := 4 + 2 - 1;
    subtraction_addition_expression : BOOLEAN := 4 - 2 + 1;
    addition_multiplication_expression : BOOLEAN := 8 + 4 * 2;
    multiplication_addition_expression : BOOLEAN := 8 * 4 + 2;
    parenthesis_addition_multiplication_expression : BOOLEAN := (8 + 4) * 2;
    multiplication_parenthesis_addition_expression : BOOLEAN := 8 * (4 + 2);
    equal_expression : BOOLEAN := 4 = 2;
    not_equal_expression : BOOLEAN := 4 <> 2;
    instance_equal_expression : BOOLEAN := 4 :=: 2;
    instance_not_equal_expression : BOOLEAN := 4 :<>: 2;
    lt_expression : BOOLEAN := 4 < 2;
    gt_expression : BOOLEAN := 4 > 2;
    lte_expression : BOOLEAN := 4 <= 2;
    gte_expression : BOOLEAN := 4 >= 2;
    not_expression : BOOLEAN := NOT TRUE;
    not_or_expression : BOOLEAN := NOT (TRUE OR FALSE);
    or_expression : BOOLEAN := TRUE OR FALSE;
    and_expression : BOOLEAN := TRUE AND FALSE;
    or_or_expression : BOOLEAN := TRUE OR FALSE OR TRUE;
    and_and_expression : BOOLEAN := TRUE AND FALSE AND TRUE;
    or_and_expression : BOOLEAN := TRUE OR FALSE AND TRUE;
    and_or_expression : BOOLEAN := TRUE AND FALSE OR TRUE;
    parenthesis_or_and_expression : BOOLEAN := (TRUE OR FALSE) AND TRUE;
    and_parenthesis_or_expression : BOOLEAN := TRUE AND (FALSE OR TRUE);
    combine_expression : BOOLEAN := test || test2;
    in_expression : BOOLEAN := TRUE IN [TRUE];
    like_expression : BOOLEAN := 'xxx' LIKE 'xxx';

    -- aggregate initializer expressions
    aggregate_initializer_expression : BOOLEAN := [4];
    repeated_aggregate_initializer_expression : BOOLEAN := [4:2];
    complex_aggregate_initializer_expression : BOOLEAN := [4 + 2];
    complex_repeated_aggregate_initializer_expression : BOOLEAN := [4 + 2:4 + 2];

    -- function call or entity constructor expressions
    call_expression : BOOLEAN := parameter_function(TRUE);

    -- reference expressions
    simple_reference_expression : BOOLEAN := test;
    group_reference_expression : BOOLEAN := test\test2;
    index_reference_expression : BOOLEAN := test[1];
    index2_reference_expression : BOOLEAN := test[1:9];
    attribute_reference_expression : BOOLEAN := test.test2;

    -- interval expressions
    lt_lt_interval_expression : BOOLEAN := {1 < 5 < 9};
    lte_lt_interval_expression : BOOLEAN := {1 <= 5 < 9};
    lt_lte_interval_expression : BOOLEAN := {1 < 5 <= 9};
    lte_lte_interval_expression : BOOLEAN := {1 <= 5 <= 9};

    -- query expressions
    query_expression : BOOLEAN := QUERY(test <* test2 | TRUE);
  END_LOCAL;
END_PROCEDURE;
END_SCHEMA;
--- END FILE: spec/syntax/syntax.exp ---
--- START FILE: spec/syntax/syntax.yaml ---
---
_class: Expressir::Model::Repository
schemas:
- _class: Expressir::Model::Declarations::Schema
  file: spec/syntax/syntax.exp
  id: syntax_schema
  version:
    _class: Expressir::Model::Declarations::SchemaVersion
    value: "{ISO standard 10303 part(41) object(1) version(8)}"
    items:
    - _class: Expressir::Model::Declarations::SchemaVersionItem
      name: ISO
    - _class: Expressir::Model::Declarations::SchemaVersionItem
      name: standard
    - _class: Expressir::Model::Declarations::SchemaVersionItem
      value: '10303'
    - _class: Expressir::Model::Declarations::SchemaVersionItem
      name: part
      value: '41'
    - _class: Expressir::Model::Declarations::SchemaVersionItem
      name: object
      value: '1'
    - _class: Expressir::Model::Declarations::SchemaVersionItem
      name: version
      value: '8'
  interfaces:
  - _class: Expressir::Model::Declarations::Interface
    kind: :USE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
  - _class: Expressir::Model::Declarations::Interface
    kind: :USE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract
  - _class: Expressir::Model::Declarations::Interface
    kind: :USE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract2
  - _class: Expressir::Model::Declarations::Interface
    kind: :USE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract
      id: contract2
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract2
  - _class: Expressir::Model::Declarations::Interface
    kind: :REFERENCE
    schema:
      _class: Expressir::Model::References::SimpleReference
      id: contract_schema
    items:
    - _class: Expressir::Model::Declarations::InterfaceItem
      ref:
        _class: Expressir::Model::References::SimpleReference
        id: contract
      id: contract2
  constants:
  - _class: Expressir::Model::Declarations::Constant
    id: empty_constant
    type:
      _class: Expressir::Model::DataTypes::Boolean
    expression:
      _class: Expressir::Model::Literals::Logical
      value: :TRUE
  types:
  - _class: Expressir::Model::Declarations::Type
    id: empty_type
    underlying_type:
      _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Type
    id: where_type
    underlying_type:
      _class: Expressir::Model::DataTypes::Boolean
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Type
    id: where_label_type
    underlying_type:
      _class: Expressir::Model::DataTypes::Boolean
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      id: WR1
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  entities:
  - _class: Expressir::Model::Declarations::Entity
    id: empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: abstract_entity
    abstract: true
  - _class: Expressir::Model::Declarations::Entity
    id: abstract_supertype_entity
    abstract: true
  - _class: Expressir::Model::Declarations::Entity
    id: abstract_supertype_constraint_entity
    abstract: true
    supertype_expression:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: supertype_constraint_entity
    supertype_expression:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: subtype_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: supertype_constraint_subtype_entity
    supertype_expression:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_optional_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      optional: true
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_multiple_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Attribute
      id: test2
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_multiple_shorthand_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Attribute
      id: test2
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_redeclared_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :EXPLICIT
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: attribute_redeclared_renamed_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test2
      kind: :EXPLICIT
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Entity
    id: derived_attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :DERIVED
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Entity
    id: derived_attribute_redeclared_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :DERIVED
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Entity
    id: derived_attribute_redeclared_renamed_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test2
      kind: :DERIVED
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :INVERSE
      type:
        _class: Expressir::Model::References::SimpleReference
        id: attribute_entity
        base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.inverse_attribute_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_entity_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :INVERSE
      type:
        _class: Expressir::Model::References::SimpleReference
        id: attribute_entity
        base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::SimpleReference
          id: attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_set_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :INVERSE
      type:
        _class: Expressir::Model::DataTypes::Set
        base_type:
          _class: Expressir::Model::References::SimpleReference
          id: attribute_entity
          base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.inverse_attribute_set_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_set_bound_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :INVERSE
      type:
        _class: Expressir::Model::DataTypes::Set
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        base_type:
          _class: Expressir::Model::References::SimpleReference
          id: attribute_entity
          base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.inverse_attribute_set_bound_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_bag_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :INVERSE
      type:
        _class: Expressir::Model::DataTypes::Bag
        base_type:
          _class: Expressir::Model::References::SimpleReference
          id: attribute_entity
          base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.inverse_attribute_bag_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_bag_bound_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :INVERSE
      type:
        _class: Expressir::Model::DataTypes::Bag
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        base_type:
          _class: Expressir::Model::References::SimpleReference
          id: attribute_entity
          base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.inverse_attribute_bag_bound_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_redeclared_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      kind: :INVERSE
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::References::SimpleReference
        id: attribute_entity
        base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
  - _class: Expressir::Model::Declarations::Entity
    id: inverse_attribute_redeclared_renamed_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test2
      kind: :INVERSE
      supertype_attribute:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
      type:
        _class: Expressir::Model::References::SimpleReference
        id: attribute_entity
        base_path: syntax_schema.attribute_entity
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
  - _class: Expressir::Model::Declarations::Entity
    id: unique_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
    unique_rules:
    - _class: Expressir::Model::Declarations::UniqueRule
      attributes:
      - _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.unique_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: unique_label_entity
    attributes:
    - _class: Expressir::Model::Declarations::Attribute
      id: test
      kind: :EXPLICIT
      type:
        _class: Expressir::Model::DataTypes::Boolean
    unique_rules:
    - _class: Expressir::Model::Declarations::UniqueRule
      id: UR1
      attributes:
      - _class: Expressir::Model::References::SimpleReference
        id: test
        base_path: syntax_schema.unique_label_entity.test
  - _class: Expressir::Model::Declarations::Entity
    id: unique_redeclared_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    unique_rules:
    - _class: Expressir::Model::Declarations::UniqueRule
      attributes:
      - _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
  - _class: Expressir::Model::Declarations::Entity
    id: unique_label_redeclared_entity
    subtype_of:
    - _class: Expressir::Model::References::SimpleReference
      id: attribute_entity
      base_path: syntax_schema.attribute_entity
    unique_rules:
    - _class: Expressir::Model::Declarations::UniqueRule
      id: UR1
      attributes:
      - _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: SELF
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: attribute_entity
            base_path: syntax_schema.attribute_entity
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test
  - _class: Expressir::Model::Declarations::Entity
    id: where_entity
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Entity
    id: where_label_entity
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      id: WR1
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  subtype_constraints:
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: empty_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: abstract_supertype_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    abstract: true
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: total_over_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    total_over:
    - _class: Expressir::Model::References::SimpleReference
      id: a
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::References::SimpleReference
      id: a
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_andor_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :ANDOR
      operand1:
        _class: Expressir::Model::References::SimpleReference
        id: a
      operand2:
        _class: Expressir::Model::References::SimpleReference
        id: b
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_and_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :AND
      operand1:
        _class: Expressir::Model::References::SimpleReference
        id: a
      operand2:
        _class: Expressir::Model::References::SimpleReference
        id: b
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_andor_and_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :ANDOR
      operand1:
        _class: Expressir::Model::References::SimpleReference
        id: a
      operand2:
        _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
        operator: :AND
        operand1:
          _class: Expressir::Model::References::SimpleReference
          id: b
        operand2:
          _class: Expressir::Model::References::SimpleReference
          id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_and_andor_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :ANDOR
      operand1:
        _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
        operator: :AND
        operand1:
          _class: Expressir::Model::References::SimpleReference
          id: a
        operand2:
          _class: Expressir::Model::References::SimpleReference
          id: b
      operand2:
        _class: Expressir::Model::References::SimpleReference
        id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_parenthesis_andor_and_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :AND
      operand1:
        _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
        operator: :ANDOR
        operand1:
          _class: Expressir::Model::References::SimpleReference
          id: a
        operand2:
          _class: Expressir::Model::References::SimpleReference
          id: b
      operand2:
        _class: Expressir::Model::References::SimpleReference
        id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_and_parenthesis_andor_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :AND
      operand1:
        _class: Expressir::Model::References::SimpleReference
        id: a
      operand2:
        _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
        operator: :ANDOR
        operand1:
          _class: Expressir::Model::References::SimpleReference
          id: b
        operand2:
          _class: Expressir::Model::References::SimpleReference
          id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_oneof_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
      operands:
      - _class: Expressir::Model::References::SimpleReference
        id: a
      - _class: Expressir::Model::References::SimpleReference
        id: b
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_and_oneof_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :AND
      operand1:
        _class: Expressir::Model::References::SimpleReference
        id: a
      operand2:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: b
        - _class: Expressir::Model::References::SimpleReference
          id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_andor_oneof_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :ANDOR
      operand1:
        _class: Expressir::Model::References::SimpleReference
        id: a
      operand2:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: b
        - _class: Expressir::Model::References::SimpleReference
          id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_oneof_and_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :AND
      operand1:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: a
        - _class: Expressir::Model::References::SimpleReference
          id: b
      operand2:
        _class: Expressir::Model::References::SimpleReference
        id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_oneof_andor_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :ANDOR
      operand1:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: a
        - _class: Expressir::Model::References::SimpleReference
          id: b
      operand2:
        _class: Expressir::Model::References::SimpleReference
        id: c
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_oneof_and_oneof_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :AND
      operand1:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: a
        - _class: Expressir::Model::References::SimpleReference
          id: b
      operand2:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: c
        - _class: Expressir::Model::References::SimpleReference
          id: d
  - _class: Expressir::Model::Declarations::SubtypeConstraint
    id: supertype_expression_oneof_andor_oneof_subtype_constraint
    applies_to:
      _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    supertype_expression:
      _class: Expressir::Model::SupertypeExpressions::BinarySupertypeExpression
      operator: :ANDOR
      operand1:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: a
        - _class: Expressir::Model::References::SimpleReference
          id: b
      operand2:
        _class: Expressir::Model::SupertypeExpressions::OneofSupertypeExpression
        operands:
        - _class: Expressir::Model::References::SimpleReference
          id: c
        - _class: Expressir::Model::References::SimpleReference
          id: d
  functions:
  - _class: Expressir::Model::Declarations::Function
    id: empty_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: parameter_function
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_parameter_function
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_shorthand_parameter_function
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: type_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    types:
    - _class: Expressir::Model::Declarations::Type
      id: test
      underlying_type:
        _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: constant_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_constant_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Constant
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: variable_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_variable_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_shorthand_variable_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: variable_expression_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_variable_expression_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Function
    id: multiple_shorthand_variable_expression_function
    return_type:
      _class: Expressir::Model::DataTypes::Boolean
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    statements:
    - _class: Expressir::Model::Statements::Null
  rules:
  - _class: Expressir::Model::Declarations::Rule
    id: empty_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: type_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    types:
    - _class: Expressir::Model::Declarations::Type
      id: test
      underlying_type:
        _class: Expressir::Model::DataTypes::Boolean
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: constant_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: multiple_constant_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Constant
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: variable_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: multiple_variable_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: multiple_shorthand_variable_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: variable_expression_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: multiple_variable_expression_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: multiple_shorthand_variable_expression_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: statement_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    statements:
    - _class: Expressir::Model::Statements::Null
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Rule
    id: where_label_rule
    applies_to:
    - _class: Expressir::Model::References::SimpleReference
      id: empty_entity
      base_path: syntax_schema.empty_entity
    where_rules:
    - _class: Expressir::Model::Declarations::WhereRule
      id: WR1
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  procedures:
  - _class: Expressir::Model::Declarations::Procedure
    id: empty_procedure
  - _class: Expressir::Model::Declarations::Procedure
    id: parameter_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_parameter_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_shorthand_parameter_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: variable_parameter_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      var: true
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_variable_parameter_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      var: true
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_variable_parameter2_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      var: true
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_shorthand_variable_parameter_procedure
    parameters:
    - _class: Expressir::Model::Declarations::Parameter
      id: test
      var: true
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Parameter
      id: test2
      var: true
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: type_procedure
    types:
    - _class: Expressir::Model::Declarations::Type
      id: test
      underlying_type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: constant_procedure
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_constant_procedure
    constants:
    - _class: Expressir::Model::Declarations::Constant
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Constant
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Procedure
    id: variable_procedure
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_variable_procedure
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_shorthand_variable_procedure
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
  - _class: Expressir::Model::Declarations::Procedure
    id: variable_expression_procedure
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_variable_expression_procedure
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Procedure
    id: multiple_shorthand_variable_expression_procedure
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: test
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: test2
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
  - _class: Expressir::Model::Declarations::Procedure
    id: statement_procedure
    statements:
    - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Procedure
    id: statements
    procedures:
    - _class: Expressir::Model::Declarations::Procedure
      id: alias_simple_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Alias
        id: test
        expression:
          _class: Expressir::Model::References::SimpleReference
          id: test
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: alias_group_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Alias
        id: test
        expression:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: test2
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: alias_index_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Alias
        id: test
        expression:
          _class: Expressir::Model::References::IndexReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          index1:
            _class: Expressir::Model::Literals::Integer
            value: '1'
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: alias_index2_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Alias
        id: test
        expression:
          _class: Expressir::Model::References::IndexReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          index1:
            _class: Expressir::Model::Literals::Integer
            value: '1'
          index2:
            _class: Expressir::Model::Literals::Integer
            value: '9'
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: alias_attribute_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Alias
        id: test
        expression:
          _class: Expressir::Model::References::AttributeReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          attribute:
            _class: Expressir::Model::References::SimpleReference
            id: test2
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: assignment_simple_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Assignment
        ref:
          _class: Expressir::Model::References::SimpleReference
          id: test
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: assignment_group_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Assignment
        ref:
          _class: Expressir::Model::References::GroupReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          entity:
            _class: Expressir::Model::References::SimpleReference
            id: test2
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: assignment_index_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Assignment
        ref:
          _class: Expressir::Model::References::IndexReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          index1:
            _class: Expressir::Model::Literals::Integer
            value: '1'
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: assignment_index2_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Assignment
        ref:
          _class: Expressir::Model::References::IndexReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          index1:
            _class: Expressir::Model::Literals::Integer
            value: '1'
          index2:
            _class: Expressir::Model::Literals::Integer
            value: '9'
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: assignment_attribute_reference_statement
      statements:
      - _class: Expressir::Model::Statements::Assignment
        ref:
          _class: Expressir::Model::References::AttributeReference
          ref:
            _class: Expressir::Model::References::SimpleReference
            id: test
          attribute:
            _class: Expressir::Model::References::SimpleReference
            id: test2
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: case_statement
      statements:
      - _class: Expressir::Model::Statements::Case
        expression:
          _class: Expressir::Model::References::SimpleReference
          id: test
        actions:
        - _class: Expressir::Model::Statements::CaseAction
          labels:
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
          statement:
            _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: case_multiple_statement
      statements:
      - _class: Expressir::Model::Statements::Case
        expression:
          _class: Expressir::Model::References::SimpleReference
          id: test
        actions:
        - _class: Expressir::Model::Statements::CaseAction
          labels:
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
          statement:
            _class: Expressir::Model::Statements::Null
        - _class: Expressir::Model::Statements::CaseAction
          labels:
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
          statement:
            _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: case_multiple_shorthand_statement
      statements:
      - _class: Expressir::Model::Statements::Case
        expression:
          _class: Expressir::Model::References::SimpleReference
          id: test
        actions:
        - _class: Expressir::Model::Statements::CaseAction
          labels:
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
          statement:
            _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: case_otherwise_statement
      statements:
      - _class: Expressir::Model::Statements::Case
        expression:
          _class: Expressir::Model::References::SimpleReference
          id: test
        actions:
        - _class: Expressir::Model::Statements::CaseAction
          labels:
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
          statement:
            _class: Expressir::Model::Statements::Null
        otherwise_statement:
          _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: compound_statement
      statements:
      - _class: Expressir::Model::Statements::Compound
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: escape_statement
      statements:
      - _class: Expressir::Model::Statements::Escape
    - _class: Expressir::Model::Declarations::Procedure
      id: if_statement
      statements:
      - _class: Expressir::Model::Statements::If
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: if2_statement
      statements:
      - _class: Expressir::Model::Statements::If
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: if_else_statement
      statements:
      - _class: Expressir::Model::Statements::If
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
        else_statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: if2_else_statement
      statements:
      - _class: Expressir::Model::Statements::If
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
        - _class: Expressir::Model::Statements::Null
        else_statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: if_else2_statement
      statements:
      - _class: Expressir::Model::Statements::If
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
        else_statements:
        - _class: Expressir::Model::Statements::Null
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: if2_else2_statement
      statements:
      - _class: Expressir::Model::Statements::If
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
        - _class: Expressir::Model::Statements::Null
        else_statements:
        - _class: Expressir::Model::Statements::Null
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: null_statement
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: call_statement
      statements:
      - _class: Expressir::Model::Statements::ProcedureCall
        procedure:
          _class: Expressir::Model::References::SimpleReference
          id: empty_procedure
          base_path: syntax_schema.empty_procedure
    - _class: Expressir::Model::Declarations::Procedure
      id: call_parameter_statement
      statements:
      - _class: Expressir::Model::Statements::ProcedureCall
        procedure:
          _class: Expressir::Model::References::SimpleReference
          id: empty_procedure
          base_path: syntax_schema.empty_procedure
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: call_parameter2_statement
      statements:
      - _class: Expressir::Model::Statements::ProcedureCall
        procedure:
          _class: Expressir::Model::References::SimpleReference
          id: empty_procedure
          base_path: syntax_schema.empty_procedure
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: call_insert_statement
      statements:
      - _class: Expressir::Model::Statements::ProcedureCall
        procedure:
          _class: Expressir::Model::References::SimpleReference
          id: INSERT
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: call_remove_statement
      statements:
      - _class: Expressir::Model::Statements::ProcedureCall
        procedure:
          _class: Expressir::Model::References::SimpleReference
          id: REMOVE
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: repeat_statement
      statements:
      - _class: Expressir::Model::Statements::Repeat
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: repeat_variable_statement
      statements:
      - _class: Expressir::Model::Statements::Repeat
        id: test
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: repeat_variable_increment_statement
      statements:
      - _class: Expressir::Model::Statements::Repeat
        id: test
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        increment:
          _class: Expressir::Model::Literals::Integer
          value: '2'
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: repeat_while_statement
      statements:
      - _class: Expressir::Model::Statements::Repeat
        while_expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: repeat_until_statement
      statements:
      - _class: Expressir::Model::Statements::Repeat
        until_expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        statements:
        - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Procedure
      id: return_statement
      statements:
      - _class: Expressir::Model::Statements::Return
    - _class: Expressir::Model::Declarations::Procedure
      id: return_expression_statement
      statements:
      - _class: Expressir::Model::Statements::Return
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Procedure
      id: skip_statement
      statements:
      - _class: Expressir::Model::Statements::Skip
  - _class: Expressir::Model::Declarations::Procedure
    id: types
    types:
    - _class: Expressir::Model::Declarations::Type
      id: binary_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Binary
    - _class: Expressir::Model::Declarations::Type
      id: binary_width_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Binary
        width:
          _class: Expressir::Model::Literals::Integer
          value: '3'
    - _class: Expressir::Model::Declarations::Type
      id: binary_width_fixed_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Binary
        width:
          _class: Expressir::Model::Literals::Integer
          value: '3'
        fixed: true
    - _class: Expressir::Model::Declarations::Type
      id: boolean_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Boolean
    - _class: Expressir::Model::Declarations::Type
      id: integer_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Integer
    - _class: Expressir::Model::Declarations::Type
      id: logical_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Logical
    - _class: Expressir::Model::Declarations::Type
      id: number_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Number
    - _class: Expressir::Model::Declarations::Type
      id: real_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Real
    - _class: Expressir::Model::Declarations::Type
      id: real_precision_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Real
        precision:
          _class: Expressir::Model::Literals::Integer
          value: '3'
    - _class: Expressir::Model::Declarations::Type
      id: string_type
      underlying_type:
        _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: string_width_type
      underlying_type:
        _class: Expressir::Model::DataTypes::String
        width:
          _class: Expressir::Model::Literals::Integer
          value: '3'
    - _class: Expressir::Model::Declarations::Type
      id: string_width_fixed_type
      underlying_type:
        _class: Expressir::Model::DataTypes::String
        width:
          _class: Expressir::Model::Literals::Integer
          value: '3'
        fixed: true
    - _class: Expressir::Model::Declarations::Type
      id: array_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Array
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: array_optional_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Array
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        optional: true
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: array_unique_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Array
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        unique: true
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: array_optional_unique_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Array
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        optional: true
        unique: true
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: bag_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Bag
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: bag_bound_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Bag
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: list_type
      underlying_type:
        _class: Expressir::Model::DataTypes::List
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: list_bound_type
      underlying_type:
        _class: Expressir::Model::DataTypes::List
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: list_unique_type
      underlying_type:
        _class: Expressir::Model::DataTypes::List
        unique: true
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: list_bound_unique_type
      underlying_type:
        _class: Expressir::Model::DataTypes::List
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        unique: true
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: set_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Set
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: set_bound_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Set
        bound1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        bound2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
        base_type:
          _class: Expressir::Model::DataTypes::String
    - _class: Expressir::Model::Declarations::Type
      id: select_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
    - _class: Expressir::Model::Declarations::Type
      id: select_extensible_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        extensible: true
    - _class: Expressir::Model::Declarations::Type
      id: select_extensible_generic_entity_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        extensible: true
        generic_entity: true
    - _class: Expressir::Model::Declarations::Type
      id: select_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        items:
        - _class: Expressir::Model::References::SimpleReference
          id: empty_type
          base_path: syntax_schema.empty_type
    - _class: Expressir::Model::Declarations::Type
      id: select_multiple_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        items:
        - _class: Expressir::Model::References::SimpleReference
          id: empty_type
          base_path: syntax_schema.empty_type
        - _class: Expressir::Model::References::SimpleReference
          id: empty_type
          base_path: syntax_schema.empty_type
    - _class: Expressir::Model::Declarations::Type
      id: select_based_on_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        based_on:
          _class: Expressir::Model::References::SimpleReference
          id: select_type
          base_path: syntax_schema.types.select_type
    - _class: Expressir::Model::Declarations::Type
      id: select_based_on_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        based_on:
          _class: Expressir::Model::References::SimpleReference
          id: select_type
          base_path: syntax_schema.types.select_type
        items:
        - _class: Expressir::Model::References::SimpleReference
          id: empty_type
          base_path: syntax_schema.empty_type
    - _class: Expressir::Model::Declarations::Type
      id: select_based_on_multiple_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Select
        based_on:
          _class: Expressir::Model::References::SimpleReference
          id: select_type
          base_path: syntax_schema.types.select_type
        items:
        - _class: Expressir::Model::References::SimpleReference
          id: empty_type
          base_path: syntax_schema.empty_type
        - _class: Expressir::Model::References::SimpleReference
          id: empty_type
          base_path: syntax_schema.empty_type
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_extensible_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        extensible: true
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: test
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_multiple_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: test
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: test2
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_based_on_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        based_on:
          _class: Expressir::Model::References::SimpleReference
          id: enumeration_type
          base_path: syntax_schema.types.enumeration_type
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_based_on_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        based_on:
          _class: Expressir::Model::References::SimpleReference
          id: enumeration_type
          base_path: syntax_schema.types.enumeration_type
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: test
    - _class: Expressir::Model::Declarations::Type
      id: enumeration_based_on_multiple_item_type
      underlying_type:
        _class: Expressir::Model::DataTypes::Enumeration
        based_on:
          _class: Expressir::Model::References::SimpleReference
          id: enumeration_type
          base_path: syntax_schema.types.enumeration_type
        items:
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: test
        - _class: Expressir::Model::DataTypes::EnumerationItem
          id: test2
    functions:
    - _class: Expressir::Model::Declarations::Function
      id: generic_type
      return_type:
        _class: Expressir::Model::DataTypes::Generic
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Function
      id: generic_label_type
      return_type:
        _class: Expressir::Model::DataTypes::Generic
        id: label
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Function
      id: generic_entity_type
      return_type:
        _class: Expressir::Model::DataTypes::GenericEntity
      statements:
      - _class: Expressir::Model::Statements::Null
    - _class: Expressir::Model::Declarations::Function
      id: generic_entity_label_type
      return_type:
        _class: Expressir::Model::DataTypes::GenericEntity
        id: label
      statements:
      - _class: Expressir::Model::Statements::Null
  - _class: Expressir::Model::Declarations::Procedure
    id: expressions
    variables:
    - _class: Expressir::Model::Declarations::Variable
      id: binary_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Binary
        value: '011110000111100001111000'
    - _class: Expressir::Model::Declarations::Variable
      id: integer_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Integer
        value: '999'
    - _class: Expressir::Model::Declarations::Variable
      id: true_logical_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: false_logical_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :FALSE
    - _class: Expressir::Model::Declarations::Variable
      id: unknown_logical_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Logical
        value: :UNKNOWN
    - _class: Expressir::Model::Declarations::Variable
      id: real_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::Real
        value: '999.999'
    - _class: Expressir::Model::Declarations::Variable
      id: simple_string_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::String
        value: xxx
    - _class: Expressir::Model::Declarations::Variable
      id: utf8_simple_string_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::String
        value: 'UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.'
    - _class: Expressir::Model::Declarations::Variable
      id: encoded_string_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Literals::String
        value: '000000780000007800000078'
        encoded: true
    - _class: Expressir::Model::Declarations::Variable
      id: const_e_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: CONST_E
    - _class: Expressir::Model::Declarations::Variable
      id: indeterminate_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: "?"
    - _class: Expressir::Model::Declarations::Variable
      id: pi_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: PI
    - _class: Expressir::Model::Declarations::Variable
      id: self_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: SELF
    - _class: Expressir::Model::Declarations::Variable
      id: abs_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: ABS
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: acos_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: ACOS
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: asin_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: ASIN
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: atan_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: ATAN
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: blength_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: BLENGTH
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: cos_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: COS
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: exists_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: EXISTS
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: exp_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: EXP
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: format_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: FORMAT
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: hibound_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: HIBOUND
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: hiindex_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: HIINDEX
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: length_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: LENGTH
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: lobound_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: LOBOUND
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: loindex_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: LOINDEX
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: log_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: LOG
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: log2_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: LOG2
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: log10_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: LOG10
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: nvl_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: NVL
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: odd_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: ODD
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: rolesof_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: ROLESOF
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: sin_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: SIN
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: sizeof_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: SIZEOF
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: sqrt_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: SQRT
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: tan_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: TAN
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: typeof_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: TYPEOF
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: usedin_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: USEDIN
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: value_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: VALUE
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: value_in_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: VALUE_IN
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: value_unique_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: VALUE_UNIQUE
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: plus_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::UnaryExpression
        operator: :PLUS
        operand:
          _class: Expressir::Model::Literals::Integer
          value: '4'
    - _class: Expressir::Model::Declarations::Variable
      id: plus_addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::UnaryExpression
        operator: :PLUS
        operand:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: minus_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::UnaryExpression
        operator: :MINUS
        operand:
          _class: Expressir::Model::Literals::Integer
          value: '4'
    - _class: Expressir::Model::Declarations::Variable
      id: minus_addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::UnaryExpression
        operator: :MINUS
        operand:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :ADDITION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: subtraction_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :SUBTRACTION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: multiplication_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :MULTIPLICATION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: real_division_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :REAL_DIVISION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: integer_division_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :INTEGER_DIVISION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: modulo_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :MODULO
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: exponentiation_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :EXPONENTIATION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: addition_addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :ADDITION
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '1'
    - _class: Expressir::Model::Declarations::Variable
      id: subtraction_subtraction_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :SUBTRACTION
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :SUBTRACTION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '1'
    - _class: Expressir::Model::Declarations::Variable
      id: addition_subtraction_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :SUBTRACTION
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '1'
    - _class: Expressir::Model::Declarations::Variable
      id: subtraction_addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :ADDITION
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :SUBTRACTION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '1'
    - _class: Expressir::Model::Declarations::Variable
      id: addition_multiplication_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :ADDITION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '8'
        operand2:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :MULTIPLICATION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: multiplication_addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :ADDITION
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :MULTIPLICATION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '8'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: parenthesis_addition_multiplication_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :MULTIPLICATION
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '8'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: multiplication_parenthesis_addition_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :MULTIPLICATION
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '8'
        operand2:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: equal_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :EQUAL
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: not_equal_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :NOT_EQUAL
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: instance_equal_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :INSTANCE_EQUAL
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: instance_not_equal_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :INSTANCE_NOT_EQUAL
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: lt_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :LESS_THAN
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: gt_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :GREATER_THAN
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: lte_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :LESS_THAN_OR_EQUAL
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: gte_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :GREATER_THAN_OR_EQUAL
        operand1:
          _class: Expressir::Model::Literals::Integer
          value: '4'
        operand2:
          _class: Expressir::Model::Literals::Integer
          value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: not_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::UnaryExpression
        operator: :NOT
        operand:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: not_or_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::UnaryExpression
        operator: :NOT
        operand:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :OR
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
    - _class: Expressir::Model::Declarations::Variable
      id: or_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :OR
        operand1:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        operand2:
          _class: Expressir::Model::Literals::Logical
          value: :FALSE
    - _class: Expressir::Model::Declarations::Variable
      id: and_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :AND
        operand1:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        operand2:
          _class: Expressir::Model::Literals::Logical
          value: :FALSE
    - _class: Expressir::Model::Declarations::Variable
      id: or_or_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :OR
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :OR
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
        operand2:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: and_and_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :AND
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :AND
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
        operand2:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: or_and_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :OR
        operand1:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        operand2:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :AND
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: and_or_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :OR
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :AND
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
        operand2:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: parenthesis_or_and_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :AND
        operand1:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :OR
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
        operand2:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: and_parenthesis_or_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :AND
        operand1:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        operand2:
          _class: Expressir::Model::Expressions::BinaryExpression
          operator: :OR
          operand1:
            _class: Expressir::Model::Literals::Logical
            value: :FALSE
          operand2:
            _class: Expressir::Model::Literals::Logical
            value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: combine_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :COMBINE
        operand1:
          _class: Expressir::Model::References::SimpleReference
          id: test
        operand2:
          _class: Expressir::Model::References::SimpleReference
          id: test2
    - _class: Expressir::Model::Declarations::Variable
      id: in_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :IN
        operand1:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
        operand2:
          _class: Expressir::Model::Expressions::AggregateInitializer
          items:
          - _class: Expressir::Model::Literals::Logical
            value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: like_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::BinaryExpression
        operator: :LIKE
        operand1:
          _class: Expressir::Model::Literals::String
          value: xxx
        operand2:
          _class: Expressir::Model::Literals::String
          value: xxx
    - _class: Expressir::Model::Declarations::Variable
      id: aggregate_initializer_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::AggregateInitializer
        items:
        - _class: Expressir::Model::Literals::Integer
          value: '4'
    - _class: Expressir::Model::Declarations::Variable
      id: repeated_aggregate_initializer_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::AggregateInitializer
        items:
        - _class: Expressir::Model::Expressions::AggregateInitializerItem
          expression:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          repetition:
            _class: Expressir::Model::Literals::Integer
            value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: complex_aggregate_initializer_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::AggregateInitializer
        items:
        - _class: Expressir::Model::Expressions::BinaryExpression
          operator: :ADDITION
          operand1:
            _class: Expressir::Model::Literals::Integer
            value: '4'
          operand2:
            _class: Expressir::Model::Literals::Integer
            value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: complex_repeated_aggregate_initializer_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::AggregateInitializer
        items:
        - _class: Expressir::Model::Expressions::AggregateInitializerItem
          expression:
            _class: Expressir::Model::Expressions::BinaryExpression
            operator: :ADDITION
            operand1:
              _class: Expressir::Model::Literals::Integer
              value: '4'
            operand2:
              _class: Expressir::Model::Literals::Integer
              value: '2'
          repetition:
            _class: Expressir::Model::Expressions::BinaryExpression
            operator: :ADDITION
            operand1:
              _class: Expressir::Model::Literals::Integer
              value: '4'
            operand2:
              _class: Expressir::Model::Literals::Integer
              value: '2'
    - _class: Expressir::Model::Declarations::Variable
      id: call_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::FunctionCall
        function:
          _class: Expressir::Model::References::SimpleReference
          id: parameter_function
          base_path: syntax_schema.parameter_function
        parameters:
        - _class: Expressir::Model::Literals::Logical
          value: :TRUE
    - _class: Expressir::Model::Declarations::Variable
      id: simple_reference_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::SimpleReference
        id: test
    - _class: Expressir::Model::Declarations::Variable
      id: group_reference_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::GroupReference
        ref:
          _class: Expressir::Model::References::SimpleReference
          id: test
        entity:
          _class: Expressir::Model::References::SimpleReference
          id: test2
    - _class: Expressir::Model::Declarations::Variable
      id: index_reference_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::IndexReference
        ref:
          _class: Expressir::Model::References::SimpleReference
          id: test
        index1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
    - _class: Expressir::Model::Declarations::Variable
      id: index2_reference_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::IndexReference
        ref:
          _class: Expressir::Model::References::SimpleReference
          id: test
        index1:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        index2:
          _class: Expressir::Model::Literals::Integer
          value: '9'
    - _class: Expressir::Model::Declarations::Variable
      id: attribute_reference_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::References::AttributeReference
        ref:
          _class: Expressir::Model::References::SimpleReference
          id: test
        attribute:
          _class: Expressir::Model::References::SimpleReference
          id: test2
    - _class: Expressir::Model::Declarations::Variable
      id: lt_lt_interval_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::Interval
        low:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        operator1: :LESS_THAN
        item:
          _class: Expressir::Model::Literals::Integer
          value: '5'
        operator2: :LESS_THAN
        high:
          _class: Expressir::Model::Literals::Integer
          value: '9'
    - _class: Expressir::Model::Declarations::Variable
      id: lte_lt_interval_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::Interval
        low:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        operator1: :LESS_THAN_OR_EQUAL
        item:
          _class: Expressir::Model::Literals::Integer
          value: '5'
        operator2: :LESS_THAN
        high:
          _class: Expressir::Model::Literals::Integer
          value: '9'
    - _class: Expressir::Model::Declarations::Variable
      id: lt_lte_interval_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::Interval
        low:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        operator1: :LESS_THAN
        item:
          _class: Expressir::Model::Literals::Integer
          value: '5'
        operator2: :LESS_THAN_OR_EQUAL
        high:
          _class: Expressir::Model::Literals::Integer
          value: '9'
    - _class: Expressir::Model::Declarations::Variable
      id: lte_lte_interval_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::Interval
        low:
          _class: Expressir::Model::Literals::Integer
          value: '1'
        operator1: :LESS_THAN_OR_EQUAL
        item:
          _class: Expressir::Model::Literals::Integer
          value: '5'
        operator2: :LESS_THAN_OR_EQUAL
        high:
          _class: Expressir::Model::Literals::Integer
          value: '9'
    - _class: Expressir::Model::Declarations::Variable
      id: query_expression
      type:
        _class: Expressir::Model::DataTypes::Boolean
      expression:
        _class: Expressir::Model::Expressions::QueryExpression
        id: test
        aggregate_source:
          _class: Expressir::Model::References::SimpleReference
          id: test2
        expression:
          _class: Expressir::Model::Literals::Logical
          value: :TRUE
--- END FILE: spec/syntax/syntax.yaml ---
--- START FILE: spec/syntax/syntax_formatted.exp ---
SCHEMA syntax_schema '{ISO standard 10303 part(41) object(1) version(8)}';

USE FROM contract_schema;
USE FROM contract_schema
  (contract);
USE FROM contract_schema
  (contract,
   contract2);
USE FROM contract_schema
  (contract AS contract2);
REFERENCE FROM contract_schema;
REFERENCE FROM contract_schema
  (contract);
REFERENCE FROM contract_schema
  (contract,
   contract2);
REFERENCE FROM contract_schema
  (contract AS contract2);

CONSTANT
  empty_constant : BOOLEAN := TRUE;
END_CONSTANT;

TYPE empty_type = BOOLEAN;
END_TYPE;

TYPE where_type = BOOLEAN;
WHERE
  TRUE;
END_TYPE;

TYPE where_label_type = BOOLEAN;
WHERE
  WR1: TRUE;
END_TYPE;

ENTITY empty_entity;
END_ENTITY;

ENTITY abstract_entity
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY abstract_supertype_entity
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY abstract_supertype_constraint_entity
  ABSTRACT SUPERTYPE OF (empty_entity);
END_ENTITY;

ENTITY supertype_constraint_entity
  SUPERTYPE OF (empty_entity);
END_ENTITY;

ENTITY subtype_entity
  SUBTYPE OF (empty_entity);
END_ENTITY;

ENTITY supertype_constraint_subtype_entity
  SUPERTYPE OF (empty_entity)
  SUBTYPE OF (empty_entity);
END_ENTITY;

ENTITY attribute_entity;
  test : BOOLEAN;
END_ENTITY;

ENTITY attribute_optional_entity;
  test : OPTIONAL BOOLEAN;
END_ENTITY;

ENTITY attribute_multiple_entity;
  test : BOOLEAN;
  test2 : BOOLEAN;
END_ENTITY;

ENTITY attribute_multiple_shorthand_entity;
  test : BOOLEAN;
  test2 : BOOLEAN;
END_ENTITY;

ENTITY attribute_redeclared_entity
  SUBTYPE OF (attribute_entity);
  SELF\attribute_entity.test : BOOLEAN;
END_ENTITY;

ENTITY attribute_redeclared_renamed_entity
  SUBTYPE OF (attribute_entity);
  SELF\attribute_entity.test RENAMED test2 : BOOLEAN;
END_ENTITY;

ENTITY derived_attribute_entity;
DERIVE
  test : BOOLEAN := TRUE;
END_ENTITY;

ENTITY derived_attribute_redeclared_entity
  SUBTYPE OF (attribute_entity);
DERIVE
  SELF\attribute_entity.test : BOOLEAN := TRUE;
END_ENTITY;

ENTITY derived_attribute_redeclared_renamed_entity
  SUBTYPE OF (attribute_entity);
DERIVE
  SELF\attribute_entity.test RENAMED test2 : BOOLEAN := TRUE;
END_ENTITY;

ENTITY inverse_attribute_entity;
INVERSE
  test : attribute_entity FOR test;
END_ENTITY;

ENTITY inverse_attribute_entity_entity;
INVERSE
  test : attribute_entity FOR attribute_entity.test;
END_ENTITY;

ENTITY inverse_attribute_set_entity;
INVERSE
  test : SET OF attribute_entity FOR test;
END_ENTITY;

ENTITY inverse_attribute_set_bound_entity;
INVERSE
  test : SET [1:9] OF attribute_entity FOR test;
END_ENTITY;

ENTITY inverse_attribute_bag_entity;
INVERSE
  test : BAG OF attribute_entity FOR test;
END_ENTITY;

ENTITY inverse_attribute_bag_bound_entity;
INVERSE
  test : BAG [1:9] OF attribute_entity FOR test;
END_ENTITY;

ENTITY inverse_attribute_redeclared_entity
  SUBTYPE OF (attribute_entity);
INVERSE
  SELF\attribute_entity.test : attribute_entity FOR test;
END_ENTITY;

ENTITY inverse_attribute_redeclared_renamed_entity
  SUBTYPE OF (attribute_entity);
INVERSE
  SELF\attribute_entity.test RENAMED test2 : attribute_entity FOR test;
END_ENTITY;

ENTITY unique_entity;
  test : BOOLEAN;
UNIQUE
  test;
END_ENTITY;

ENTITY unique_label_entity;
  test : BOOLEAN;
UNIQUE
  UR1: test;
END_ENTITY;

ENTITY unique_redeclared_entity
  SUBTYPE OF (attribute_entity);
UNIQUE
  SELF\attribute_entity.test;
END_ENTITY;

ENTITY unique_label_redeclared_entity
  SUBTYPE OF (attribute_entity);
UNIQUE
  UR1: SELF\attribute_entity.test;
END_ENTITY;

ENTITY where_entity;
WHERE
  TRUE;
END_ENTITY;

ENTITY where_label_entity;
WHERE
  WR1: TRUE;
END_ENTITY;

SUBTYPE_CONSTRAINT empty_subtype_constraint FOR empty_entity;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT abstract_supertype_subtype_constraint FOR empty_entity;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT total_over_subtype_constraint FOR empty_entity;
  TOTAL_OVER(a);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_subtype_constraint FOR empty_entity;
  a;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_andor_subtype_constraint FOR empty_entity;
  a ANDOR b;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_subtype_constraint FOR empty_entity;
  a AND b;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_andor_and_subtype_constraint FOR empty_entity;
  a ANDOR b AND c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_andor_subtype_constraint FOR empty_entity;
  a AND b ANDOR c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_parenthesis_andor_and_subtype_constraint FOR empty_entity;
  (a ANDOR b) AND c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_parenthesis_andor_subtype_constraint FOR empty_entity;
  a AND (b ANDOR c);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_subtype_constraint FOR empty_entity;
  ONEOF(a, b);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_oneof_subtype_constraint FOR empty_entity;
  a AND ONEOF(b, c);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_andor_oneof_subtype_constraint FOR empty_entity;
  a ANDOR ONEOF(b, c);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_and_subtype_constraint FOR empty_entity;
  ONEOF(a, b) AND c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_subtype_constraint FOR empty_entity;
  ONEOF(a, b) ANDOR c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_and_oneof_subtype_constraint FOR empty_entity;
  ONEOF(a, b) AND ONEOF(c, d);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_oneof_subtype_constraint FOR empty_entity;
  ONEOF(a, b) ANDOR ONEOF(c, d);
END_SUBTYPE_CONSTRAINT;

FUNCTION empty_function : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION parameter_function(test : BOOLEAN) : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION multiple_parameter_function(test : BOOLEAN;
                                     test2 : BOOLEAN) : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION multiple_shorthand_parameter_function(test : BOOLEAN;
                                               test2 : BOOLEAN) : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION type_function : BOOLEAN;
  TYPE test = BOOLEAN;
  END_TYPE;
  ;
END_FUNCTION;

FUNCTION constant_function : BOOLEAN;
  CONSTANT
    test : BOOLEAN := TRUE;
  END_CONSTANT;
  ;
END_FUNCTION;

FUNCTION multiple_constant_function : BOOLEAN;
  CONSTANT
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_CONSTANT;
  ;
END_FUNCTION;

FUNCTION variable_function : BOOLEAN;
  LOCAL
    test : BOOLEAN;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_variable_function : BOOLEAN;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_shorthand_variable_function : BOOLEAN;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION variable_expression_function : BOOLEAN;
  LOCAL
    test : BOOLEAN := TRUE;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_variable_expression_function : BOOLEAN;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_shorthand_variable_expression_function : BOOLEAN;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
  ;
END_FUNCTION;

RULE empty_rule FOR (empty_entity);
WHERE
  TRUE;
END_RULE;

RULE type_rule FOR (empty_entity);
  TYPE test = BOOLEAN;
  END_TYPE;
WHERE
  TRUE;
END_RULE;

RULE constant_rule FOR (empty_entity);
  CONSTANT
    test : BOOLEAN := TRUE;
  END_CONSTANT;
WHERE
  TRUE;
END_RULE;

RULE multiple_constant_rule FOR (empty_entity);
  CONSTANT
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_CONSTANT;
WHERE
  TRUE;
END_RULE;

RULE variable_rule FOR (empty_entity);
  LOCAL
    test : BOOLEAN;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_variable_rule FOR (empty_entity);
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_shorthand_variable_rule FOR (empty_entity);
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE variable_expression_rule FOR (empty_entity);
  LOCAL
    test : BOOLEAN := TRUE;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_variable_expression_rule FOR (empty_entity);
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_shorthand_variable_expression_rule FOR (empty_entity);
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE statement_rule FOR (empty_entity);
  ;
WHERE
  TRUE;
END_RULE;

RULE where_label_rule FOR (empty_entity);
WHERE
  WR1: TRUE;
END_RULE;

PROCEDURE empty_procedure;
END_PROCEDURE;

PROCEDURE parameter_procedure(test : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_parameter_procedure(test : BOOLEAN;
                                       test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_shorthand_parameter_procedure(test : BOOLEAN;
                                                 test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE variable_parameter_procedure(VAR test : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_variable_parameter_procedure(VAR test : BOOLEAN;
                                                test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_variable_parameter2_procedure(test : BOOLEAN;
                                                 VAR test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_shorthand_variable_parameter_procedure(VAR test : BOOLEAN;
                                                          VAR test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE type_procedure;
  TYPE test = BOOLEAN;
  END_TYPE;
END_PROCEDURE;

PROCEDURE constant_procedure;
  CONSTANT
    test : BOOLEAN := TRUE;
  END_CONSTANT;
END_PROCEDURE;

PROCEDURE multiple_constant_procedure;
  CONSTANT
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_CONSTANT;
END_PROCEDURE;

PROCEDURE variable_procedure;
  LOCAL
    test : BOOLEAN;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_variable_procedure;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_shorthand_variable_procedure;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE variable_expression_procedure;
  LOCAL
    test : BOOLEAN := TRUE;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_variable_expression_procedure;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_shorthand_variable_expression_procedure;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE statement_procedure;
  ;
END_PROCEDURE;

PROCEDURE statements;
  PROCEDURE alias_simple_reference_statement;
    ALIAS test FOR test;
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_group_reference_statement;
    ALIAS test FOR test\test2;
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_index_reference_statement;
    ALIAS test FOR test[1];
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_index2_reference_statement;
    ALIAS test FOR test[1:9];
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_attribute_reference_statement;
    ALIAS test FOR test.test2;
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE assignment_simple_reference_statement;
    test := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_group_reference_statement;
    test\test2 := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_index_reference_statement;
    test[1] := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_index2_reference_statement;
    test[1:9] := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_attribute_reference_statement;
    test.test2 := TRUE;
  END_PROCEDURE;
  PROCEDURE case_statement;
    CASE test OF
    TRUE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE case_multiple_statement;
    CASE test OF
    TRUE :
      ;
    TRUE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE case_multiple_shorthand_statement;
    CASE test OF
    TRUE, TRUE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE case_otherwise_statement;
    CASE test OF
    TRUE :
      ;
    OTHERWISE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE compound_statement;
    BEGIN
      ;
    END;
  END_PROCEDURE;
  PROCEDURE escape_statement;
    ESCAPE;
  END_PROCEDURE;
  PROCEDURE if_statement;
    IF TRUE THEN
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if2_statement;
    IF TRUE THEN
      ;
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if_else_statement;
    IF TRUE THEN
      ;
    ELSE
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if2_else_statement;
    IF TRUE THEN
      ;
      ;
    ELSE
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if_else2_statement;
    IF TRUE THEN
      ;
    ELSE
      ;
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if2_else2_statement;
    IF TRUE THEN
      ;
      ;
    ELSE
      ;
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE null_statement;
    ;
  END_PROCEDURE;
  PROCEDURE call_statement;
    empty_procedure;
  END_PROCEDURE;
  PROCEDURE call_parameter_statement;
    empty_procedure(TRUE);
  END_PROCEDURE;
  PROCEDURE call_parameter2_statement;
    empty_procedure(TRUE, TRUE);
  END_PROCEDURE;
  PROCEDURE call_insert_statement;
    INSERT(TRUE);
  END_PROCEDURE;
  PROCEDURE call_remove_statement;
    REMOVE(TRUE);
  END_PROCEDURE;
  PROCEDURE repeat_statement;
    REPEAT;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_variable_statement;
    REPEAT test := 1 TO 9;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_variable_increment_statement;
    REPEAT test := 1 TO 9 BY 2;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_while_statement;
    REPEAT WHILE TRUE;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_until_statement;
    REPEAT UNTIL TRUE;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE return_statement;
    RETURN;
  END_PROCEDURE;
  PROCEDURE return_expression_statement;
    RETURN (TRUE);
  END_PROCEDURE;
  PROCEDURE skip_statement;
    SKIP;
  END_PROCEDURE;
END_PROCEDURE;

PROCEDURE types;
  TYPE binary_type = BINARY;
  END_TYPE;
  TYPE binary_width_type = BINARY (3);
  END_TYPE;
  TYPE binary_width_fixed_type = BINARY (3) FIXED;
  END_TYPE;
  TYPE boolean_type = BOOLEAN;
  END_TYPE;
  TYPE integer_type = INTEGER;
  END_TYPE;
  TYPE logical_type = LOGICAL;
  END_TYPE;
  TYPE number_type = NUMBER;
  END_TYPE;
  TYPE real_type = REAL;
  END_TYPE;
  TYPE real_precision_type = REAL (3);
  END_TYPE;
  TYPE string_type = STRING;
  END_TYPE;
  TYPE string_width_type = STRING (3);
  END_TYPE;
  TYPE string_width_fixed_type = STRING (3) FIXED;
  END_TYPE;
  TYPE array_type = ARRAY [1:9] OF STRING;
  END_TYPE;
  TYPE array_optional_type = ARRAY [1:9] OF OPTIONAL STRING;
  END_TYPE;
  TYPE array_unique_type = ARRAY [1:9] OF UNIQUE STRING;
  END_TYPE;
  TYPE array_optional_unique_type = ARRAY [1:9] OF OPTIONAL UNIQUE STRING;
  END_TYPE;
  TYPE bag_type = BAG OF STRING;
  END_TYPE;
  TYPE bag_bound_type = BAG [1:9] OF STRING;
  END_TYPE;
  TYPE list_type = LIST OF STRING;
  END_TYPE;
  TYPE list_bound_type = LIST [1:9] OF STRING;
  END_TYPE;
  TYPE list_unique_type = LIST OF UNIQUE STRING;
  END_TYPE;
  TYPE list_bound_unique_type = LIST [1:9] OF UNIQUE STRING;
  END_TYPE;
  TYPE set_type = SET OF STRING;
  END_TYPE;
  TYPE set_bound_type = SET [1:9] OF STRING;
  END_TYPE;
  TYPE select_type = SELECT;
  END_TYPE;
  TYPE select_extensible_type = EXTENSIBLE SELECT;
  END_TYPE;
  TYPE select_extensible_generic_entity_type = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;
  TYPE select_item_type = SELECT
    (empty_type);
  END_TYPE;
  TYPE select_multiple_item_type = SELECT
    (empty_type,
     empty_type);
  END_TYPE;
  TYPE select_based_on_type = SELECT BASED_ON select_type;
  END_TYPE;
  TYPE select_based_on_item_type = SELECT BASED_ON select_type WITH
    (empty_type);
  END_TYPE;
  TYPE select_based_on_multiple_item_type = SELECT BASED_ON select_type WITH
    (empty_type,
     empty_type);
  END_TYPE;
  TYPE enumeration_type = ENUMERATION;
  END_TYPE;
  TYPE enumeration_extensible_type = EXTENSIBLE ENUMERATION;
  END_TYPE;
  TYPE enumeration_item_type = ENUMERATION OF
    (test);
  END_TYPE;
  TYPE enumeration_multiple_item_type = ENUMERATION OF
    (test,
     test2);
  END_TYPE;
  TYPE enumeration_based_on_type = ENUMERATION BASED_ON enumeration_type;
  END_TYPE;
  TYPE enumeration_based_on_item_type = ENUMERATION BASED_ON enumeration_type WITH
    (test);
  END_TYPE;
  TYPE enumeration_based_on_multiple_item_type = ENUMERATION BASED_ON enumeration_type WITH
    (test,
     test2);
  END_TYPE;
  FUNCTION generic_type : GENERIC;
    ;
  END_FUNCTION;
  FUNCTION generic_label_type : GENERIC:label;
    ;
  END_FUNCTION;
  FUNCTION generic_entity_type : GENERIC_ENTITY;
    ;
  END_FUNCTION;
  FUNCTION generic_entity_label_type : GENERIC_ENTITY:label;
    ;
  END_FUNCTION;
END_PROCEDURE;

PROCEDURE expressions;
  LOCAL
    binary_expression : BOOLEAN := %011110000111100001111000;
    integer_expression : BOOLEAN := 999;
    true_logical_expression : BOOLEAN := TRUE;
    false_logical_expression : BOOLEAN := FALSE;
    unknown_logical_expression : BOOLEAN := UNKNOWN;
    real_expression : BOOLEAN := 999.999;
    simple_string_expression : BOOLEAN := 'xxx';
    utf8_simple_string_expression : BOOLEAN := 'UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.';
    encoded_string_expression : BOOLEAN := "000000780000007800000078";
    const_e_expression : BOOLEAN := CONST_E;
    indeterminate_expression : BOOLEAN := ?;
    pi_expression : BOOLEAN := PI;
    self_expression : BOOLEAN := SELF;
    abs_expression : BOOLEAN := ABS(TRUE);
    acos_expression : BOOLEAN := ACOS(TRUE);
    asin_expression : BOOLEAN := ASIN(TRUE);
    atan_expression : BOOLEAN := ATAN(TRUE);
    blength_expression : BOOLEAN := BLENGTH(TRUE);
    cos_expression : BOOLEAN := COS(TRUE);
    exists_expression : BOOLEAN := EXISTS(TRUE);
    exp_expression : BOOLEAN := EXP(TRUE);
    format_expression : BOOLEAN := FORMAT(TRUE);
    hibound_expression : BOOLEAN := HIBOUND(TRUE);
    hiindex_expression : BOOLEAN := HIINDEX(TRUE);
    length_expression : BOOLEAN := LENGTH(TRUE);
    lobound_expression : BOOLEAN := LOBOUND(TRUE);
    loindex_expression : BOOLEAN := LOINDEX(TRUE);
    log_expression : BOOLEAN := LOG(TRUE);
    log2_expression : BOOLEAN := LOG2(TRUE);
    log10_expression : BOOLEAN := LOG10(TRUE);
    nvl_expression : BOOLEAN := NVL(TRUE);
    odd_expression : BOOLEAN := ODD(TRUE);
    rolesof_expression : BOOLEAN := ROLESOF(TRUE);
    sin_expression : BOOLEAN := SIN(TRUE);
    sizeof_expression : BOOLEAN := SIZEOF(TRUE);
    sqrt_expression : BOOLEAN := SQRT(TRUE);
    tan_expression : BOOLEAN := TAN(TRUE);
    typeof_expression : BOOLEAN := TYPEOF(TRUE);
    usedin_expression : BOOLEAN := USEDIN(TRUE);
    value_expression : BOOLEAN := VALUE(TRUE);
    value_in_expression : BOOLEAN := VALUE_IN(TRUE);
    value_unique_expression : BOOLEAN := VALUE_UNIQUE(TRUE);
    plus_expression : BOOLEAN := +4;
    plus_addition_expression : BOOLEAN := +(4 + 2);
    minus_expression : BOOLEAN := -4;
    minus_addition_expression : BOOLEAN := -(4 + 2);
    addition_expression : BOOLEAN := 4 + 2;
    subtraction_expression : BOOLEAN := 4 - 2;
    multiplication_expression : BOOLEAN := 4 * 2;
    real_division_expression : BOOLEAN := 4 / 2;
    integer_division_expression : BOOLEAN := 4 DIV 2;
    modulo_expression : BOOLEAN := 4 MOD 2;
    exponentiation_expression : BOOLEAN := 4 ** 2;
    addition_addition_expression : BOOLEAN := 4 + 2 + 1;
    subtraction_subtraction_expression : BOOLEAN := 4 - 2 - 1;
    addition_subtraction_expression : BOOLEAN := 4 + 2 - 1;
    subtraction_addition_expression : BOOLEAN := 4 - 2 + 1;
    addition_multiplication_expression : BOOLEAN := 8 + 4 * 2;
    multiplication_addition_expression : BOOLEAN := 8 * 4 + 2;
    parenthesis_addition_multiplication_expression : BOOLEAN := (8 + 4) * 2;
    multiplication_parenthesis_addition_expression : BOOLEAN := 8 * (4 + 2);
    equal_expression : BOOLEAN := 4 = 2;
    not_equal_expression : BOOLEAN := 4 <> 2;
    instance_equal_expression : BOOLEAN := 4 :=: 2;
    instance_not_equal_expression : BOOLEAN := 4 :<>: 2;
    lt_expression : BOOLEAN := 4 < 2;
    gt_expression : BOOLEAN := 4 > 2;
    lte_expression : BOOLEAN := 4 <= 2;
    gte_expression : BOOLEAN := 4 >= 2;
    not_expression : BOOLEAN := NOT TRUE;
    not_or_expression : BOOLEAN := NOT (TRUE OR FALSE);
    or_expression : BOOLEAN := TRUE OR FALSE;
    and_expression : BOOLEAN := TRUE AND FALSE;
    or_or_expression : BOOLEAN := TRUE OR FALSE OR TRUE;
    and_and_expression : BOOLEAN := TRUE AND FALSE AND TRUE;
    or_and_expression : BOOLEAN := TRUE OR FALSE AND TRUE;
    and_or_expression : BOOLEAN := TRUE AND FALSE OR TRUE;
    parenthesis_or_and_expression : BOOLEAN := (TRUE OR FALSE) AND TRUE;
    and_parenthesis_or_expression : BOOLEAN := TRUE AND (FALSE OR TRUE);
    combine_expression : BOOLEAN := test || test2;
    in_expression : BOOLEAN := TRUE IN [TRUE];
    like_expression : BOOLEAN := 'xxx' LIKE 'xxx';
    aggregate_initializer_expression : BOOLEAN := [4];
    repeated_aggregate_initializer_expression : BOOLEAN := [4:2];
    complex_aggregate_initializer_expression : BOOLEAN := [4 + 2];
    complex_repeated_aggregate_initializer_expression : BOOLEAN := [4 + 2:4 + 2];
    call_expression : BOOLEAN := parameter_function(TRUE);
    simple_reference_expression : BOOLEAN := test;
    group_reference_expression : BOOLEAN := test\test2;
    index_reference_expression : BOOLEAN := test[1];
    index2_reference_expression : BOOLEAN := test[1:9];
    attribute_reference_expression : BOOLEAN := test.test2;
    lt_lt_interval_expression : BOOLEAN := {1 < 5 < 9};
    lte_lt_interval_expression : BOOLEAN := {1 <= 5 < 9};
    lt_lte_interval_expression : BOOLEAN := {1 < 5 <= 9};
    lte_lte_interval_expression : BOOLEAN := {1 <= 5 <= 9};
    query_expression : BOOLEAN := QUERY(test <* test2 | TRUE);
  END_LOCAL;
END_PROCEDURE;

END_SCHEMA;
--- END FILE: spec/syntax/syntax_formatted.exp ---
--- START FILE: spec/syntax/syntax_hyperlink_formatted.exp ---
SCHEMA syntax_schema '{ISO standard 10303 part(41) object(1) version(8)}';

USE FROM contract_schema;
USE FROM contract_schema
  (contract);
USE FROM contract_schema
  (contract,
   contract2);
USE FROM contract_schema
  (contract AS contract2);
REFERENCE FROM contract_schema;
REFERENCE FROM contract_schema
  (contract);
REFERENCE FROM contract_schema
  (contract,
   contract2);
REFERENCE FROM contract_schema
  (contract AS contract2);

CONSTANT
  empty_constant : BOOLEAN := TRUE;
END_CONSTANT;

TYPE empty_type = BOOLEAN;
END_TYPE;

TYPE where_type = BOOLEAN;
WHERE
  TRUE;
END_TYPE;

TYPE where_label_type = BOOLEAN;
WHERE
  WR1: TRUE;
END_TYPE;

ENTITY empty_entity;
END_ENTITY;

ENTITY abstract_entity
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY abstract_supertype_entity
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY abstract_supertype_constraint_entity
  ABSTRACT SUPERTYPE OF ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
END_ENTITY;

ENTITY supertype_constraint_entity
  SUPERTYPE OF ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
END_ENTITY;

ENTITY subtype_entity
  SUBTYPE OF ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
END_ENTITY;

ENTITY supertype_constraint_subtype_entity
  SUPERTYPE OF ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}})
  SUBTYPE OF ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
END_ENTITY;

ENTITY attribute_entity;
  test : BOOLEAN;
END_ENTITY;

ENTITY attribute_optional_entity;
  test : OPTIONAL BOOLEAN;
END_ENTITY;

ENTITY attribute_multiple_entity;
  test : BOOLEAN;
  test2 : BOOLEAN;
END_ENTITY;

ENTITY attribute_multiple_shorthand_entity;
  test : BOOLEAN;
  test2 : BOOLEAN;
END_ENTITY;

ENTITY attribute_redeclared_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test : BOOLEAN;
END_ENTITY;

ENTITY attribute_redeclared_renamed_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test RENAMED test2 : BOOLEAN;
END_ENTITY;

ENTITY derived_attribute_entity;
DERIVE
  test : BOOLEAN := TRUE;
END_ENTITY;

ENTITY derived_attribute_redeclared_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
DERIVE
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test : BOOLEAN := TRUE;
END_ENTITY;

ENTITY derived_attribute_redeclared_renamed_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
DERIVE
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test RENAMED test2 : BOOLEAN := TRUE;
END_ENTITY;

ENTITY inverse_attribute_entity;
INVERSE
  test : {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY inverse_attribute_entity_entity;
INVERSE
  test : {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR attribute_entity.test;
END_ENTITY;

ENTITY inverse_attribute_set_entity;
INVERSE
  test : SET OF {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY inverse_attribute_set_bound_entity;
INVERSE
  test : SET [1:9] OF {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY inverse_attribute_bag_entity;
INVERSE
  test : BAG OF {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY inverse_attribute_bag_bound_entity;
INVERSE
  test : BAG [1:9] OF {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY inverse_attribute_redeclared_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
INVERSE
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test : {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY inverse_attribute_redeclared_renamed_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
INVERSE
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test RENAMED test2 : {{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}} FOR test;
END_ENTITY;

ENTITY unique_entity;
  test : BOOLEAN;
UNIQUE
  test;
END_ENTITY;

ENTITY unique_label_entity;
  test : BOOLEAN;
UNIQUE
  UR1: test;
END_ENTITY;

ENTITY unique_redeclared_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
UNIQUE
  SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test;
END_ENTITY;

ENTITY unique_label_redeclared_entity
  SUBTYPE OF ({{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}});
UNIQUE
  UR1: SELF\{{{<<express:syntax_schema.attribute_entity,attribute_entity>>}}}.test;
END_ENTITY;

ENTITY where_entity;
WHERE
  TRUE;
END_ENTITY;

ENTITY where_label_entity;
WHERE
  WR1: TRUE;
END_ENTITY;

SUBTYPE_CONSTRAINT empty_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT abstract_supertype_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT total_over_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  TOTAL_OVER(a);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_andor_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a ANDOR b;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a AND b;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_andor_and_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a ANDOR b AND c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_andor_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a AND b ANDOR c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_parenthesis_andor_and_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  (a ANDOR b) AND c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_parenthesis_andor_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a AND (b ANDOR c);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  ONEOF(a, b);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_and_oneof_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a AND ONEOF(b, c);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_andor_oneof_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  a ANDOR ONEOF(b, c);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_and_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  ONEOF(a, b) AND c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  ONEOF(a, b) ANDOR c;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_and_oneof_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  ONEOF(a, b) AND ONEOF(c, d);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_oneof_subtype_constraint FOR {{{<<express:syntax_schema.empty_entity,empty_entity>>}}};
  ONEOF(a, b) ANDOR ONEOF(c, d);
END_SUBTYPE_CONSTRAINT;

FUNCTION empty_function : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION parameter_function(test : BOOLEAN) : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION multiple_parameter_function(test : BOOLEAN;
                                     test2 : BOOLEAN) : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION multiple_shorthand_parameter_function(test : BOOLEAN;
                                               test2 : BOOLEAN) : BOOLEAN;
  ;
END_FUNCTION;

FUNCTION type_function : BOOLEAN;
  TYPE test = BOOLEAN;
  END_TYPE;
  ;
END_FUNCTION;

FUNCTION constant_function : BOOLEAN;
  CONSTANT
    test : BOOLEAN := TRUE;
  END_CONSTANT;
  ;
END_FUNCTION;

FUNCTION multiple_constant_function : BOOLEAN;
  CONSTANT
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_CONSTANT;
  ;
END_FUNCTION;

FUNCTION variable_function : BOOLEAN;
  LOCAL
    test : BOOLEAN;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_variable_function : BOOLEAN;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_shorthand_variable_function : BOOLEAN;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION variable_expression_function : BOOLEAN;
  LOCAL
    test : BOOLEAN := TRUE;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_variable_expression_function : BOOLEAN;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
  ;
END_FUNCTION;

FUNCTION multiple_shorthand_variable_expression_function : BOOLEAN;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
  ;
END_FUNCTION;

RULE empty_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
WHERE
  TRUE;
END_RULE;

RULE type_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  TYPE test = BOOLEAN;
  END_TYPE;
WHERE
  TRUE;
END_RULE;

RULE constant_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  CONSTANT
    test : BOOLEAN := TRUE;
  END_CONSTANT;
WHERE
  TRUE;
END_RULE;

RULE multiple_constant_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  CONSTANT
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_CONSTANT;
WHERE
  TRUE;
END_RULE;

RULE variable_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  LOCAL
    test : BOOLEAN;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_variable_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_shorthand_variable_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE variable_expression_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  LOCAL
    test : BOOLEAN := TRUE;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_variable_expression_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE multiple_shorthand_variable_expression_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
WHERE
  TRUE;
END_RULE;

RULE statement_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
  ;
WHERE
  TRUE;
END_RULE;

RULE where_label_rule FOR ({{{<<express:syntax_schema.empty_entity,empty_entity>>}}});
WHERE
  WR1: TRUE;
END_RULE;

PROCEDURE empty_procedure;
END_PROCEDURE;

PROCEDURE parameter_procedure(test : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_parameter_procedure(test : BOOLEAN;
                                       test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_shorthand_parameter_procedure(test : BOOLEAN;
                                                 test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE variable_parameter_procedure(VAR test : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_variable_parameter_procedure(VAR test : BOOLEAN;
                                                test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_variable_parameter2_procedure(test : BOOLEAN;
                                                 VAR test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE multiple_shorthand_variable_parameter_procedure(VAR test : BOOLEAN;
                                                          VAR test2 : BOOLEAN);
END_PROCEDURE;

PROCEDURE type_procedure;
  TYPE test = BOOLEAN;
  END_TYPE;
END_PROCEDURE;

PROCEDURE constant_procedure;
  CONSTANT
    test : BOOLEAN := TRUE;
  END_CONSTANT;
END_PROCEDURE;

PROCEDURE multiple_constant_procedure;
  CONSTANT
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_CONSTANT;
END_PROCEDURE;

PROCEDURE variable_procedure;
  LOCAL
    test : BOOLEAN;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_variable_procedure;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_shorthand_variable_procedure;
  LOCAL
    test : BOOLEAN;
    test2 : BOOLEAN;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE variable_expression_procedure;
  LOCAL
    test : BOOLEAN := TRUE;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_variable_expression_procedure;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE multiple_shorthand_variable_expression_procedure;
  LOCAL
    test : BOOLEAN := TRUE;
    test2 : BOOLEAN := TRUE;
  END_LOCAL;
END_PROCEDURE;

PROCEDURE statement_procedure;
  ;
END_PROCEDURE;

PROCEDURE statements;
  PROCEDURE alias_simple_reference_statement;
    ALIAS test FOR test;
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_group_reference_statement;
    ALIAS test FOR test\test2;
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_index_reference_statement;
    ALIAS test FOR test[1];
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_index2_reference_statement;
    ALIAS test FOR test[1:9];
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE alias_attribute_reference_statement;
    ALIAS test FOR test.test2;
      ;
    END_ALIAS;
  END_PROCEDURE;
  PROCEDURE assignment_simple_reference_statement;
    test := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_group_reference_statement;
    test\test2 := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_index_reference_statement;
    test[1] := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_index2_reference_statement;
    test[1:9] := TRUE;
  END_PROCEDURE;
  PROCEDURE assignment_attribute_reference_statement;
    test.test2 := TRUE;
  END_PROCEDURE;
  PROCEDURE case_statement;
    CASE test OF
    TRUE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE case_multiple_statement;
    CASE test OF
    TRUE :
      ;
    TRUE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE case_multiple_shorthand_statement;
    CASE test OF
    TRUE, TRUE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE case_otherwise_statement;
    CASE test OF
    TRUE :
      ;
    OTHERWISE :
      ;
    END_CASE;
  END_PROCEDURE;
  PROCEDURE compound_statement;
    BEGIN
      ;
    END;
  END_PROCEDURE;
  PROCEDURE escape_statement;
    ESCAPE;
  END_PROCEDURE;
  PROCEDURE if_statement;
    IF TRUE THEN
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if2_statement;
    IF TRUE THEN
      ;
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if_else_statement;
    IF TRUE THEN
      ;
    ELSE
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if2_else_statement;
    IF TRUE THEN
      ;
      ;
    ELSE
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if_else2_statement;
    IF TRUE THEN
      ;
    ELSE
      ;
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE if2_else2_statement;
    IF TRUE THEN
      ;
      ;
    ELSE
      ;
      ;
    END_IF;
  END_PROCEDURE;
  PROCEDURE null_statement;
    ;
  END_PROCEDURE;
  PROCEDURE call_statement;
    {{{<<express:syntax_schema.empty_procedure,empty_procedure>>}}};
  END_PROCEDURE;
  PROCEDURE call_parameter_statement;
    {{{<<express:syntax_schema.empty_procedure,empty_procedure>>}}}(TRUE);
  END_PROCEDURE;
  PROCEDURE call_parameter2_statement;
    {{{<<express:syntax_schema.empty_procedure,empty_procedure>>}}}(TRUE, TRUE);
  END_PROCEDURE;
  PROCEDURE call_insert_statement;
    INSERT(TRUE);
  END_PROCEDURE;
  PROCEDURE call_remove_statement;
    REMOVE(TRUE);
  END_PROCEDURE;
  PROCEDURE repeat_statement;
    REPEAT;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_variable_statement;
    REPEAT test := 1 TO 9;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_variable_increment_statement;
    REPEAT test := 1 TO 9 BY 2;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_while_statement;
    REPEAT WHILE TRUE;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE repeat_until_statement;
    REPEAT UNTIL TRUE;
      ;
    END_REPEAT;
  END_PROCEDURE;
  PROCEDURE return_statement;
    RETURN;
  END_PROCEDURE;
  PROCEDURE return_expression_statement;
    RETURN (TRUE);
  END_PROCEDURE;
  PROCEDURE skip_statement;
    SKIP;
  END_PROCEDURE;
END_PROCEDURE;

PROCEDURE types;
  TYPE binary_type = BINARY;
  END_TYPE;
  TYPE binary_width_type = BINARY (3);
  END_TYPE;
  TYPE binary_width_fixed_type = BINARY (3) FIXED;
  END_TYPE;
  TYPE boolean_type = BOOLEAN;
  END_TYPE;
  TYPE integer_type = INTEGER;
  END_TYPE;
  TYPE logical_type = LOGICAL;
  END_TYPE;
  TYPE number_type = NUMBER;
  END_TYPE;
  TYPE real_type = REAL;
  END_TYPE;
  TYPE real_precision_type = REAL (3);
  END_TYPE;
  TYPE string_type = STRING;
  END_TYPE;
  TYPE string_width_type = STRING (3);
  END_TYPE;
  TYPE string_width_fixed_type = STRING (3) FIXED;
  END_TYPE;
  TYPE array_type = ARRAY [1:9] OF STRING;
  END_TYPE;
  TYPE array_optional_type = ARRAY [1:9] OF OPTIONAL STRING;
  END_TYPE;
  TYPE array_unique_type = ARRAY [1:9] OF UNIQUE STRING;
  END_TYPE;
  TYPE array_optional_unique_type = ARRAY [1:9] OF OPTIONAL UNIQUE STRING;
  END_TYPE;
  TYPE bag_type = BAG OF STRING;
  END_TYPE;
  TYPE bag_bound_type = BAG [1:9] OF STRING;
  END_TYPE;
  TYPE list_type = LIST OF STRING;
  END_TYPE;
  TYPE list_bound_type = LIST [1:9] OF STRING;
  END_TYPE;
  TYPE list_unique_type = LIST OF UNIQUE STRING;
  END_TYPE;
  TYPE list_bound_unique_type = LIST [1:9] OF UNIQUE STRING;
  END_TYPE;
  TYPE set_type = SET OF STRING;
  END_TYPE;
  TYPE set_bound_type = SET [1:9] OF STRING;
  END_TYPE;
  TYPE select_type = SELECT;
  END_TYPE;
  TYPE select_extensible_type = EXTENSIBLE SELECT;
  END_TYPE;
  TYPE select_extensible_generic_entity_type = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;
  TYPE select_item_type = SELECT
    ({{{<<express:syntax_schema.empty_type,empty_type>>}}});
  END_TYPE;
  TYPE select_multiple_item_type = SELECT
    ({{{<<express:syntax_schema.empty_type,empty_type>>}}},
     {{{<<express:syntax_schema.empty_type,empty_type>>}}});
  END_TYPE;
  TYPE select_based_on_type = SELECT BASED_ON select_type;
  END_TYPE;
  TYPE select_based_on_item_type = SELECT BASED_ON select_type WITH
    ({{{<<express:syntax_schema.empty_type,empty_type>>}}});
  END_TYPE;
  TYPE select_based_on_multiple_item_type = SELECT BASED_ON select_type WITH
    ({{{<<express:syntax_schema.empty_type,empty_type>>}}},
     {{{<<express:syntax_schema.empty_type,empty_type>>}}});
  END_TYPE;
  TYPE enumeration_type = ENUMERATION;
  END_TYPE;
  TYPE enumeration_extensible_type = EXTENSIBLE ENUMERATION;
  END_TYPE;
  TYPE enumeration_item_type = ENUMERATION OF
    (test);
  END_TYPE;
  TYPE enumeration_multiple_item_type = ENUMERATION OF
    (test,
     test2);
  END_TYPE;
  TYPE enumeration_based_on_type = ENUMERATION BASED_ON enumeration_type;
  END_TYPE;
  TYPE enumeration_based_on_item_type = ENUMERATION BASED_ON enumeration_type WITH
    (test);
  END_TYPE;
  TYPE enumeration_based_on_multiple_item_type = ENUMERATION BASED_ON enumeration_type WITH
    (test,
     test2);
  END_TYPE;
  FUNCTION generic_type : GENERIC;
    ;
  END_FUNCTION;
  FUNCTION generic_label_type : GENERIC:label;
    ;
  END_FUNCTION;
  FUNCTION generic_entity_type : GENERIC_ENTITY;
    ;
  END_FUNCTION;
  FUNCTION generic_entity_label_type : GENERIC_ENTITY:label;
    ;
  END_FUNCTION;
END_PROCEDURE;

PROCEDURE expressions;
  LOCAL
    binary_expression : BOOLEAN := %011110000111100001111000;
    integer_expression : BOOLEAN := 999;
    true_logical_expression : BOOLEAN := TRUE;
    false_logical_expression : BOOLEAN := FALSE;
    unknown_logical_expression : BOOLEAN := UNKNOWN;
    real_expression : BOOLEAN := 999.999;
    simple_string_expression : BOOLEAN := 'xxx';
    utf8_simple_string_expression : BOOLEAN := 'UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.';
    encoded_string_expression : BOOLEAN := "000000780000007800000078";
    const_e_expression : BOOLEAN := CONST_E;
    indeterminate_expression : BOOLEAN := ?;
    pi_expression : BOOLEAN := PI;
    self_expression : BOOLEAN := SELF;
    abs_expression : BOOLEAN := ABS(TRUE);
    acos_expression : BOOLEAN := ACOS(TRUE);
    asin_expression : BOOLEAN := ASIN(TRUE);
    atan_expression : BOOLEAN := ATAN(TRUE);
    blength_expression : BOOLEAN := BLENGTH(TRUE);
    cos_expression : BOOLEAN := COS(TRUE);
    exists_expression : BOOLEAN := EXISTS(TRUE);
    exp_expression : BOOLEAN := EXP(TRUE);
    format_expression : BOOLEAN := FORMAT(TRUE);
    hibound_expression : BOOLEAN := HIBOUND(TRUE);
    hiindex_expression : BOOLEAN := HIINDEX(TRUE);
    length_expression : BOOLEAN := LENGTH(TRUE);
    lobound_expression : BOOLEAN := LOBOUND(TRUE);
    loindex_expression : BOOLEAN := LOINDEX(TRUE);
    log_expression : BOOLEAN := LOG(TRUE);
    log2_expression : BOOLEAN := LOG2(TRUE);
    log10_expression : BOOLEAN := LOG10(TRUE);
    nvl_expression : BOOLEAN := NVL(TRUE);
    odd_expression : BOOLEAN := ODD(TRUE);
    rolesof_expression : BOOLEAN := ROLESOF(TRUE);
    sin_expression : BOOLEAN := SIN(TRUE);
    sizeof_expression : BOOLEAN := SIZEOF(TRUE);
    sqrt_expression : BOOLEAN := SQRT(TRUE);
    tan_expression : BOOLEAN := TAN(TRUE);
    typeof_expression : BOOLEAN := TYPEOF(TRUE);
    usedin_expression : BOOLEAN := USEDIN(TRUE);
    value_expression : BOOLEAN := VALUE(TRUE);
    value_in_expression : BOOLEAN := VALUE_IN(TRUE);
    value_unique_expression : BOOLEAN := VALUE_UNIQUE(TRUE);
    plus_expression : BOOLEAN := +4;
    plus_addition_expression : BOOLEAN := +(4 + 2);
    minus_expression : BOOLEAN := -4;
    minus_addition_expression : BOOLEAN := -(4 + 2);
    addition_expression : BOOLEAN := 4 + 2;
    subtraction_expression : BOOLEAN := 4 - 2;
    multiplication_expression : BOOLEAN := 4 * 2;
    real_division_expression : BOOLEAN := 4 / 2;
    integer_division_expression : BOOLEAN := 4 DIV 2;
    modulo_expression : BOOLEAN := 4 MOD 2;
    exponentiation_expression : BOOLEAN := 4 ** 2;
    addition_addition_expression : BOOLEAN := 4 + 2 + 1;
    subtraction_subtraction_expression : BOOLEAN := 4 - 2 - 1;
    addition_subtraction_expression : BOOLEAN := 4 + 2 - 1;
    subtraction_addition_expression : BOOLEAN := 4 - 2 + 1;
    addition_multiplication_expression : BOOLEAN := 8 + 4 * 2;
    multiplication_addition_expression : BOOLEAN := 8 * 4 + 2;
    parenthesis_addition_multiplication_expression : BOOLEAN := (8 + 4) * 2;
    multiplication_parenthesis_addition_expression : BOOLEAN := 8 * (4 + 2);
    equal_expression : BOOLEAN := 4 = 2;
    not_equal_expression : BOOLEAN := 4 <> 2;
    instance_equal_expression : BOOLEAN := 4 :=: 2;
    instance_not_equal_expression : BOOLEAN := 4 :<>: 2;
    lt_expression : BOOLEAN := 4 < 2;
    gt_expression : BOOLEAN := 4 > 2;
    lte_expression : BOOLEAN := 4 <= 2;
    gte_expression : BOOLEAN := 4 >= 2;
    not_expression : BOOLEAN := NOT TRUE;
    not_or_expression : BOOLEAN := NOT (TRUE OR FALSE);
    or_expression : BOOLEAN := TRUE OR FALSE;
    and_expression : BOOLEAN := TRUE AND FALSE;
    or_or_expression : BOOLEAN := TRUE OR FALSE OR TRUE;
    and_and_expression : BOOLEAN := TRUE AND FALSE AND TRUE;
    or_and_expression : BOOLEAN := TRUE OR FALSE AND TRUE;
    and_or_expression : BOOLEAN := TRUE AND FALSE OR TRUE;
    parenthesis_or_and_expression : BOOLEAN := (TRUE OR FALSE) AND TRUE;
    and_parenthesis_or_expression : BOOLEAN := TRUE AND (FALSE OR TRUE);
    combine_expression : BOOLEAN := test || test2;
    in_expression : BOOLEAN := TRUE IN [TRUE];
    like_expression : BOOLEAN := 'xxx' LIKE 'xxx';
    aggregate_initializer_expression : BOOLEAN := [4];
    repeated_aggregate_initializer_expression : BOOLEAN := [4:2];
    complex_aggregate_initializer_expression : BOOLEAN := [4 + 2];
    complex_repeated_aggregate_initializer_expression : BOOLEAN := [4 + 2:4 + 2];
    call_expression : BOOLEAN := {{{<<express:syntax_schema.parameter_function,parameter_function>>}}}(TRUE);
    simple_reference_expression : BOOLEAN := test;
    group_reference_expression : BOOLEAN := test\test2;
    index_reference_expression : BOOLEAN := test[1];
    index2_reference_expression : BOOLEAN := test[1:9];
    attribute_reference_expression : BOOLEAN := test.test2;
    lt_lt_interval_expression : BOOLEAN := {1 < 5 < 9};
    lte_lt_interval_expression : BOOLEAN := {1 <= 5 < 9};
    lt_lte_interval_expression : BOOLEAN := {1 < 5 <= 9};
    lte_lte_interval_expression : BOOLEAN := {1 <= 5 <= 9};
    query_expression : BOOLEAN := QUERY(test <* test2 | TRUE);
  END_LOCAL;
END_PROCEDURE;

END_SCHEMA;
--- END FILE: spec/syntax/syntax_hyperlink_formatted.exp ---
--- START FILE: spec/syntax/syntax_schema_head_formatted.exp ---
SCHEMA syntax_schema '{ISO standard 10303 part(41) object(1) version(8)}';

USE FROM contract_schema;
USE FROM contract_schema
  (contract);
USE FROM contract_schema
  (contract,
   contract2);
USE FROM contract_schema
  (contract AS contract2);
REFERENCE FROM contract_schema;
REFERENCE FROM contract_schema
  (contract);
REFERENCE FROM contract_schema
  (contract,
   contract2);
REFERENCE FROM contract_schema
  (contract AS contract2);
--- END FILE: spec/syntax/syntax_schema_head_formatted.exp ---
